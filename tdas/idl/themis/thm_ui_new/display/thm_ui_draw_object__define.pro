;+
;NAME:
; thm_ui_draw_object
;
;PURPOSE:
; This object generates an object graphics tree using the IDLgr* objects that are built
; into IDL.  It generates this tree by querying the loaded data object and the window storage
; object to get the settings generated by the panel.  This object also performs other utility
; operations related to drawing.  These include animations of vertical bars and markers, updating
; the legend by performing a lookup in a hashed version of the plotted data, and reporting information
; about the current display.(Cursor segment selected,  range of displayed data, etc...)
;
; There are a few major functions in this object.
; #1 'update': will update the draw area to correspond to new settings
; #2 'setCursor' : actually makes the draw object do all the animation updates
; #3 'draw' : use it to force the object to redraw the draw area.\
; #4 'getInfo(panelIndex)' : get a struct with information about a panel in the currently drawn display
;                            This includes information like the actual range and scaling for each axis, the number of tics, etc...
;
;NOTES:
; 1. May want to try to split functions organizationally into functions related to update and static drawing, vs.
;    functions related to setCursor and dynamic drawing.
;    
; 2. In almost all cases ranges will be stored and passed around as 2-element arrays.
;    If they are on log scaled axis, the ranges will be in log space, this tends to make some calculations simpler(and others more complex)
;    By log space, I mean, if scaling eq 1 then range = alog10(normalRange), if scaling eq 2 then range = alog(normalRange)
;    
; 3. The codes used for different scaling values are consistent.  0 indicates linear scaling, 1 indicates base 10 logarithm, 2 indicates natural logarithm
; 
; 4. Positions in this code are generally specified in one of three different coordinate systems.  
;    a.  They are normalized to the draw area.  So [.5,.5] is the center of the draw area.
;    b.  They are normalized to the panel.  So [.5,.5] is the center of a panel.
;    c.  They are specified in pixels.  Often when pixels are used, the value used may actually be 2x or 4x the actual number of screen pixels to prevent aliasing.
;    
;    Somewhat ambiguously, c. is sometimes called points(because it is a scaled number of pixels).  This is not the same as the measurement in note 5.
; 
;    Rectangles(like panels) will normally be specified using two variables, which are each 2 element doubles.
;    xpos = [xstart,xstop],  ypos = [ystart,stop]  These are absolute locations. 
;    The alternative representation [xstart,xsize],[ystart,ysize], is rarely, if ever, used as a parameter,
;    although sizes are used for various computations throughout the code.
;    
; 5. distances that aren't specified in the above coordinates are often specified in pts. 
;    This is a desktop publishing standard, that ideally is consistent across output devices.  1 pt should be 127/360 mm.
;    The goal is to make all output consistent across output devices.
;    
; 
;
;$LastChangedBy: pcruce $
;$LastChangedDate: 2010-03-03 12:08:53 -0800 (Wed, 03 Mar 2010) $
;$LastChangedRevision: 7393 $
;$URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/thmsoc/tags/tdas_5_21/idl/themis/thm_ui_new/display/thm_ui_draw_object__define.pro $
;-

;Makes a vertical bar, updates legends, draws rubber band,
;draws markers(during draw animation), highlights markers
;during mouseover. 
;This routine should be called pretty much
;any time the cursor moves in the draw area.
;
;Location(2-element double):  The cursor location
;in coordinates normalized to the draw area size.  
pro thm_ui_draw_object::setCursor,location

  compile_opt idl2
  
 ; tm = systime(/seconds)
  
  self.cursorloc = location
  
  ;update the position of the vertical and horizontal bar
  self->updateVBar,location,self.panelInfo
  self->updateHBar,location,self.panelInfo
  
  ;If the rubber band is turned on then update its position when
  ;the cursor position is updated
  if self.rubberOn then begin
  
    if ~self->rubberBand(self.rubberStart,self.cursorLoc - self.rubberStart) then begin
      self.statusBar->update,'Problem drawing rubber band'
    ;t=error_message('Problem drawing rubber band',/traceback)
    endif
    
  endif
  
  ;Single panel legend update block
  if self.legendOn eq 1 && ptr_valid(self.panelInfo) then begin
  
    ;loop over panels
    for i = 0,n_elements(*self.panelInfo)-1 do begin
    
      panel = ((*self.panelInfo)[i])
      
      ;if the cursor is within this panel then update the legend
      if self->inBounds(panel) then begin
      
        ;calculate normalized position of cursor relative to the panel
        xposnorm = (location[0] - panel.xplotpos[0])/(panel.xplotpos[1]-panel.xplotpos[0])
        yposnorm = (location[1] - panel.yplotpos[0])/(panel.yplotpos[1]-panel.yplotpos[0])
        
        ;turn on the legend model(so the legend will be visible)
        if obj_valid(panel.legendModel) then begin
          panel.legendModel->setProperty,hide=0
        endif
        
        ;turn on the annotation model(the actual text objects that the numbers are drawn to are stored in these models)
        if obj_valid(panel.legendAnnoModel) then begin
          panel.legendAnnoModel->setProperty,hide=0
        endif
        
        ;make any variable annotations visible for this panel
        self->setVarHide,panel,0
        
        ;now update the values in the legend for this panel
        self->updatelegend,[xposnorm,yposnorm],panel
        
      endif else begin
      
        ;if we're out of bounds, hide everything
        if obj_valid(panel.legendModel) then begin
          panel.legendModel->setProperty,hide=1
        endif
        
        if obj_valid(panel.legendAnnoModel) then begin
          panel.legendAnnoModel->setProperty,hide=1
        endif
        
        self->setVarHide,panel,1
      
        ;self->updateLegend,0,0,panel,/blank
        
      endelse
      
    endfor
    
  ;multiple panel legend update block
  endif else if self.legendOn eq 2 && ptr_valid(self.panelInfo) then begin
  
    drawlegend = 0
    
    ;if the cursor is within the bounds of *any* panel, then we update all panels
    ;with values proportional to the panel that the cursor is currently positioned over
    for i = 0,n_elements(*self.panelInfo)-1 do begin
    
      panel = ((*self.panelInfo)[i])
      
      if self->inBounds(panel) then begin
      
        drawlegend = 1
        inBoundsIndex = i
        xposnorm = (location[0] - panel.xplotpos[0])/(panel.xplotpos[1]-panel.xplotpos[0])
        yposnorm = (location[1] - panel.yplotpos[0])/(panel.yplotpos[1]-panel.yplotpos[0])
        
      endif
      
    endfor
    
    ;this block actually does the updating
    if drawlegend then begin
      for i = 0,n_elements(*self.panelInfo)-1 do begin
      
        panel = ((*self.panelInfo)[i])
        
        ;turn on the legend model(so the legend will be visible)
        if obj_valid(panel.legendModel) then begin
          panel.legendModel->setProperty,hide=0
        endif
        
        ;turn on the annotation model(the actual text objects that the numbers are drawn to are stored in these models)
        if obj_valid(panel.legendAnnoModel) then begin
          panel.legendAnnoModel->setProperty,hide=0
        endif
        
        ;make any variable annotations visible for this panel
        self->setVarHide,panel,0
             
        if i eq inBoundsIndex then begin
          self->updatelegend,[xposnorm,yposnorm],panel
        endif else begin
          self->updatelegend,[xposnorm,yposnorm],panel,/noyvalue  
        endelse
        
      endfor
    endif else begin ;if we aren't drawing blank the text
    
      for i = 0,n_elements(*self.panelInfo)-1 do begin
      
        panel = ((*self.panelInfo)[i])
        
        ;if we're out of bounds, hide everything
        if obj_valid(panel.legendModel) then begin
          panel.legendModel->setProperty,hide=1
        endif
      
        if obj_valid(panel.legendAnnoModel) then begin
          panel.legendAnnoModel->setProperty,hide=1
        endif
      
        self->setVarHide,panel,1
        
        self->updateLegend,[0,0],panel,/blank
      endfor
      
    endelse
  endif else if ptr_valid(self.panelInfo) then begin
  
    ;loop over panels
    for i = 0,n_elements(*self.panelInfo)-1 do begin
    
      panel = ((*self.panelInfo)[i])
  
      ;if we're out of bounds, hide everything
      if obj_valid(panel.legendModel) then begin
        panel.legendModel->setProperty,hide=1
      endif
      
      if obj_valid(panel.legendAnnoModel) then begin
        panel.legendAnnoModel->setProperty,hide=1
      endif
      
      self->setVarHide,panel,1
    
    endfor
  
  endif
  
  ;Determine if marker should be drawn on cursor update
  ;Single panel marking
  ;This block executes when we are in the process of drawing a new marker
  if self.markerOn eq 1 && $
    ptr_valid(self.panelInfo) && $
    ptr_valid(self.currentMarkers) then begin
    
    panels = *self.panelInfo
    
    ;finds out if the cursor is over a panel and updates the marker position if it is
    for i=0,n_elements(panels)-1 do begin
      if self->inBounds(panels[i]) && $
        self->inBounds(panels[i],location=self.markerStart) then begin
        
        xstart = (self.markerStart[0] - panels[i].xplotpos[0])/(panels[i].xplotpos[1]-panels[i].xplotpos[0])
        xstop = (self.cursorloc[0] - panels[i].xplotpos[0])/(panels[i].xplotpos[1]-panels[i].xplotpos[0])
        
        self->drawMarker,[xstart,xstop],panels[i],(*self.currentMarkers)[0]
        
      endif
      
    endfor
    
  ;multiple panel marking
  ;This block executes when new markers are being drawn on all panels
  endif else if self.markerOn eq 2 && $
    ptr_valid(self.panelInfo) && $
    ptr_valid(self.currentMarkers) then begin
    
    panels = *self.panelInfo
    
    inBounds = 0
    
    ;determine if the cursor is within the bounds of any marker
    for i = 0,n_elements(panels)-1 do begin
      if self->inBounds(panels[i]) && $
        self->inBounds(panels[i],location=self.markerstart) then begin
        inBounds = 1
        xstart = (self.markerStart[0] - panels[i].xplotpos[0])/(panels[i].xplotpos[1]-panels[i].xplotpos[0])
        xstop = (self.cursorloc[0] - panels[i].xplotpos[0])/(panels[i].xplotpos[1]-panels[i].xplotpos[0])
      endif
    endfor
    
    ;if yes then update all markers with x-value proportional
    ;to the panel that the cursor is within
    if inBounds then begin
    
      markers = *self.currentMarkers
      
      for i = 0,n_elements(panels)-1 do begin
        self->drawMarker,[xstart,xstop],panels[i],markers[i]
      endfor
    endif
    
  endif
  
  ;highlight markers during mouseover
  if ptr_valid(self.panelInfo) then begin
  
    panels = *self.panelInfo
    
    ;loop over panels
    for i = 0,n_elements(panels) -1 do begin
     
     
      ;if we have any markers on this panel
      if ptr_valid(panels[i].markerInfo) then begin
      
        xloc = (location[0] - panels[i].xplotpos[0])/(panels[i].xplotpos[1]-panels[i].xplotpos[0])
        
        marked = 0 ; to make sure only one panel gets marked
        
        ;loop over the markers on this panel
        for j = n_elements(*panels[i].markerInfo)-1,0,-1 do begin
        
          marker = (*panels[i].markerInfo)[j]
          
          ;determine if the cursor is over each marker on this panel or not and update the color by rotating the hue 120 or 240 degrees.
          if marker.displayed then begin
          
            ;these first two cases execute identically.  Their results are distinct because marker.color is different if a marker is selected
            ;So rotation ends up occuring from a different starting point
            ;Mouse is over selected marker 
            if (xloc ge marker.pos[0] && xloc le marker.pos[1] && ~marked && self->inBounds(panels[i])) && marker.selected then begin
              marked = 1
              marker.frames[0]->setProperty,color=self->convertColor(self->hueRotation(marker.color))
              marker.frames[1]->setProperty,color=self->convertColor(self->hueRotation(marker.color))
              panels[i].markerIdx = j
            ;Mouse is over unselected marker
            endif else if xloc ge marker.pos[0] && xloc le marker.pos[1] && ~marked && self->inBounds(panels[i]) then begin
              marked = 1
              marker.frames[0]->setProperty,color=self->convertColor(self->hueRotation(marker.color))
              marker.frames[1]->setProperty,color=self->convertColor(self->hueRotation(marker.color))
              panels[i].markerIdx = j
            ;Mouse is not over marker, but it is selected
            endif else if marker.selected then begin
              marker.frames[0]->setProperty,color=self->convertColor(self->huerotation(self->hueRotation(marker.color)))
              marker.frames[1]->setProperty,color=self->convertColor(self->huerotation(self->hueRotation(marker.color)))
            ;Mouse is not over marker and it is not selected
            endif else begin
              marker.frames[0]->setProperty,color=self->convertColor(marker.color)
              marker.frames[1]->setProperty,color=self->convertColor(marker.color)
            endelse
          endif
          
        endfor
        
        ;Making sure the no-marked code is properly updated in the meta-data
        if ~marked then begin
          panels[i].markerIdx = -1
        endif
        
      endif
      
    endfor
    
    ;replace old panel metadata with updated quantities
    ptr_free,self.panelInfo
    self.panelInfo = ptr_new(panels)
    
  endif
  
  ;print,'TM1: ' + strtrim(string((systime(/seconds)-tm)),2)
  
  ;self.destination->draw,self.scene,/draw_instance
  self->draw
  
  ;print,'TM2: ' + strtrim(string((systime(/seconds)-tm)),2)
  
end

;This routine updates the location of the vertical bar 
;in each panel.  Behavior is a function of the various
;tracking options and the location of the cursor
;
;location(2-element double): The position of the cursor
;in coordinates normalized to the draw area
;
;panelInfo(pointer to array of structs): Each struct stores the
;metadata for each panel in a format for internal use by the draw object 
pro thm_ui_draw_object::updateVBar,location,panelInfo

  compile_opt idl2

 ;single panel vBar draw mode
  if self.vBarOn eq 1 && ptr_valid(panelInfo) then begin
  
    for i = 0,n_elements(*panelInfo)-1 do begin
    
      xpos = ((*panelInfo)[i]).xplotpos
      ypos = ((*panelInfo)[i]).yplotpos
      vBar = ((*panelInfo)[i]).vBar
      anno = ((*panelInfo)[i]).annotation
      view = ((*panelInfo)[i]).view
      
      ;For some reason updating the location of the existing bar did not work
      ;So instead, we destroy the old one and create a new one
      old = vBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      vBar->remove,/all
      
      ;If we're inside the bounds of the panel, we create the new bar
      if self->inBounds((*panelInfo)[i]) then begin
      
        xobjpos = (location[0] - xpos[0])/(xpos[1]-xpos[0])
        
        vBar->add,obj_new('IDLgrPolyline',[xobjpos,xobjpos],[0.,1.],[.5,.5],color=self->convertColor([0,0,0]),hide=0,/double)
      endif
      
    ;self.destination->draw,view
    ;self.destination->draw,anno
      
    endfor
    
  ;multiple panel vBar draw mode
  endif else if self.vBarOn eq 2 && ptr_valid(panelInfo) then begin
  
    drawbar = 0
    
    ;this section determines if the cursor is within the area of *any*
    ;panel, we loop over all panels
    for i = 0,n_elements(*panelInfo)-1 do begin
    
      xpos = ((*panelInfo)[i]).xplotpos
      ypos = ((*panelInfo)[i]).yplotpos
      vBar = ((*panelInfo)[i]).vBar
      anno = ((*panelInfo)[i]).annotation
      view = ((*panelInfo)[i]).view
      
      ;For some reason updating the location of the existing bar did not work
      ;So instead, we destroy the old one and create a new one
      old = vBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      vBar->remove,/all
      
      ;If we're inside the bounds of the panel, we note the location, and that we're inside *some* panel
      if self->inBounds((*panelInfo)[i]) then begin
      
        xobjpos = (location[0] - xpos[0])/(xpos[1]-xpos[0])
        
        drawbar = 1
        
      ;vBar->add,obj_new('IDLgrPolyline',[xobjpos,xobjpos],[0.,1.],[.5,.5],color=self->convertColor([0,0,0]),hide=0)
      endif
      
    endfor
    
    ;If it is in bounds, then draw the vbar proportional to each panel.
    if drawBar then begin
    
      for i = 0,n_elements(*panelInfo)-1 do begin
      
        xpos = ((*panelInfo)[i]).xplotpos
        ypos = ((*panelInfo)[i]).yplotpos
        vBar = ((*panelInfo)[i]).vBar
        anno = ((*panelInfo)[i]).annotation
        view = ((*panelInfo)[i]).view
        
        ;anno->setProperty,hide=0
        ;vBar->remove,/all
        vBar->add,obj_new('IDLgrPolyline',[xobjpos,xobjpos],[0.,1.],[.5,.5],color=self->convertColor([0,0,0]),hide=0,/double)
        
      endfor
      
    endif
    
  endif
  
end


;This routine updates the location of the horizontal bar 
;in each panel.  Behavior is a function of the various
;tracking options and the location of the cursor
;
;location(2-element double): The position of the cursor
;in coordinates normalized to the draw area
;
;panelInfo(pointer to array of structs): Each struct stores the
;metadata for each panel in a format for internal use by the draw object 
pro thm_ui_draw_object::updateHBar,location,panelInfo

  compile_opt idl2

 ;single panel hBar draw mode
  if self.hBarOn eq 1 && ptr_valid(panelInfo) then begin
  
    ;loop over each panel
    for i = 0,n_elements(*panelInfo)-1 do begin
    
      xpos = ((*panelInfo)[i]).xplotpos
      ypos = ((*panelInfo)[i]).yplotpos
      hBar = ((*panelInfo)[i]).hBar
      anno = ((*panelInfo)[i]).annotation
      view = ((*panelInfo)[i]).view
      
      ;For some reason updating the location of the existing bar did not work
      ;So instead, we destroy the old one and create a new one
      old = hBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      hBar->remove,/all
      
      ;If the cursor is within panel bounds, a new horizontal bar is created
      if self->inBounds((*panelInfo)[i]) then begin
      
        yobjpos = (location[1] - ypos[0])/(ypos[1]-ypos[0])
        
        hBar->add,obj_new('IDLgrPolyline',[0.,1.],[yobjpos,yobjpos],[.5,.5],color=self->convertColor([0,0,0]),hide=0,/double)
      endif
      
    ;self.destination->draw,view
    ;self.destination->draw,anno
      
    endfor
    
  ;multiple panel hBar draw mode
  endif else if self.hBarOn eq 2 && ptr_valid(panelInfo) then begin
  
    drawbar = 0
    
    ;this section determines if the cursor is within the area of *any*
    ;panel
    for i = 0,n_elements(*panelInfo)-1 do begin
    
      xpos = ((*panelInfo)[i]).xplotpos
      ypos = ((*panelInfo)[i]).yplotpos
      hBar = ((*panelInfo)[i]).hBar
      anno = ((*panelInfo)[i]).annotation
      view = ((*panelInfo)[i]).view
      
      ;For some reason updating the location of the existing bar did not work
      ;So instead, we destroy the old one and create a new one
      old = hBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      hBar->remove,/all
      
      ;If we're inside the bounds of the panel, we note the location, and that we're inside *some* panel
      if self->inBounds((*panelInfo)[i]) then begin
      
        yobjpos = (location[1] - ypos[0])/(ypos[1]-ypos[0])
        
        drawbar = 1
        
      ;vBar->add,obj_new('IDLgrPolyline',[xobjpos,xobjpos],[0.,1.],[.5,.5],color=self->convertColor([0,0,0]),hide=0)
      endif
      
    endfor
    
    ;If it is in bounds on some panel, then draw the hbar proportional to each panel
    if drawBar then begin
    
      for i = 0,n_elements(*panelInfo)-1 do begin
      
        xpos = ((*panelInfo)[i]).xplotpos
        ypos = ((*panelInfo)[i]).yplotpos
        hBar = ((*panelInfo)[i]).hBar
        anno = ((*panelInfo)[i]).annotation
        view = ((*panelInfo)[i]).view
        
        ;anno->setProperty,hide=0
        ;vBar->remove,/all
        hBar->add,obj_new('IDLgrPolyline',[0.,1.],[yobjpos,yobjpos],[.5,.5],color=self->convertColor([0,0,0]),hide=0,/double)
        
      endfor
      
    endif
    
  endif
  
end

;this code performs an update on the legend text values for the provided panel
;it fills them in with the normalized data values provided as arguments
;
;panelLocation(2-element double): The position of the cursor in coordinates normalized to the panel
;panel(struct):  The draw object struct representing the panel
;blank(boolean keyword):  Set this keyword to make the legend blank
;noyvalue(boolean keyword): If this keyword is set, the yvalue will be set to an empty string and other values will be updated as normal
pro thm_ui_draw_object::updateLegend,panelLocation,panel,blank=blank,noyvalue=noyvalue

  compile_opt idl2
  
  ;update panel legend
  ;blank panel, empty legend
  if keyword_set(blank) && ptr_valid(panel.traceInfo) then begin
    panel.xobj->setProperty,strings=''
    
  ;  if panel.hasSpec then begin
    panel.yobj->setProperty,strings=''
  ;  endif
    
    traces = *panel.traceInfo
    
    for j = 0,n_elements(traces)-1 do begin
      if obj_valid(traces[j].textObj) then begin
        traces[j].textObj->setProperty,strings=''
      endif
    endfor
    
  ;inside panel range, update with data
  endif else if ptr_valid(panel.traceinfo) then begin
    
    ;if we're locked, override the defaults with the locked values
    if panel.locked then begin
      xrange = panel.lockedRange
      xscale = panel.lockedScale
    endif else begin
      xrange = panel.xrange
      xscale = panel.xscale
    endelse
    
    if panel.xistime then begin
      if xrange[1]-xrange[0] lt 60*60*24 then begin
        xformat = 6
      endif else begin
        xformat = 15
      endelse
    endif else begin
      xformat = 5
    endelse
    
    if panel.yistime then begin
      if panel.yrange[1]-panel.yrange[0] lt 60*60*24 then begin
        yformat = 6
      endif else begin
        yformat = 15
      endelse
    endif else begin
      yformat = 5
    endelse
    
    if panel.zistime then begin
      if panel.zrange[1]-panel.zrange[0] lt 60*60*24 then begin
        zformat = 6
      endif else begin
        zformat = 15
      endelse
    endif else begin
      zformat = 5
    endelse
        
    
    ;calculate the x-position in data coordinates and update the string value for that point 
    xdatapos = xrange[0]+(xrange[1]-xrange[0])*panelLocation[0]
    formatdata={timeAxis:panel.xIsTime,formatid:xformat,scaling:xscale,exponent:~xscale?0:2}
    panel.xobj->setProperty,strings=formatannotation(0,0,xdatapos,data=formatdata)
    
    if ~keyword_set(noyvalue) then begin
      ;calculate the y-position in data coordinates and update the string value for that point 
      ydatapos = panel.yrange[0]+(panel.yrange[1]-panel.yrange[0])*panelLocation[1]
      formatdatay={timeAxis:panel.yIsTime,formatid:yformat,scaling:panel.yscale,exponent:~panel.yscale?0:2}
     ; if panel.hasSpec then begin
      panel.yobj->setProperty,strings=formatannotation(0,0,ydatapos,data=formatdatay)
      ;endif
    endif else begin
      panel.yobj->setProperty,strings=''
    endelse
    
    ;annotation struct for z-annotations
    formatdataz={timeAxis:panel.zIsTime,formatid:zformat,scaling:panel.zscale,exponent:~panel.zscale?0:2}
    
    traces = *panel.traceInfo
    
    ;loop through and update dependent variables
    for  i= 0,n_elements(traces)-1 do begin
    
      if ~ptr_valid(traces[i].refData) then begin
        dataString = 'NaN'
      endif else begin
      
        ;lookup 2-input dependent for specplot
        if traces[i].isSpec then begin
        
          refdim = dimen(*traces[i].refData)
          ;guarantee that IDL doesnt' make a dimension disappear(I hate it when IDL does this SOOOOO much)
          if n_elements(refDim) eq 1 then begin
            refDim = [refDim,1]
          endif
          
          ;The x/y indexes into the lookup table, bounded on the interval [0,1]
          refxidx = (round(panelLocation[0]*refdim[0]) < (refdim[0]-1)) > 0
          refyidx = (round(panelLocation[1]*refdim[1]) < (refdim[1]-1)) > 0
          
       ;   if finite((*traces[i].refData)[refxidx,refyidx],/inf) then stop
          
          dataString = formatannotation(0,0,(*traces[i].refData)[refxidx,refyidx],data=formatdataz)
          
       ;   print,dataString,refdim[0],refxidx,(*traces[i].refData)[refxidx,refyidx]
        endif else begin
        
          ;loopkup 1-input dependent for lineplot
        
          ;If there is no valid independent, use a proportionally scaled dependent
          if ~ptr_valid(traces[i].abcissa) then begin
          
            refdim = dimen(*traces[i].refData)
            refxidx = (round(panelLocation[0]*refdim[0]-1) < (refdim[0]-1)) > 0
            formatdatay={timeAxis:panel.yIsTime,formatid:yformat,scaling:panel.yscale,exponent:~panel.yscale?0:2}
            
          endif else begin
          ;valid indepenent, find the point closest to the input, abcissa values are normalized so comparison can be done directly
          
            tmp = min(abs(*traces[i].abcissa - panelLocation[0]),refxidx)
            formatdatay={timeAxis:panel.yIsTime,formatid:yformat,scaling:panel.yscale,range:panel.yrange,exponent:~panel.yscale?0:2}
            
          endelse
                   
          dataString = formatannotation(0,0,(*traces[i].refData)[refxidx],data=formatdatay)
          
        endelse
        
      endelse
      
      ;finally update the text object
      if obj_valid(traces[i].textObj) then begin
        traces[i].textObj->setProperty,strings=dataString
      endif
      
   ;   print,dataString,(dimen(*traces[i].refdata))[0],refxidx,(*traces[i].refData)[refxidx]
      
    endfor
    
  endif
  
  ;now update variables using the same logic
  
  ;If blank is requested blank all the variables
  if keyword_set(blank) && ptr_valid(panel.varInfo) then begin
 
    vars = *panel.varInfo
    
    for i = 0,n_elements(vars)-1 do begin
      vars[i].textObj->setProperty,strings=''
    endfor
    
  endif else if ptr_valid(panel.varInfo) then begin
  ;If not blanking do the update
  
    vars = *panel.varInfo
    
    for i = 0,n_elements(vars)-1 do begin
    
      ;update is done proportionally, because a lookup value has been generated
      ;for every possible cursor position.  This is possible because aliasing
      ;Is not as issue for variable quantities
      nx  = n_elements(*vars[i].dataY)
    
      ; calculate pixel-proportional index on interval [0,nx-1]
      idx = (round(panelLocation[0]*(nx-1)) > 0) < (nx-1)  
    
      ;identify value
      value = (*vars[i].dataY)[idx]
      
      ;format output string
      formatdata={timeAxis:vars[i].isTime,formatid:vars[i].annotateStyle,scaling:0,exponent:0}
      str = formatannotation(0,0,value,data=formatdata)
      
      if value ge 0 then begin
        str = ' ' + str
      endif
      
      ;update text object
      vars[i].textObj->setProperty,strings=str
      
    endfor
    
  endif
  
  
end

;draws marker and updates the range in the marker object. Applies to marker is progress.
;
;markerRange (2-element double array):  The start and stop position of the marker in panel-normalized coordinates, 
;                                       (note that start may be larger than stop, if marker was drawn right->left)
;
;panel (struct): Struct used by draw object to store panel information
;
;marker(object):  Reference to the marker being drawn
;
;remove(boolean keyword): Set this keyword to remove the marker
pro thm_ui_draw_object::drawMarker,markerRange,panel,marker,remove=remove

  compile_opt idl2
  
  zstack = .21
  
  xbegin = min(markerRange,/nan)
  xend = max(markerRange,/nan)
  
  ; print,xbegin,xend
  
  ;get rid of old partial markers
  old = panel.marker->get(/all)
  if obj_valid(old[0]) then obj_destroy,old
  panel.marker->remove,/all
  
  if keyword_set(remove) then return
  
  ;get all the settings for the marker being drawn
  marker->getProperty,settings=settings
  
  settings->getProperty,$
    fillColor=fillColor,$
    lineStyle=lineStyle,$
    drawOpaque=drawOpaque
    
  lineStyle->getProperty,$
    id=lineid,$
    show=lineshow,$
    color=linecolor,$
    thickness=linethick
    
  ;generate new border for the marker
  lineleft = obj_new('IDLgrPolyline',$
    [xbegin,xbegin],$
    [0.,1.],$
    replicate(zstack,2)+.00001,$
    linestyle=lineid,$
    hide=~lineshow,$
    color=self->convertColor(linecolor),$
    thick=linethick,$
    /double)
    
  lineright = obj_new('IDLgrPolyline',$
    [xend,xend],$
    [0.,1.],$
    replicate(zstack,2)+.00001,$
    linestyle=lineid,$
    hide=~lineshow,$
    color=self->convertColor(linecolor),$
    thick=linethick,$
    /double)
    
  ;This is the semi-transparent interior of the marker
  poly = obj_new('IDLgrPolygon',$
    [xbegin,xend,xend,xbegin],$
    [0.,0.,1.,1.],$
    replicate(zstack,4),$
    color=self->convertColor(fillColor),$
    alpha_channel=drawOpaque,$
    /double)
    
  panel.marker->add,lineleft
  panel.marker->add,lineright
  panel.marker->add,poly
  
  ;Need to use the locked range if the layout is locked
  if panel.locked then begin
    range = ([xbegin,xend]*(panel.lockedrange[1]-panel.lockedrange[0]))+panel.lockedrange[0]
  endif else begin
    range = ([xbegin,xend]*(panel.xrange[1]-panel.xrange[0]))+panel.xrange[0]
  endelse
  
  ;   print,time_string(range)
  
  ;updating the range
  marker->setProperty,range=range
  
end

;returns true if the current cursor location is within the bounds of the panel past as an argument
;panelInfo(struct):  struct that stores information for the draw object about the panel in question
;location(keyword, 2-element double):  Overrides the default location stored in self.cursorLoc with the value in the keyword
;                                      Default behavior uses self.cursorloc
function thm_ui_draw_object::inBounds,panelInfo,location=location

  compile_opt idl2
  
  if ~keyword_set(location) then location = self.cursorloc
  
  ;print,'x',panelInfo.xplotpos,'y',panelInfo.yplotpos
  
  return,location[0] ge panelInfo.xplotpos[0] && $
    location[0] le panelInfo.xplotpos[1] && $
    location[1] ge panelInfo.yplotpos[0] && $
    location[1] le panelInfo.yplotpos[1]
    
end

;Returns an array of structs that indicate the panels overlapped by the rubber band
;Input:
;  xonly:
;    If set, constrain along the x-axis only.
;
;Output:
;   structs have the form {idx:0,xrange:[0,1],yrange[0,1],vars:ptr_new()}
;   idx is the panel index in the current display, this is an index into the list of panels displayed, not the ID field from the thm_ui_panel object
;   xrange is the xrange of the panel in non-logarithmic(normal) space
;   yrange is the yrange of the panel in non-logarithmic(normal) space
;   vars is either a null pointer or an array of structs of the form:
;       {range:[0,1]} which stores the range of each variable on the panel
;   returns 0 on fail
;
;Notes: No inputs, uses the information in self.panelInfo, self.rubberStart, self.cursorLoc(considered rubber band stop position 
function thm_ui_draw_object::GetrubberBandPos,xonly=xonly

  compile_opt idl2
  
  ;prototype output structs
  str = {idx:0,xrange:[0D,1D],yrange:[0D,1D],vars:ptr_new()}
  varstr = {range:[0D,1D]}
  
  if ~ptr_valid(self.panelInfo) then return,0
  
  str_arr = replicate(str,n_elements(*self.panelInfo))
  
  arr_num = 0
  
  ;calculate the borders of the rubberband box
  ;because the box can be oriented in various ways
  ;the start & end pos may not be the expected corner
  left = self.cursorloc[0] < self.rubberstart[0]
  right = self.cursorloc[0] > self.rubberstart[0]
  bottom = self.cursorloc[1] < self.rubberstart[1]
  top = self.cursorloc[1] > self.rubberstart[1]
  
  ;loop over panels
  for i = 0,n_elements(*self.panelInfo)-1 do begin
  
    xplotpos = ((*self.panelInfo)[i]).xplotpos
    yplotpos = ((*self.panelInfo)[i]).yplotpos
    
    if ((*self.panelInfo)[i]).locked then begin
  ;  if 0 then begin
      xrange = ((*self.panelInfo)[i]).lockedRange
    endif else begin
      xrange = ((*self.panelInfo)[i]).xrange
    endelse
    
    yrange = ((*self.panelInfo)[i]).yrange
    
    ;determine if rubber band intersects with panel
    if (right  ge  xplotpos[0] && $
      left   le  xplotpos[1] && $
      (top    ge  yplotpos[0] || keyword_set(xonly)) && $
      (bottom le  yplotpos[1] || keyword_set(xonly))) then begin
      
      ;determine the dimensions of the overlapping box
      bx_right    = right < xplotpos[1]
      bx_left     = left > xplotpos[0]
      bx_top      = top < yplotpos[1]
      bx_bottom   = bottom > yplotpos[0]
      
      ;now calculate ranges
      
      bx_left_norm = (bx_left - xplotpos[0])/(xplotpos[1]-xplotpos[0])
      bx_right_norm = (bx_right - xplotpos[0])/(xplotpos[1]-xplotpos[0])
      bx_bottom_norm = (bx_bottom - yplotpos[0])/(yplotpos[1]-yplotpos[0])
      bx_top_norm = (bx_top - yplotpos[0])/(yplotpos[1]-yplotpos[0])
      
      
      rng_left   = bx_left_norm*(xrange[1]-xrange[0])+xrange[0]
      rng_right  = bx_right_norm*(xrange[1]-xrange[0])+xrange[0]
      rng_bottom = bx_bottom_norm*(yrange[1]-yrange[0])+yrange[0]
      rng_top    = bx_top_norm*(yrange[1]-yrange[0])+yrange[0]
      
      outxrange = [rng_left,rng_right]
      outyrange = [rng_bottom,rng_top]
      
      ;now translate from logarithmic to normal space(if necessary)
      if ((*self.panelInfo)[i]).xscale eq 1 then $
        outxrange = 10D ^ outxrange $
      else if  ((*self.panelInfo)[i]).xscale eq 2 then $
      outxrange = exp(outxrange)

      if ((*self.panelInfo)[i]).yscale eq 1 then $
        outyrange = 10D ^ outyrange $
      else if  ((*self.panelInfo)[i]).yscale eq 2 then $
        outyrange = exp(outyrange)
   
    
      ;store the output info
      str_arr[arr_num].idx = i
      str_arr[arr_num].xrange = outxrange
      
      str_arr[arr_num].yrange = outyrange
     
      ;check variables for rubber band information
      if ptr_valid(((*self.panelInfo)[i]).varInfo) then begin
      
        varInfoArray = *((*self.panelInfo)[i]).varInfo
        
        varstr_arr = replicate(varstr,n_elements(varInfoArray))
        
        for j = 0,n_elements(varInfoArray) - 1 do begin
        
          ;same computation as above
          varrange = varInfoArray[j].range
          
          ;determine values of edges, by scaling proportionately
          varlow = bx_left_norm*(varrange[1]-varrange[0])+varrange[0]
          varhigh = bx_right_norm*(varrange[1]-varrange[0])+varrange[0]
          
          outvarrange = [varlow,varhigh]
          
          ;delog output range
          if varInfoArray[j].scaling eq 1 then begin
            outvarRange = 10. ^ outvarrange
          endif else if varInfoArray[j].scaling eq 2 then begin
            outvarRange = exp(outvarrange)
          endif
          
          varstr_arr[j].range=outvarrange
          
        endfor
        
        str_arr[arr_num].vars = ptr_new(varstr_arr)
        
      endif
    
      arr_num++
    endif
  
  endfor

if arr_num eq 0 then return,0 else return,str_arr[0:arr_num-1]

end

;Return a bunch of information about a panel with a particular index
;returns 0 on fail
function thm_ui_draw_object::GetPanelInfo,index

  compile_opt idl2
  
  info = {$
    xpos:[0D,1D],$  ;the normalized x position of the plot within the panel
    ypos:[0D,1D],$  ;the normalized y position of the plot within the panel
    xrange:[0D,1D],$ ;the x data range of the panel(If xscale= 1 or 2 it will be the log of the range)
    yrange:[0D,1D],$ ;the y data range of the panel(If yscale= 1 or 2 it will be the log of the range)
    zrange:[0D,1D],$ ;the z data range of the panel(If zscale= 1 or 2 it will be the log of the range)
    xmajorSize:0D,$  ;the size of a major tick on the x axis(If xscale= 1 or 2 it will be in logarithmic space)
    ymajorSize:0D,$  ;the size of a major tick on the y axis(If yscale= 1 or 2 it will be in logarithmic space)
    xmajorNum:0,$ ; the number of major ticks on the x-axis
    ymajorNum:0,$ ; the number of major ticks on the y-axis
    zmajorNum:0,$ ; the number of major ticks on the z-axis
    xminorNum:0,$ ; the number of minor ticks on the x-axis
    yminorNum:0,$ ; the number of minor ticks on the y-axis
    zminorNum:0,$ ; the number of minor ticks on the z-axis
    xscale:0D,$  ;indicates scaling option for the x axis 0:linear,1:log10,2:logN
    yscale:0D,$  ;indicates scaling option for the y axis 0:linear,1:log10,2:logN
    zscale:0D,$  ;indicates scaling option for the z axis 0:linear,1:log10,2:logN
    xcenter:0D,$  ;The center for floating center.
    ycenter:0D,$  ;The center for floating center.
    lockedcenter:0D,$  ;The center for floating center.
    hasspec:0B,$ ;boolean indicates whether the panel has at least one spectrogram, if yes Z info will apply
    hasLine:0B } ;boolean indicates whether the panel has at least one line, if yes Z info will apply
    
  if ~ptr_valid(self.panelInfo) || $
    n_elements(index) ne 1 || $
    index ge n_elements(*self.panelInfo) then begin
    return,0
  endif
  
  panel = (*self.panelInfo)[index]
  
  info.xpos = panel.xplotpos
  info.ypos = panel.yplotpos
  info.xrange = panel.xrange
  info.yrange = panel.yrange
  info.zrange = panel.zrange
  info.xmajorsize = panel.xmajorsize
  info.ymajorsize = panel.ymajorsize
  info.xmajornum = panel.xmajornum
  info.ymajornum = panel.ymajornum
  info.zmajornum = panel.zmajornum
  info.xminornum = panel.xminornum
  info.yminornum = panel.yminornum
  info.zminornum = panel.zminornum
  info.xscale = panel.xscale
  info.yscale = panel.yscale
  info.zscale = panel.zscale
  info.xcenter = panel.xcenter
  info.ycenter = panel.ycenter
  info.lockedcenter = panel.lockedcenter
  info.hasSpec = panel.hasSpec
  info.hasLine = panel.hasLine
  
  return,info
  
end

;Returns an array that shows panel size.
;Inputs:
;  xdims(2 element double array):  The start and stop position of the panel x-axis, coordinates normalized to the draw area 
;  ydims(2 element double array):  The start and stop position of the panel y-axis, coordinates normalized to the draw area 
;Outputs:
;  array format = [xpos,ypos,width,height]
;
function thm_ui_draw_object::getPanelSize,xdims,ydims

  compile_opt idl2
  
  xpos = self->norm2pt(xdims[0],0)
  xlen = self->norm2pt(xdims[1]-xdims[0],0)
  ypos = self->norm2pt(ydims[0],1)
  ylen = self->norm2pt(ydims[1]-ydims[0],1)
  
  return,[xpos,ypos,xlen,ylen]
  
end

;Returns the number of panels currently displayed
;If there is any confusion about the output panel indices, 
;This indicates the maximum value.  0 indicates no panels
function thm_ui_draw_object::getPanelNumber

  compile_opt idl2
  
  if ~ptr_valid(self.panelInfo) then return,0
  
  return,n_elements(*self.panelInfo)
  
end

;Returns the marker or list of markers that were created
;by the most recent markeron/markeroff call
;if no markers available, returns 0
;Output:
; an array of structs of the form
;{idx:0,marker:obj_new('thm_ui_marker')}
;idx is index of the panel the marker is on, this is the index into the list of panels in the IDL_Container on the window, not the ID field of the panel
;the object is the marker, with correct default settings and range
function thm_ui_draw_object::getMarkers

  compile_opt idl2
  
  if ~ptr_valid(self.currentMarkers) then return,0
  
  markerStruct = {idx:0,marker:obj_new()}
  
  markers = replicate(markerStruct,n_elements(*self.currentMarkers))
  
  for i = 0,n_elements(markers)-1 do begin
    markers[i].marker = ((*self.currentMarkers)[i])->copy()
  endfor
  
  markers[*].idx = *self.markerIdx
  
  return,[markers]
  
end

;returns the a struct that identifies that panel and the part of the panel under the cursor
;Uses self.cursorLoc to determine current cursor location.
;Output:
;  Struct of the form: {panelidx:0L,component:0,marker:-1}
;PanelIdx(long):  An index into the list of panels on the currently drawn display, not the panel ID field
;Components(short):  0=plot,1=xaxis,2=yaxis,3=zaxis,4=variables
;Marker: the index of any marker under the cursor, is -1 if none, index is an index into the list of markers currently stored in the IDL_Container on the copy
;Returns 0L  if click is nothing(ie page)
;
;NOTES:
;  Resolution of position is only approximate at this point.
;  In particular, this could be better and distinguishing z-axis from x/yaxis and variable from x axis
;
;  Things that need to be done to improve approximation, account for text height, take layout issues
;  into account.  Resolve variable/z-axis on the same size.
;
function thm_ui_draw_object::getClick

  compile_opt idl2
  
  if ~ptr_valid(self.panelInfo) then return,0
  
  panels = *self.panelInfo
  
  loc = self.cursorloc
  
  markeridx = -1L
  panelidx = -1L
  
  ;loop through panels
  for i = 0,n_elements(panels)-1 do begin
  
    xpos = panels[i].xplotpos
    ypos = panels[i].yplotpos
    margins = panels[i].margins
    place = panels[i].zplacement
    
    ;Check bounds. (Cursor over plot)
    if loc[0] ge xpos[0] && $  ;panel
      loc[0] le xpos[1] && $
      loc[1] ge ypos[0] && $
      loc[1] le ypos[1] then  begin
      return,{panelidx:i,component:0,marker:panels[i].markeridx}
      
    ;This block handles a click on the left side of the panel
    endif else if loc[0] ge xpos[0] - margins[0] && $ ;left side
      loc[0] le xpos[0] && $
      loc[1] ge ypos[0] && $
      loc[1] le ypos[1] then begin
      
      ;If z-axis is placed on a particular side, you cannot get the other axis by a click on that side
      if place eq 2 then begin
        return,{panelidx:i,component:3,marker:-1} ;zaxis
      endif else begin
        return,{panelidx:i,component:2,marker:-1} ;yaxis
      endelse
     
   ;This block handles a click on the right side of the panel
    endif else if loc[0] ge xpos[1] && $ ;right side
      loc[0] le xpos[1] + margins[1] && $
      loc[1] ge ypos[0] && $
      loc[1] le ypos[1] then begin
      
      ;If z-axis is placed on a particular side, you cannot get the other axis by a click on that side 
      if place eq 3 then begin
        return,{panelidx:i,component:3,marker:-1} ;zaxis
      endif else begin
        return,{panelidx:i,component:2,marker:-1} ; yaxis
      endelse
      
    ;This block handles a click on the top side of the panel
    endif else if loc[0] ge xpos[0] && $ ;top side
      loc[0] le xpos[1] && $
      loc[1] ge ypos[1] && $
      loc[1] le ypos[1] + margins[2] then begin
      
      
      ;If z-axis is placed on a particular side, you cannot get the other axis by a click on that side 
      if place eq 0 then begin
        return,{panelidx:i,component:3,marker:-1} ;zaxis
      endif else begin
        return,{panelidx:i,component:1,marker:-1} ;xaxis
      endelse
      
    ;This block handles a click on the bottom side of the panel
    endif else if loc[0] ge xpos[0] && $ ;bottom side
      loc[0] le xpos[1] && $
      loc[1] ge ypos[0] - margins[3] && $
      loc[1] le ypos[0] then begin
      
      ;If z-axis is placed on a particular side, you cannot get the other axis by a click on that side 
      if place eq 1 then begin
        return,{panelidx:i,component:3,marker:-1} ;zaxis
      endif else begin
        return,{panelidx:i,component:1,marker:-1} ;xaxis
      endelse
      
    ;This block handles variable selection.  Basically, if your selection is outside of margins, it is assumed to be variable
    endif else if loc[0] ge xpos[0] && $
      loc[0] le xpos[1] && $
      loc[1] ge ypos[0] - margins[3] - margins[4] && $
      loc[1] le ypos[0] - margins[3] then begin
      
      return,{panelidx:i,component:4,marker:-1} ; vars
      
    endif
    
  endfor
  
  return,0
  
end

;This routine performs the draw work necessary to display a marker click
;basically this means mutating the selected flag on markerinfo.
;Then when drawn the marker will show up with the appropriate highlighting
;
;Inputs:
;  InfoStruct(struct) : This is the struct returned by thm_ui_draw_object::getClick
;  
;NOTES:
;  This is separated from getclick() to preserve separation between routines that 
;     give information on the display, and ones that mutate display.
;     This way, the calling routine doesn't need to expect a mutation to
;     query the layout 
;
pro thm_ui_draw_object::setClick,infostruct

  compile_opt idl2
  
  ;Doesn't assume infostruct exists to
  ;Allow direct passthrough of getClick output
  ;and to avoid failing when calling routine fails
  if keyword_set(infostruct) && $
    is_struct(infostruct) && $
    infostruct.marker ne -1 && $
    ptr_valid(self.panelInfo) then begin
    
    panels = *self.panelInfo
    
    ;loop over panels to find the selected panel
    for i = 0,n_elements(panels)-1 do begin
    
      if ptr_valid(panels[i].markerInfo) then begin
      
        markers = *panels[i].markerInfo
        
        ;Find the selected value of the currently clicked marker
        if i eq infostruct.panelidx then begin
          old_selected = markers[infostruct.marker].selected
        endif
        
        ;Deselect all other markers.
        ;This is the line that prevents multi-select,ATM
        markers[*].selected = 0
        
        ;If we've got a selection, then flip the selected value
        if i eq infostruct.panelidx then begin
        
          if old_selected eq 1 then begin
            markers[infostruct.marker].selected = 0
          endif else begin
            markers[infostruct.marker].selected = 1
          endelse
          
        endif
        
        ;Replace old marker structs with new-ones to guarantee proper mutation
        ptr_free,panels[i].markerInfo
        panels[i].markerInfo = ptr_new(markers)
        
      endif
      
    endfor
    
    ;Replace old panel structs with new-ones to guarantee proper mutation
    ptr_free,self.panelInfo
    self.panelInfo = ptr_new(panels)
    
  endif
  
  ;This will update the display to show any changed colors
  self->setCursor,self.cursorloc
end

;This function updates the entire display, it will be pretty
;slow so it should only be called after panel applies, but not
;during common widget events.
;
;WindowStorage:
; the thm_ui_windows object that stores the windows for the scene that is being updated
;
;LoadedData: 
; thm thm_ui_loaded_data object that stores the data used in the scene that is being drawn
;
;Postscript=postscript:
; set this keyword when postscripts are being drawn.  Special kluges for dealing with
; postscript transparency and layering issues are turned on.
; 
; Error=error:
; Pass a named variable in via this keyword when updates are being drawn.  After completion
; It will return a 1 if there was an error and a 0 if there was no error.
; 
; NOTES:
;  1.  Slowness depends on complexity of displayed layout.(number of panels, size of data)
;      It can range from 1/10th of a second to 10 or more seconds
;      
;  2.  Memory usage can spike moderately during this function, but memory usage between
;      calls should be minimal because lookup tables are used for cursor functions.
;      Memory will max out at ~2x the memory of the largest panel being plotted, because data
;      must be copied to process it without corrupting the main data store. 
;      In other words O(N*M), where N is the time resolution of the data on your largest
;      panel, and M is the number of dimensions on this panel.
;    
;
pro thm_ui_draw_object::update,windowStorage,loadedData,postscript=postscript,error=error

  compile_opt idl2
  
  ;Assume an error until told otherwise
  error = 1
  
 ; t1 = systime(/seconds)
  
  ;This constant controls the space between locked panels
  ;All locked panels will have at most this many points of vertical spacing
  ;But they can have less.
  lockedVerticalSpacing = 5
  
  ;Turn on hourglass, in case it takes awhile
  widget_control,/hourglass
  
 ; self.statusBar->update,'Beginning Update'
 ; self.historyWin->update,'Beginning Update'
  
  ;Remove all of the old display 
  self.staticViews->remove,/all
  self.dynamicViews->remove,/all
  
  ;Garbage collect any heap variables that might be floating around.
  heap_gc
  
  ;Adds the view that rubber band will exist on
  self.dynamicViews->add,self.rubberView
  
  ;Set the internal postscript flag(it is global to the update operation)
  if keyword_set(postscript) then begin
    self.postscript=1
  endif else begin
    self.postscript=0
  endelse
  
  originalWindow = windowStorage->getActive()
  
  ;use copy to prevent mutation of input settings
  activeWindow = originalWindow->copy()
  
  activeWindow->getProperty,settings=pageSettings,panels=panels,nRows=nRows,nCols=nCols,locked=locked
  
  pageSettings->getProperty,ypanelspacing=yverticalspacing
  
  ;override default spacing, if panel locked and page value bigger than constant
  if locked ne -1 && yverticalspacing ge lockedVerticalSpacing then begin
  
    pageSettings->setProperty,ypanelspacing=lockedVerticalSpacing
    
  endif
  
  ;This draws the page.  Which includes things like background coloring, and page titles
  if ~self->updatePage(pageSettings) then begin
    self.statusbar->update,'Draw Object Error: Invalid page settings when drawing page'
    self.historyWin->update,'Draw Object Error: Invalid page settings when drawing page'
        
    ;If we fail this call returns us to a pristine state, so that this
    ;object will interact correctly with parent routines without error
    self->nukeDraw
    ;Creating instances allows much quicker operation between updates,
    ;At the cost of slightly slower updates 
    self->createInstance
    return
  endif
  
  ;needed for creating the illusion of transparent ticks, without using true transparency
  pageSettings->getProperty,backgroundcolor=backgroundcolor
  
  margins = activeWindow->getMargins()
  
  panelObjs = panels->get(/ALL)
  
  ;If we don't have a pre-existing view group for panels
  ;This adds one
  if ~obj_valid(self.panelViews) then begin
    self.panelViews = obj_new('IDLgrViewGroup')
    self.scene->add,self.panelViews
  endif
  
  ;Remove old panel info structs
  ptr_free,self.panelInfo
  
  ;Remove old IDLgr panel representations
  self.panelViews->remove,/all
  
  ;No panels in the current display.  Terminate without error.
  ;This is a blank panel.
  if ~obj_valid(panelObjs[0]) then begin
  
    ;Creating instances allows much quicker operation between updates,
    ;At the cost of slightly slower updates
    self->createInstance
    error = 0
    return
  endif
  
  layoutDims = [nRows,nCols]
  ;This routine does the bulk of the detailed updating.
  ;It renders each individual panel, and everything in it
  if ~self->updatePanels(layoutDims,margins,panelObjs,loadedData,backgroundcolor,locked,activeWindow) then begin
    self.statusbar->update,'Draw Object Error: Updating panels, Please check History'
    self.historyWin->update,'Draw Object Error: Updating panels, Please check History'
    
    ;If we fail this call returns us to a pristine state, so that this
    ;object will interact correctly with parent routines without error
    self->nukeDraw
    
    ;Creating instances allows much quicker operation between updates,
    ;At the cost of slightly slower updates
    self->createInstance
    return
  endif
  
  ;Creating instances allows much quicker operation between updates,
 ;At the cost of slightly slower updates
  self->createInstance
  
  error = 0
  
 ; print,'RUNTIME: ' + string((systime(/seconds) - t1))
  
end
;This routine, performs prepocessing with respect to the x-axis
;
;1. translates data from linear to log space, if necessary
;2. Removes invalid values because:
;    a. non-finite
;    b. out of range
;    c. le 0 on log axis
;    
;3. Performs analogous removals on y/z/mirror data
;
;Inputs:
;
;xPtr(array of pointers to arrays):  A list of the data quantities for all x-values used in the panel. 
;                     The number of pointers should match the number of pointers in y and z.  
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer
;yPtr(array of pointers to arrays) : A list of the data quantities for all y-values used in the panel. 
;                     The number of pointers should match the number of pointers in x and z. 
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer
;zPtr(array of pointers to arrays) : A list of the data quantities for all z-values used in the panel. 
;                     The number of pointers should match the number of pointers in x and y.            
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer     
;  
;range(2-element double) : The min and max x-range that the data should be clipped to.
;
;scale(long) : The scaling method to be used on this axis(0: linear,1:log10,2:logN)
;
;mirrorPtr(array of pointers to arrays) : A list of the data quantities for all mirror-values used in the panel. 
;                     The number of pointers should match the number of pointers in x,y, z            
;                     If an x/y has no mirror the corresponding element should be a null pointer      
;
;Outputs: 
;  xPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  yPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  zPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  fail(named variable keyword):  Will store 1 if routine fails, 0 otherwise
;
;NOTES:
; This routine is a partial replacement for thm_ui_xyclip, which became unwieldy to maintain
; as the reponsibilities of the routine diverged.
pro thm_ui_draw_object::xclip,xPtr,yPtr,zPtr,range,scale,mirrorptr=mirrorptr,fail=fail

  compile_opt idl2

  fail = 1
  
  ;allocate output arrays
  outx = ptrarr(n_elements(xPtr))
  outy = ptrarr(n_elements(yPtr))
  outz = ptrarr(n_elements(zptr))
  
  if keyword_set(mirrorptr) then begin
    outmirror = ptrarr(n_elements(mirrorptr))
  endif
  
  ;loop over traces
  for i = 0,n_elements(xPtr)-1 do begin
  
    ;skip any traces that are invalid for any reason
    if ~ptr_valid(xPtr[i]) || $
       ~ptr_valid(yPtr[i]) then continue
   
    ;temporary allocations for the purpose of this algorithm
    x = temporary(*xPtr[i])
    y = temporary(*yPtr[i])
  
    if keyword_set(mirrorptr) && $
       ptr_valid(mirrorptr[i]) then begin
       mirror = temporary(*mirrorptr[i])
    endif else begin
       mirror = 0
    endelse  
    
    if ptr_valid(zPtr[i]) then begin
      z = temporary(*zPtr[i])
    endif else begin
      z = 0
    endelse
    
    ;apply logarithmic scaling to x values, out of range values will be marked by translation in -Inf, then removed when we screen out of range values
    if scale eq 1 then begin
      x = alog10(x)
    endif else if scale eq 2 then begin
      x = alog(x)
    endif
    
    ;sort x if spectral quantity
    if keyword_set(z) then begin
    
      sortidx = bsort(x)
      x = x[sortidx]
      
      if ndimen(y) eq 2 then begin
        y = y[sortidx,*]
      endif
      
      z = z[sortidx,*]
    
    endif
  
    ;identify out of range values
    idx = where(x lt range[0],c)
    
    if ~keyword_set(z) then begin
      ;add some margin, if possible
      if c gt 1 then begin
        idx = idx[0:n_elements(idx)-2]
        x[idx] = !values.d_nan
      endif
;      if c gt 0 then begin
;        x[idx] = !values.d_nan
;      endif
    endif else begin
      if c eq n_elements(x) then begin
        x[idx] = !values.d_nan
      endif else if c gt 1 then begin
        ;if we can, add a little bit of margin to the spectral plot
        ;this way we won't have blank edges when we zoom
        idx = idx[0:c-2]
        x[idx] = !values.d_nan
      endif
    endelse
    
    idx = where(x gt range[1],c)
    
    if ~keyword_set(z) then begin
;     if c gt 0 then begin
;       x[idx] = !values.d_nan
;     endif
      ;this code adds a little bit of margin
      ;to prevent gaps from clipping
      if c gt 1 then begin
        idx = idx[1:n_elements(idx)-1]
        x[idx] = !values.d_nan
      endif
    endif else begin
      if c eq n_elements(x) then begin
        x[idx] = !values.d_nan
      endif else if c gt 1 then begin
        ;if we can, add a little bit of margin to the spectral plot
        ;this way we won't have blank edges when we zoom
        idx = idx[1:c-1]
        x[idx] = !values.d_nan
      endif
    endelse
     
    ;now clip out of range values
    
    idx = where(finite(x),c)
     
    ;if no legitimate values are available, then the outptrs are left as null
    if c gt 0 then begin
    
      x = x[idx]
    
      ; clipping z-values entails 2-dimensional clipping
      if keyword_set(z) then begin
         
        if ndimen(y) eq 2 then begin
          y = y[idx,*]
        endif

        z = z[idx,*]
        
        outz[i] = ptr_new(temporary(z))
    
      endif else begin
   
       ;clipping z-values, is 1-d but may also entail clipping a mirror
        y = y[idx]
        
        if keyword_set(mirror) then begin
          mirror = mirror[idx]
          outmirror[i] = ptr_new(temporary(mirror))
        endif
    
      endelse
      
      outx[i] = ptr_new(temporary(x))
      outy[i] = ptr_new(temporary(y))
    endif
    
  endfor
  
  ;replace input data with output
  ptr_free,xPtr,yPtr,zPtr
  
  if keyword_set(mirrorptr) then begin
    ptr_free,mirrorPtr
    mirrorPtr = outmirror
  endif
  
  xPtr = outx
  yPtr = outy
  zPtr = outz
  
  fail = 0
       
end

;This function returns indices of all the data values greater(or less) 
;than the index limit + 1(or -1).  It is vectorized, so
;that it will work quickly even if there is a lot of data. 
;
;Inputs:
;  Data(2-dimensional array of data points any numeric type):
;     The values that will be modified dims = MxN
;  Idx(array of indices): an M element array of indices 
;     that specify the limit.  All indices greater(or less) than
;     this index + 1 in a particular column will be returned  
;  Less(boolean keyword):  If set, indicates that indices less than
;                    index - 1 should be returned
;                    
;Outputs: 
;  All the indices that fit the limit critereon, -1 if no values found.
;  
;NOTES:
; 1.  This is used in y-clipping spectrograms.  We want there to be a small amount
;  of margin on spectrograms to prevent any blank from showing up at the edge
;  of plots, but we don't want to render the whole data set because performance
;  would suffer a precipitous drop.
;  
;2. Each element of data[i,*] should be sorted in descending order.
;
;3. This is quite tricky to do without looping, hence the magic.
;
function thm_ui_draw_object::indexMagic,data,idx,less=less

  compile_opt idl2
  
  ;if we have 1 offending value, it is swallowed by the margin
  ;any more than that, and there is a chance that we'll need
  ;to NaN-clip
  if n_elements(idx) gt 1 then begin

    ;turn the 1-d indices into pairs of 2-d indices
    idx2 = array_indices(data,idx)
    
    ;sort on x-value
    ;This is the central trick. A side effect of a stable sort
    ;on pre-sorted inputs, is that the values for each individual
    ;x-will now be sorted.  Because IDL:'sort' is not stable, 'bsort'
    ;must be used by this algorithm
    srt2 = bsort(idx2[0,*])
    
    ;now reorder indices in order of ascending x indices
    idx2 = idx2[*,srt2]
    
    ;this block identifies all the indicies that are not the minimum(or max) in a column
    if keyword_set(less) then begin
      idx3 = where((shift(idx2[0,*],1)-idx2[0,*]) eq 0,c)
    endif else begin
      idx3 = where((shift(idx2[0,*],-1)-idx2[0,*]) eq 0,c)
    endelse
    
    ;if any exist we return our magic indexes
    if c gt 0 then begin
   
      return,idx2[*,idx3]
  
    endif
    
  endif
  
  return,-1

end

;This routine, performs prepocessing with respect to the y-axis
;
;1. translates data from linear to log space, if necessary
;2. Removes invalid values or marks with NaNs depending on whether trace in spectrographic and spec geometry.
;   Reasons for marking/removing
;    a. non-finite.
;    b. out of range
;    c. le 0 on log axis
;    
;3. Performs analogous removals on z/mirror data
;
;Inputs:
;
;xPtr(array of pointers to arrays):  A list of the data quantities for all x-values used in the panel. 
;                     The number of pointers should match the number of pointers in y and z.  
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer
;yPtr(array of pointers to arrays) : A list of the data quantities for all y-values used in the panel. 
;                     The number of pointers should match the number of pointers in x and z. 
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer
;zPtr(array of pointers to arrays) : A list of the data quantities for all z-values used in the panel. 
;                     The number of pointers should match the number of pointers in x and y.            
;                     If an x/y has no z(ie line plot), the corresponding element should be a null pointer     
;  
;range(2-element double) : The min and max y-range that the data should be clipped to.
;
;scale(long) : The scaling method to be used on this axis(0: linear,1:log10,2:logN)
;
;mirrorPtr(array of pointers to arrays) : A list of the data quantities for all mirror-values used in the panel. 
;                     The number of pointers should match the number of pointers in x,y, z            
;                     If an x/y has no mirror the corresponding element should be a null pointer      
;
;Outputs: 
;  xPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  yPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  zPtr(array of pointers to arrays): Input data replaced with clipped data. Format is the same
;  fail(named variable keyword):  Will store 1 if routine fails, 0 otherwise
;
;NOTES:
; This routine is a partial replacement for thm_ui_xyclip, which became unwieldy to maintain
; as the reponsibilities of the routine diverged.
pro thm_ui_draw_object::yclip,xPtr,yPtr,zPtr,range,scale,mirrorptr=mirrorptr,fail=fail

  compile_opt idl2
  
  fail = 1
  
  ;allocate output arrays
  outx = ptrarr(n_elements(xPtr))
  outy = ptrarr(n_elements(yPtr))
  outz = ptrarr(n_elements(zptr))
  
  if keyword_set(mirrorptr) then begin
    outmirror = ptrarr(n_elements(mirrorptr))
  endif
  
  for i = 0,n_elements(yPtr)-1 do begin
  
    ;skip any traces that are invalid for any reason
    if ~ptr_valid(xPtr[i]) || $
       ~ptr_valid(yPtr[i]) then continue
       
    ;temporary allocations for the purpose of this algorithm
    x = temporary(*xPtr[i])
    y = temporary(*yPtr[i])
  
    if keyword_set(mirrorptr) && $
       ptr_valid(mirrorptr[i]) then begin
       mirror = temporary(*mirrorptr[i])
    endif else begin
       mirror = 0
    endelse   
    
    if ptr_valid(zPtr[i]) then begin
      z = temporary(*zPtr[i])
    endif else begin
      z = 0
    endelse
    
    ;sort 1 dimensional y-axis....I'm not sure what to do with 2-d ones here
    ;This is descending, as per the convention in tplot/themis data
    ;If the y is ascending, the data will have vertical inversion and probably other problems
    if keyword_set(z) && ndimen(y) eq 1 then begin
    
      idx = reverse(bsort(y))
      
      y = y[idx]
      z = z[*,idx]
    
    endif
       
    ;apply logarithmic scaling to x values, out of range values will be marked by translation in -Inf, then removed when we screen out of range values
    if scale eq 1 then begin
      y = alog10(y)
    endif else if scale eq 2 then begin
      y = alog(y)
    endif 
    
    if keyword_set(mirror) then begin
      if scale eq 1 then begin
        mirror = alog10(mirror)
      endif else if scale eq 2 then begin
        mirror = alog(mirror)
      endif
      
;      idx = where(mirror lt range[0] or mirror gt range[1],c)
;      
;      if c ne 0 then begin
;        mirror[idx] = !VALUES.D_NAN
;      endif
      
      outmirror[i] = ptr_new(temporary(mirror))
      
    endif

   ;doesn't remove non-spec data, NaN marks is sufficient, and prevents ugly clips of line plots
    if ~keyword_set(z) then begin
    
;      idx = where(y lt range[0] or y gt range[1],c)
;      if c gt 0 then begin
;        y[idx] = !VALUES.D_NAN
;      endif
      
    endif else begin
    
      ;Spectral plots are created
      ;using bin-centers.  So if we clip to the range
      ;we clip out 1/2 a bin.  This code leaves 1-bin of margin, to 
      ;prevent blank edges from clipping.


      ;Lower Bound Clip Block

      ;this code assumes that the y-axis is sorted and descending, which happens to
      ;be the convention used with tplot variables.    
      idx = where(y lt range[0],c)
      
      if c eq n_elements(y) then continue
      
      if c gt 1 then begin
      
        if ndimen(y) eq 1 then begin
        
          idx = idx[1:c-1]    
          y[idx] = !VALUES.D_NAN
          z[*,idx] = !VALUES.D_NAN
        
        endif else begin
          ;this code should perform the same operation as was performed on the 1-d data
          ;but it performs it for each column of y's.
          ;It requires some complex index manipulations to do vectorized
          idx2 = self->indexMagic(y,idx,/less)
          
          ;it returns 2-d indices, so we should expect at least 2 elements if we have any clipping to do.
          if n_elements(idx2) gt 1 then begin
         
            y[idx2[0,*],idx2[1,*]] = !VALUES.D_NAN
            z[idx2[0,*],idx2[1,*]] = !VALUES.D_NAN
            
          endif
        
        endelse
      
      endif
      
      ;Upper Bound Clip Block
      
      
      ;this code assumes that the y-axis is sorted and descending, which happens to
      ;be the convention used with tplot variables.    
      idx = where(y gt range[1],c)
      
      if c eq n_elements(y) then continue
      
      if c gt 1 then begin
      
        if ndimen(y) eq 1 then begin
        
          idx = idx[0:c-2]    
          y[idx] = !VALUES.D_NAN
          z[*,idx] = !VALUES.D_NAN
        
        endif else begin
        
         ;this code should perform the same operation as was performed on the 1-d data
          ;but it performs it for each column of y's
          idx2 = self->indexMagic(y,idx)
          
          ;it returns 2-d indices, so we should expect at least 2 elements if we have any clipping to do.
          if n_elements(idx2) gt 1 then begin
         
            y[idx2[0,*],idx2[1,*]] = !VALUES.D_NAN
            z[idx2[0,*],idx2[1,*]] = !VALUES.D_NAN
            
          endif
          
        endelse
           
      endif
    
      ;now clip.  Why clip?  Performance improves significantly if we can pare down the data-set
      if ndimen(y) eq 1 then begin
      
        idx = where(finite(y),c)
           
        ;don't draw if there are no valid points
        if c eq 0 then continue
      
        y = y[idx]
        z = z[*,idx]
      
      endif else begin
      
        ;this expression will only have a nan at any position if every value in the row at that position is NaN 
        max_val = max(y,dimension=1,/nan)
      
        ;interior rows should not be removed, unless their neighboring rows are also all NaNs
        ;this fun code identifies these rows
        ;This vector technique operates something like the game minesweeper
        idx = where(finite(max_val),c,complement=comp)
        
        if c ne 0 then begin
          max_val[idx] = 1
        endif
        
        if c ne n_elements(max_val) then begin
          max_val[comp] = 0
        endif
        
        ;0 pad to prevent the computation from getting messed up
        row_indicator = [0,max_val,0]
        
        row_indicator = shift(row_indicator,1)+row_indicator+shift(row_indicator,-1)
        
        ;clip off the padding
        row_indicator = row_indicator[1:n_elements(row_indicator)-2]
         
        valid = where(row_indicator gt 0,c)
        
        if c eq 0 then begin
          ;don't draw if there are no valid points
          continue
        endif
        
        ;remove any leading rows that are all nans
        if valid[0] eq 0 && max_val[0] eq 0 && n_elements(valid) gt 1 then begin
          valid = valid[1:n_elements(valid)-1]
        endif 
        
        ;remove any trailing rows that are all nans
        if valid[n_elements(valid)-1] eq n_elements(max_val)-1 && max_val[n_elements(max_val)-1] eq 0 && n_elements(valid) gt 1 then begin
          valid = valid[0:n_elements(valid)-2]
        endif
        
        ;clip the rows off
        y = y[*,valid]
        z = z[*,valid]
         
      endelse
    
      outz[i] = ptr_new(temporary(z))
    
    
    endelse   
    
    outx[i] = ptr_new(temporary(x))
    outy[i] = ptr_new(temporary(y))
  
  endfor
  
  ptr_free,xPtr,yPtr,zPtr
  
  if keyword_set(mirrorptr) then begin
    ptr_free,mirrorPtr
    mirrorPtr = outmirror
  endif
  
  xPtr = outx
  yPtr = outy
  zPtr = outz
  
  fail = 0

end

;This routine sets the locked settings for a top panel in a column of a layout.
;Inputs:
;  panel(object): Reference to a thm_ui_panel that will be modified.
;                 This will generally be a copy to prevent mutation of
;                 central gui copy.
pro thm_ui_draw_object::lockTop,panel

  compile_opt idl2

  panel->getProperty,xaxis=xaxis,markers=markers
  
 ; panel->setProperty,showvariables = 0
  
  ;General purpose axis settings
  if obj_valid(xaxis) then begin
  
    xaxis->getProperty,placeAnnotation=pa
    
    ;We turn off labels, annotations, & date if annotations
    ;are set to be placed on the bottom
    if ~pa then begin
      xaxis->setProperty,showlabels = 0
      xaxis->setProperty,annotateAxis = 0
      xaxis->setProperty,showdate=0 
    endif 
    
 
  endif
  
  ;If marker title is below the axis, then move it to the middle
  if obj_valid(markers) then begin
    marker_list = markers->get(/all)
    
    if ~is_num(marker_list[0]) then begin
      for i = 0,n_elements(marker_list)-1 do begin
      
        marker_list[i]->getProperty,settings=msettings
        
        if obj_valid(msettings) then begin
          msettings->getProperty,vertPlacement=vert
          
          if vert eq 6 then begin
            msettings->setProperty,vertPlacement=3
          endif
        endif
        
      endfor
    endif
  endif
  
end

;This routine sets the locked settings for a middle panel in a column of a layout.
;Inputs:
;  panel(object): Reference to a thm_ui_panel that will be modified.
;                 This will generally be a copy to prevent mutation of
;                 central gui copy.
pro thm_ui_draw_object::lockMiddle,panel

  compile_opt idl2

  panel->getProperty,xaxis=xaxis,settings=settings,markers=markers
  
 ; panel->setProperty,showVariables = 0
  
  ;Whether top or bottom, we turn off the annotations/labels/date for x-axis
  if obj_valid(xaxis) then begin

    xaxis->setProperty,$ ;tickStyle=0, $
                     showdate=0,$
                     showlabels=0,$
                     annotateAxis=0
  endif

  ;Turn off panel title.
  if obj_valid(settings) then begin
    settings->getProperty,titleobj=title
   
    if obj_valid(title) then begin
      title->setProperty,show=0
    endif
  
  endif 
  
   ;If marker title is above or below the axis, then move it to the middle
  if obj_valid(markers) then begin
    marker_list = markers->get(/all)
    
    if ~is_num(marker_list[0]) then begin
      for i = 0,n_elements(marker_list)-1 do begin
      
        marker_list[i]->getProperty,settings=msettings
        
        if obj_valid(msettings) then begin
          msettings->getProperty,vertPlacement=vert
          
          if vert eq 6 || vert eq 0 then begin
            msettings->setProperty,vertPlacement=3
          endif
        endif
        
      endfor
    endif
  endif
  
end

;This routine sets the locked settings for a bottom panel in a column of a layout.
;Inputs:
;  panel(object): Reference to a thm_ui_panel that will be modified.
;                 This will generally be a copy to prevent mutation of
;                 central gui copy.
pro thm_ui_draw_object::lockBottom,panel

  compile_opt idl2
  
  panel->getProperty,xaxis=xaxis,settings=settings,markers=markers
  
  
  if obj_valid(xaxis) then begin
  
    xaxis->getProperty,placeAnnotation=pa
  
    ;Turn off annotations/labels/date, if the are being placed on the top of the panel
    if pa then begin
      xaxis->setProperty, annotateAxis=0,showlabels=0,showdate=0
    endif 
    
  endif
  
  ;Turn off panel title.(No room above)
  if obj_valid(settings) then begin
    settings->getProperty,titleobj=title
    
    if obj_valid(title) then begin    
      title->setProperty,show=0
    endif
  
  endif
  
  ;If marker title is above the axis, then move it to the middle
  if obj_valid(markers) then begin
    marker_list = markers->get(/all)
    
    if ~is_num(marker_list[0]) then begin
      for i = 0,n_elements(marker_list)-1 do begin
      
        marker_list[i]->getProperty,settings=msettings
        
        if obj_valid(msettings) then begin
          msettings->getProperty,vertPlacement=vert
          
          if vert eq 6 || vert eq 0 then begin
            msettings->setProperty,vertPlacement=3
          endif
        endif
        
      endfor
    endif
  endif
  
end

;draws the panels for this window.
;This routine is the workhorse of the draw object,
;
;Inputs:
;  Layout Dims(2-elements long):  The number of rows and columns in the layout(from the thm_ui_window)
;  Margins(6-elements double):  The size of the margins for the panel in points. Elements are as follows
;                               [left,right,top,bottom,horizontal_internal,vertical_internal]
;  PanelObjs(array of objects):  Array of references to the thm_ui_panel objects being drawn
;  LoadedData(object): Reference to the thm_ui_loaded_data object in which the data to be plotted is stored
;  Backgroundcolor(3-element Byte array):  The color of the background, needed to emulate some transparency effects.
;  Locked(long index):  The locked value from the window object.  -1 is unlocked, otherwise it is the index
;                       of the panel to which others are locked.  Index in terms of the list of panelObjs
;  Window(object):  The active window from which the drawn panels originate. Needed to query layout information.
;  
;  
;Outputs:
;  returns 1 on success, 0 on failure
;  
;Mutates:
;  self.panelViews,self.staticViews,self.dynamicViews,self.panelInfo
;  
;NOTE:  The order in which various elements of the panel are added to the display is IMPORTANT
;If you change the ordering be sure to check that this change hasn't oscured some
;important feature.
function thm_ui_draw_object::updatePanels,layoutDims,margins,panelObjs,loadedData,backgroundcolor,locked,window

  compile_opt idl2
  
  systm = systime(/seconds)
  
  ;This factor determines the distance the panel title is placed from the panel proper
  panelTitleVposFactor = .1
  
  dataXptr = ptr_new()
  dataYptr = ptr_new()
  dataZptr = ptr_new()
  
  ;Normalize the margin values to draw area
  marginsNorm = [self->pt2norm(margins[0],0),$ ;left
    self->pt2norm(margins[1],0),$ ;right
    self->pt2norm(margins[2],1),$ ;top
    self->pt2norm(margins[3],1),$ ;bottom
    self->pt2norm(margins[4],0),$ ;internal margin x
    self->pt2norm(margins[5],1)]  ;internal margin y
    
  ;these structures serve as a quick reference for performing fast graphical operations
  panelInfoStruct = {xplotpos:[0D,1D],$ ;position of the plot
    yplotpos:[0D,1D],$
    margins:dblarr(5),$ ; size of edge components.  Used for identifying location of click in panel [left,right,top,bottom,vars]
    locked:0,$
    lockedRange:[0D,1D],$ ; alternative range to use for plot scaling, in the event of locked panels
    lockedScale:0,$; alternative scaling to use
    xrange:[0D,1D],$  ;data range of the plot
    yrange:[0D,1D],$
    zrange:[0D,1D],$
    xmajorSize:0D,$ ;size of a major tick in converted data space(log applied if logarithimic)
    ymajorSize:0D,$
    xscale:0,$ ;indicates log or normal scaling
    yscale:0,$
    xcenter:0d, $
    ycenter:0d, $
    lockedcenter:0d, $
    xmajorNum:0,$ ; the number of major ticks on the x-axis
    ymajorNum:0,$ ; the number of major ticks on the y-axis
    zmajorNum:0,$ ; the number of major ticks on the z-axis
    xminorNum:0,$ ; the number of minor ticks on the x-axis
    yminorNum:0,$ ; the number of minor ticks on the y-axis
    zminorNum:0,$ ; the number of minor ticks on the z-axis
    xisTime:0,$ ;indicates whether the axis is time
    yisTime:0,$
    hasSpec:0,$ ;boolean, indicates whether a spectrogram is present
    hasLine:0,$ ;boolean, indicates whether a line is present
    zscale:0,$ ;indicates log/lin scaling for z axis
    zisTime:0,$ ;indicates whether the z axis is a time(I'm not sure a z time axis is possible)
    zplacement:4,$ ;0:top,1:bottom,2:left,3:right,4:no zaxis
    markerIdx:-1,$ ; indicates the index the highlighted marker(if any) on this panel
    traceInfo:ptr_new(),$ ;ptr to array of info for each trace
    varInfo:ptr_new(),$ ; ptr to array of variable info
    markerInfo:ptr_new(),$ ; ptr to array of marker info
    vBar:obj_new(),$ ;ptr to vertical bar model
    hBar:obj_new(),$ ;ptr to horizontal bar model
    marker:obj_new(),$ ;ptr to currently drawing marker model
    annotation:obj_new(),$ ;ptr to annotation view
    view:obj_new(),$ ;ptr to main view
    xobj:obj_new(),$ ;ptr to independent variable 1 legend text object
    yobj:obj_new(),$ ;ptr to independent variable 2 legend text object
    legendModel:obj_new(), $ ;the model in which the legend is stored
    legendAnnoModel:obj_new() $ ; the model in which the legend annotations are stored
    }
    
  traceInfoStruct = { $
    isSpec:0,$
    ;                     dataX:ptr_new(),$
    ;                     dataY:ptr_new(),$
    ;                     dataZ:ptr_new(),$
    refData:ptr_new(),$
    abcissa:ptr_new(),$
    plotData:ptr_new(), $ ;pointer to a struct in which some information is passed internally. 
    dataName:'',$
    color:[0,0,0],$
    textObj:obj_new() $   ;text object that displays dependent variable text output
    }
    
  varInfoStruct = { $
    dataX:ptr_new(),$ ;ptr to the x data quantity(note that this is normalized data, not real data)
    dataY:ptr_new(),$ ; ptr to the y data quantity
    textObj:obj_new(),$ ; ptr to the text object to be updated during tracking
    isTime:0B, $ ; indicates whether the data y is a time
    annotateStyle:0, $ ; the annotation style for the output
    scaling:0, $ ;0=linear,1=log10,2=log
    range:[0D,1D] $
    }
    
  markerInfoStruct = { $
    pos:[0D,1D], $ ;the x-start & x-stop of the marker in normalized panel coordinates
    color:[0B,0B,0B], $ ; the original color of the frame
    frames:[obj_new(),obj_new()], $ ;the IDLgrPolyline objects for the left and right sides of the marker frame
    selected:0, $  ;indicates whether marker is selected
    displayed:0 $  ;indicates whether the marker is displayed at this level of zoom
    }
    
  lockedIsTime = -1
    
  panelInfoArray = replicate(panelInfoStruct,n_elements(panelObjs))
  
  ;Gets the variable size of all the variables in the layout
  ;Note this has a problem, because it doesn't account for panels in separate columns
  ;It should get the height of all the variables in a column.
  variableSizes = self->pt2norm(self->getVariableRowSizes(panelObjs),1)
  
  ;calculate the range of the locked panel
  ;so that we can use it on other panels
  if locked ne -1 then begin
  
    if locked ge n_elements(panelObjs) then begin
      self.historyWin->update,'Warning: Locked value requests locking to nonexistent panel'
      self.statusBar->update,'Warning: Locked value requests locking to nonexistent panel'
    endif else begin
      currentPanel = panelObjs[locked]
      currentPanel->getProperty,traceSettings=traceSettings,xAxis=xAxis,yAxis=yAxis,zAxis=zAxis
  
      ;reverse the order of trace processing so that spectrograms layer correctly
      traces = reverse(traceSettings->get(/all))
      
      ;extract and process data
      if obj_valid(traces[0]) then begin
      
        yaxis->getProperty,scaling=yscale
        
        ;Removes copies of data from draw object,
        ;Performs some basic formatting.
        ;Generate mirror data if needed
        self->collateData,traces,loadedData,yscale=yscale,outXptrs=dataXptr,outYptrs=dataYptr,outZptrs=dataZptr,mirror=mirrorptr,fail=fail,dataNames=dataNames,dataidx=dataidx
        
        if fail then begin
          self.historyWin->update,'Failed to read data for locking master panel'
          return,0
        endif
        
        if dataidx[0] ne -1 then begin
        
          ;some data quantities may turn out invalid, so we remove those
          traces = traces[dataidx]
          dataXptr = dataXptr[dataidx]
          dataYptr = dataYptr[dataidx]
          dataZptr = dataZptr[dataidx]
          mirrorptr = mirrorptr[dataidx]
          datanames = datanames[dataidx]
          
          ;get plot range       
          self->getRange,dataXptr,xAxis,range=lockedRange,scaling=lockedScale,istime=lockedIsTime,fail=fail,center=lockedcenter
          
          if fail then begin
            self.historyWin->update,'No range on locking master panel.'
            return,0
          endif else begin
            ptr_free,dataXptr,dataYptr,dataZptr,mirrorPtr
          endelse
          
         endif else begin
           self.historyWin->update,'No valid data on locking master panel.'
           lockedRange = [0D,1D]
           lockedScale = 0
           lockedcenter = 0.5
         endelse
       endif else begin
         self.historyWin->update,'No valid traces on locking master panel'
         lockedRange = [0D,1D]
         lockedScale = 0
         lockedcenter = 0.5
       endelse
    endelse
  endif
  

  ;This is the big loop in this function,
  ;It loops over all the panelObjects
  for i = 0,n_elements(panelObjs) - 1 do begin
    
    ;print,"panel:",i,systime(/seconds)-systm
    
    currentPanel = panelObjs[i]
   
    ;Modify settings to reflect locked expectations.
    ;This will override some user settings
    if locked ne -1 then begin
    
      ;The window tells us where the panel is within the layout
      ;I suspect this can be fooled by irregular layouts
      panelLayoutPos = window->getPanelPos(currentPanel)
      
      if panelLayoutPos eq -1 then begin
        self.historyWin->update,'Problem evaluating locked panel layout'
        self.statusBar->update,'Problem evaluating locked panel layout'
        return,0
      endif else if panelLayoutPos eq 1 then begin
        self->lockBottom,currentPanel
      endif else if panelLayoutPos eq 2 then begin
        self->lockMiddle,currentPanel
      endif else if panelLayoutPos eq 3 then begin
        self->lockTop,currentPanel
      endif ;doesn't modify a panel that is only in column
    
    end
  
    currentPanel->getProperty,settings=settings,markers=markerContainer,variables=variableContainer,showvariables=showvariables
    settings->getProperty,row=row,col=col,rSpan=rSpan,cSpan=cSpan, $
      backgroundcolor=color,titleobj=titleobj,framecolor=framecolor, $
      framethick=framethick,titleMargin=titleMargin
      
    layoutPos = [row,col,rSpan,cSpan]
    
    ;Coordinates of the panel in points.
    pcoord = currentPanel->getPanelCoordinates()
    
    ;normalize coordinates
    pcoord = [(pcoord[0] ne -1)?self->pt2norm(pcoord[0],0):-1,$
      (pcoord[1] ne -1)?self->pt2norm(pcoord[1],1):-1,$
      (pcoord[2] ne -1)?self->pt2norm(pcoord[2],0):-1,$
      (pcoord[3] ne -1)?self->pt2norm(pcoord[3],1):-1]
      
    ;Pull any markers out of IDL_Container
    markerNum = 0
    if obj_valid(markerContainer) && obj_isa(markerContainer,'IDL_Container') then begin
      markerList = markerContainer->get(/all)
      
      if obj_valid(markerList[0]) then begin
        markerNum = n_elements(markerList)
        markerInfo = replicate(markerInfoStruct,markerNum)
      endif
    endif
    
    varNum = 0
    ;showvariables = 1
    
    ;Pull any variables out of IDL_Container
    if obj_valid(variableContainer) && $
      obj_isa(variableContainer,'IDL_Container') && $
      showvariables then begin
      varList = variableContainer->get(/all)
      
      if obj_valid(varList[0]) then begin
        varNum = n_elements(varList)
        varInfo = replicate(varInfoStruct,varNum)
        panelInfoArray[i].varInfo = ptr_new(varInfo)
      endif
    endif
        
    ;The next call returns all the different views used for different parts of the panels
    ;I'd very much like to create the returned views by calling this routine each time I need a view,(rather than returning multiple identical items from 1 call)
    ;but for some reason the transparency doesn't work if I do that.  It seems very odd, although maybe I'm missing something obvious.
    ;(like mutating an input so that the second call produces differing results)
    self->makeView,$
      layoutDims,$
      marginsNorm,$
      layoutPos,$
      pcoord,$
      markernum,$
      variablesizes,$
      view=view,$
      annotation=annotation,$
      markers=markerviews,$
      xplotPos=xplotPos,$
      yplotpos=yplotpos,$
      outmargins=outmargins,$
      fail=fail
             
    if fail then return,0
     
    panelInfoArray[i].annotation=annotation
    panelInfoArray[i].view=view
    panelInfoArray[i].margins=outmargins
    
    ;This should be fixed, mutation will not have any outward effect. 
    ;It should
    newsize = self->getpanelsize(xplotpos,yplotpos)
    currentPanel->setPanelCoordinates,newsize
    
    ;add views to graphics tree
    self.panelViews->add,view
    self.panelViews->add,annotation
    
    ;add static components to the list of static views
    self.staticViews->add,view
    ;add animated components to the list of dynamic views
    self.dynamicViews->add,annotation
    
    ;title
    
    if obj_valid(titleobj) then begin
    
      grTitleObj = self->getTextObject(titleobj,[.5,self->pt2norm(titleMargin,1)/(yplotpos[1]-yplotPos[0])+1.,.5],1,0)
      
      grTitle = obj_new('IDLgrModel')
      
      grTitle->add,grTitleObj
      
      view->add,grTitle
      
    endif
    
    ;get data quantities
    
    currentPanel->getProperty,traceSettings=traceSettings,xAxis=xAxis,yAxis=yAxis,zAxis=zAxis
    
    ;reverse the order of trace processing so that spectrograms layer correctly
    traces = reverse(traceSettings->get(/all))
    
    ;extract and process data
    if obj_valid(traces[0]) then begin
    
      yaxis->getProperty,scaling=yscale
      
      self->collateData,traces,loadedData,yscale=yscale,outXptrs=dataXptr,outYptrs=dataYptr,outZptrs=dataZptr,mirror=mirrorptr,fail=fail,dataNames=dataNames,dataidx=dataidx
      
      if fail then return,0
      
      if dataidx[0] ne -1 then begin
      
        ;some data quantities may turn out invalid, so we remove those
        traces = traces[dataidx]
        dataXptr = dataXptr[dataidx]
        dataYptr = dataYptr[dataidx]
        dataZptr = dataZptr[dataidx]
        mirrorptr = mirrorptr[dataidx]
        datanames = datanames[dataidx]
        
        ;get plot x range
        
        self->getRange,dataXptr,xAxis,scaling=xscaling,range=xrange,fail=fail,center=lockedCenter

        ;translate the range into the scaling used by this trace
        if size(lockedRange,/type) then begin
        
          panelInfoArray[i].locked = 1
          panelInfoArray[i].lockedRange = lockedRange
          panelInfoArray[i].lockedScale = lockedScale
          if ~undefined(lockedCenter) then panelInfoArray[i].xcenter= lockedCenter
        
          currentRange = lockedRange
          currentScale = lockedScale
        
        endif else begin
          currentRange = xrange
          currentScale = xscaling
        endelse
        
        
        ;The large block of nested if-statements below
        ;performs all the data processing tasks to prepare
        ;the data for plotting and in the event of a failure,
        ;to properly set the remaining values in such a way
        ;that it fails gracefully 
        
        if fail then begin
        
          traceInfoArray = 0
          xrange = [0D,1D]
          if size(lockedRange,/type) then begin
            currentRange=lockedRange
            currentScale = lockedScale
          endif else begin
            currentRange = [0D,1D]
            currentScale = 0
          endelse
          yrange = [0D,1D]
          yscale = 0
          zrange = [0D,1D]
          traces = 0
          zscaling = 0
          
        endif else begin
        
          panelInfoArray[i].xrange=xrange
          panelInfoArray[i].xscale=xscaling
          if ~undefined(lockedCenter) then panelinfoarray[i].xcenter=lockedCenter
          
          ;clip the data with respect to x-axis
          self->xclip,dataXptr,dataYptr,dataZptr,currentRange,currentScale,fail=fail,mirrorptr=mirrorptr
          
          ;   thm_ui_xyclip,dataXptr,dataYptr,dataZptr,xrange,xscaling,fail=fail,transposez=0,mirrorptr=mirrorptr
          
          if fail then begin
          
            traceInfoArray = 0
            yrange = [0D,1D]
            yscale = 0
            zrange = [0D,1D]
            traces = 0
            zscaling  = 0
            
          endif else begin
          
            ;get plot y range
            self->getRange,dataYptr,yAxis,scaling=yscaling,mirror=mirrorptr,range=yrange,fail=fail,center=ycenter
            
            if fail then begin
            
              traceInfoArray = 0
              traces = 0
              yrange = [0D,1D]
              zrange = [0D,1D]
              zscaling = 0
              
            endif else begin
            
              panelInfoArray[i].yrange=yrange
              panelInfoArray[i].yscale=yscaling
              if ~undefined(yCenter) then panelinfoarray[i].ycenter=ycenter
              
              ;clip with respect to y axis
              self->yclip,dataXptr,dataYptr,dataZptr,yrange,yscaling,fail=fail,mirrorptr=mirrorptr
          
              
              ; thm_ui_xyclip,dataYptr,dataXptr,dataZptr,yrange,yscaling,fail=fail,transposez=1,yaxis=1,mirrorptr=mirrorptr
              ;thm_ui_xyclip,mirrorptr,dataXptr,dataZptr,yrange,yscaling,fail=fail,transposez=1,keepnans=1
              
              if fail then begin
                traceInfoArray = 0
                traces = 0
                zrange = [0D,1D]
                zscaling = 0
              endif else begin
              
                ;print,"gotxy range",systime(/seconds)-systm
              
                if obj_valid(zAxis) then begin
                
                  ; panelInfoArray[i].hasSpec = 1
                
                  ;get plot z range
                  self->getZRange,dataZptr,zAxis,range=zrange,scaling=zscaling,fixed=zFixed,fail=fail
                 
                  if fail then begin
                    traceInfoArray = 0
                    traces = 0
                    zrange = [0D,1D]
                    zscaling = 0
                  endif else begin
                  
                    panelInfoArray[i].zscale=zscaling
                    panelInfoArray[i].zrange=zrange
                    
                  ;  self->zclip
                    
                    ;clip with respect to z-axis
                    thm_ui_xyzclip,dataZptr,zrange,zscaling,fail=fail
                    
                    if fail then begin
                      traceInfoArray = 0
                      traces = 0
                    endif
                  endelse
                  
                  traceInfoArray = replicate(traceInfoStruct,n_elements(traces))
                  
                  ; traceInfoArray[*].isSpec = 1
                  ;        traceInfoArray[*].dataX = dataXptr
                  ;        traceInfoArray[*].dataY = dataYptr
                  ;        traceInfoArray[*].dataZ = dataZptr
                  if obj_valid(traces[0]) then begin
                    ;set the list of names on each trace
                    traceInfoArray[*].dataName = dataNames
                  endif
                  
                endif else begin
                
                  zrange = [0D,1D]
                  zscaling = 0
                
                  traceInfoArray = replicate(traceInfoStruct,n_elements(traces))
                  
                  ; traceInfoArray[*].isSpec = 0
                  ;        traceInfoArray[*].dataX = dataXptr
                  ;        traceInfoArray[*].dataY = dataYptr
                  ;        traceInfoArray[*].dataZ = dataZptr
                  if obj_valid(traces[0]) then begin
                    traceInfoArray[*].dataName = dataNames
                  endif
                endelse
              endelse
            endelse
          endelse
        endelse
        
      endif else begin
        traceInfoArray = 0
        if size(lockedRange,/type) then begin
          currentRange=lockedRange
          currentScale = lockedScale
        endif else begin
          currentRange = [0D,1D]
          currentScale = 0
        endelse
        yrange = [0D,1D]
        yscale = 0
        zrange = [0D,1D]
        traces = 0
        zscaling = 0
      endelse
      
    ;print,"got zrange",systime(/seconds)-systm
      
    endif else begin
      traceInfoArray = 0
      if size(lockedRange,/type) then begin
        currentRange=lockedRange
        currentScale = lockedScale
      endif else begin
        currentRange = [0D,1D]
        currentScale = 0
      endelse
      yrange = [0D,1D]
      yscale = 0
      zrange = [0D,1D]
    endelse
    
    ;draw permanent markers
    if markerNum gt 0 then begin
      zstack = .21 + .0001
      for j = 0,n_elements(markerList)-1 do begin
      
        self->addMarker,markerviews[j],markerList[j],currentrange,zstack,fail=fail,markerpos=markerpos,markerframes=markerframes,markercolor=markercolor,markerSelected=markerSelected
        
        if ~fail then begin
        
          ;set all the information needed for operations that occur between updates
          zstack += .0001
          self.panelViews->add,markerviews[j]
          markerInfo[j].pos = markerpos
          markerInfo[j].frames = markerFrames
          markerInfo[j].color = markercolor
          markerInfo[j].displayed = 1
          markerInfo[j].selected = markerSelected
          ;adding marker view to dynamic view list
          self.dynamicViews->add,markerViews[j]
          
        endif else begin
          markerInfo[j].displayed = 0
          obj_destroy,markerviews[j]
        endelse
        
      endfor
      panelInfoArray[i].markerInfo = ptr_new(markerInfo)
      
    endif
    
    ;make axes
    
    ;DEFSYSV,'!VIEW',view
    
    ;This creates all models associated with the x axis
    self->makeXYaxisModel, $
                      0,$
                      currentrange,$
                      yrange,$
                      currentScale,$
                      xAxis,$
                      yplotpos,$
                      xplotpos,$
                      framecolor,$
                      framethick,$
                      backgroundcolor,$
                      useIsTime=lockedIsTime,$                 
                      model=xAxisModel,$
                      gridmodel=gridmodelx,$
                      majors=xAxisMajors,$
                      minorNum=xMinorNum,$
                      isTimeAxis=xistime,$
                      labelpos=labelpos,$
                      fail=fail
    
    if fail then return,0
    
    ;This creates all models associated with the y axis
    self->makeXYaxisModel, $
                      1,$
                      currentrange,$
                      yrange,$
                      yscale,$
                      yAxis,$
                      xplotpos,$
                      yplotpos,$
                      framecolor,$
                      framethick,$
                      backgroundcolor,$      
                      model=yAxisModel,$
                      gridmodel=gridmodely,$
                      majors=yAxisMajors,$
                      minorNum=yMinorNum,$
                      isTimeAxis=yistime,$
                      fail=fail
    
    if fail then return,0
    
    ;Some processing on these major variables.
    ;They will be stored for return to the
    ;calling routine via getPanelInfo
    
    if n_elements(xAxisMajors) lt 2 then begin
      ;if x axis majors are not set, use the x-range
      xMajorSize = currentrange[1]-currentrange[0]
      xMajorNum = 0
    endif else begin
      ;this rescales the x-majors into data space.  
      xMajorSize = (currentRange[1]-currentRange[0])*median(xAxisMajors[1:n_elements(xAxisMajors)-1]-xAxisMajors[0:n_elements(xAxisMajors)-2])
      xMajorNum = n_elements(xAxisMajors)-2
    endelse
    
    if n_elements(yAxisMajors) lt 2 then begin
      ;if y axis majors are not set, use the y-range
      yMajorSize = yrange[1]-yrange[0]
      yMajorNum = 0
    endif else begin
      ;this rescales the y-majors into data space.  
      yMajorSize = (yrange[1]-yrange[0])*median(yAxisMajors[1:n_elements(yAxisMajors)-1]-yAxisMajors[0:n_elements(yAxisMajors)-2])
      yMajorNum = n_elements(yAxisMajors)-2
    endelse
    
    
    ;Storing information about major ticks for output
    panelInfoArray[i].xmajorsize=xmajorsize
    panelInfoArray[i].ymajorsize=ymajorsize
    
    panelInfoArray[i].xmajornum=xmajornum
    panelInfoArray[i].ymajornum=ymajornum
    
    panelInfoArray[i].xminornum=xminornum
    panelInfoArray[i].yminornum=yminornum
    
    panelInfoArray[i].xistime=xistime
    panelInfoArray[i].yistime=yistime
    
    ;If we have a z-axis object
    if obj_valid(zAxis) then begin
    
      ;Get the z-axis color palette number( number corresponds to rainbow, hot-cold, themis, etc...not in that order)
      zaxis->getProperty,colorTable=paletteNum
  
      ;The actual z-range of autoscaled data may actually decrease during the clipping that occurs during rendering
      ;This variable is used as part of a fix that rescales at the last minute to increase dynamic range.  In other words,
      ;if the plot is zoomed, data that is not on screen could make the z-range wider than it would be if not for this fix. 
      if ~keyword_set(zfixed) then begin
        zRangeRecalc = [!VALUES.D_NAN,!VALUES.D_NAN]
      endif
    endif
    
    ;If we have any valid traces
    ;this block will generate models representing the 
    ;data itself
    if obj_valid(traces[0]) then begin
    
      ;Calculate the size of the panel for the purpose of generating spec plots
      ;This will be a 2-element array, with the values being some multiple/fraction of the 
      ;number of pixels on each axis respectively.
      panel_sz_pt = self->getPlotSize(xplotpos,yplotpos,self.specres)
      
      ;If we're generating a postscript,
      ;All the spectral plots in a panel will be turned
      ;into a single composite image.  Prior to this
      ;They will be stored in this container
      if self.postscript then begin
        spec_list = obj_new('IDL_Container')
      endif
      
      ;Loop over traces in the panel
      for j = 0,n_elements(traces)-1 do begin
      
        ;Create line model
        if obj_isa(traces[j],'thm_ui_line_settings') && $
          ptr_valid(dataXptr[j]) && $
          ptr_valid(dataYptr[j]) then begin
          
          panelInfoArray[i].hasLine = 1
          
          ;Generate a line plot model, and the reference data associated with it.
          linePlot = self->getLinePlot(traces[j],currentRange,yrange,xplotpos,yplotpos,currentScale,yscaling,xAxisMajors,dataXptr[j],datayPtr[j],panelInfoArray[i].xistime,linecolor=linecolor,mirrorptr=mirrorptr[j],refvar=refvar,abcissa=abcissa)
          if ~obj_valid(linePlot) then begin
            self.statusbar->update,'Error: Could not generate the plot due to internal error'
            self.historyWin->update,'Error: Could not generate the plot due to internal error'
            ;ok = error_message('Invalid line plot, indicates plot generation error',/traceback)
            return,0
          endif
          
          ;Store the parameters that are generated during line plot creation 
          traceInfoArray[j].color = linecolor
          
          ;The dependent variable lookup table for the legend
          if size(refVar,/type) then begin
            traceInfoArray[j].refData = ptr_new(refVar)
          endif
          
          traceInfoArray[j].isSpec = 0
          
           
          ;The independent variable lookup table for the legend
          ;This is not needed in the current schema because lookup
          ; can be done by the pixel index
          if size(abcissa,/type) then begin
          ;if keyword_set(abcissa) && ~xistime then begin
            traceInfoArray[j].abcissa = ptr_new(abcissa)
          endif
          
          ;Add the line model to the view
          view->add,linePlot
          
        ;Create Spectral Reference Data
        endif else if obj_isa(traces[j],'thm_ui_spectra_settings') && $
          ptr_valid(dataXptr[j]) && $
          ptr_valid(dataYptr[j]) && $
          ptr_valid(dataZptr[j]) && $
          obj_valid(zAxis) then begin
          
          panelInfoArray[i].hasSpec = 1
          
          ;This routine grids spectral data and performs any additional clipping that can be done after gridding.
          ;This also finds a new range after gridding and clipping, which is necessary to prevent loss of dynamic range on z.
          ;Because of dependency issues with the rescaling, the complete model cannot be generated at this step.  
          self->getSpecRef,currentRange,yrange,panel_sz_pt[0],panel_sz_pt[1],currentScale,yscaling,zscaling,dataXptr[j],datayptr[j],datazptr[j],refvar=refvar,plotdata=plotdata
          
          ;These store the results of getSpecRef in the info struct
          
          if size(refvar,/type) ne 0 then begin
            traceInfoArray[j].refData = ptr_new(refVar)
        
            traceInfoArray[j].isSpec = 1
            
          endif
          
          if size(plotData,/type) ne 0 then begin
            traceInfoArray[j].plotData = ptr_new(plotData)
            
            if ~keyword_set(zfixed) then begin
              zRangeRecalc[0] = min([zrangeRecalc[0],min(plotdata.data,/nan)],/nan)
              zRangeRecalc[1] = max([zrangeRecalc[1],max(plotdata.data,/nan)],/nan)
            endif
            
          endif
          
        endif
        
      endfor
      
      ;Now that we've definitively clipped and gridded the z-data
      ;We loop over the data again and create the true model.  The z-data
      ;Will be appropriately scaled to ensure we bound the data tightly.
      if panelInfoArray[i].hasSpec then begin
      
        if ~keyword_set(zFixed) && finite(zRangeRecalc[0]) && finite(zRangeRecalc[1]) then begin
      
          zRange = zRangeRecalc
      
        endif    
      
        for j = 0,n_elements(traces)-1 do begin
          if traceInfoArray[j].isSpec && ptr_valid(traceInfoArray[j].plotData) then begin
            
            ;This routine actually generates the model
            self->getSpecModel,traceInfoArray[j].plotData,zrange,paletteNum,model=specModel
          
            ;Either add to the view, or add to the list
            ;for creation of composite image
            if obj_valid(specModel) then begin
              if ~self.postscript then begin
                view->add,specModel
              endif else begin
                spec_list->add,specModel
              endelse
            endif
          
          endif
        endfor
      
      endif
      
      if self.postscript && spec_list->count() then begin
      
        ;This takes all the individual images and generates a single composite image,
        ;Which it puts in a model.
        model = self->aggregateSpecplots(spec_list,panel_sz_pt,color)
        ;and the model goes on the main view
        view->add,model
        
      endif
      
    endif
    
    ;Now that the z-range has been definitely locked down, we create the z-axis
    if obj_valid(zAxis) then begin
      self->makeZAxisModel,zrange,zAxis,xplotpos,yplotpos,framecolor,framethick,model=zAxisModel,majorNum=zMajorNum,minorNum=zMinorNum
      zaxis->getProperty,placement=placement
      ;This stores any information from axis creation process
      panelInfoArray[i].zplacement=placement   
      panelInfoArray[i].zmajornum=zmajornum
      panelInfoArray[i].zminornum=zminornum  
    endif
    
    ;  print,"made plot",systime(/seconds)-systm
    
    
    ;Now we generate models for dynamic content
    vBarModel = obj_new('IDLgrModel')
    hBarModel = obj_new('IDLgrModel')
    markerModel = obj_new('IDLgrModel') ;This is the model for markers in the process of being drawn, not completed markers
    
    ;And store any other parameters identified
    panelInfoArray[i].xplotpos=xplotpos
    panelInfoArray[i].yplotpos=yplotpos
    panelInfoArray[i].vBar=vBarModel
    panelInfoArray[i].hBar=hBarModel
    panelInfoArray[i].marker = markerModel
    
    currentPanel->getProperty,labelMargin=labelMargin
    
    ;This adds the variables to the current panel
    if varNum gt 0 then begin
      self->addVariables,view,annotation,varList,panelInfoArray[i],loadedData,xAxisMajors,xAxis,labelpos,labelMargin,varptr=varptr
      ptr_free,panelInfoArray[i].varInfo
      panelInfoArray[i].varInfo=varptr
    endif
    
    ; print,"added info",systime(/seconds)-systm
    
    ;annotation->add,vBarModel
    annotation->add,vBarModel
    annotation->add,hBarModel
    annotation->add,markerModel
    
    ;This adds the panel background
    self->addBackGround,view,color
    
    ;This adds the 2-line date string that normally rests in the bottom left or top left
    self->addDateString,view,xAxis,currentRange,currentScale,xplotpos[1]-xplotpos[0],yplotpos[1]-yplotpos[0],labelMargin
    
    if keyword_set(traceInfoArray) then begin
      paTmp = panelInfoArray[i] ;error occurs if you edit the array in place
      
      ;This generates the initial rendering of the legend.  The final appearance will be controlled
      ;Largely by turning the hide flags for the model on and off dynamically
      self->addLegend,view,annotation,paTmp,traceInfoArray
      panelInfoArray[i] = paTmp
      ;print,"added other fun stuff",systime(/seconds)-systm
      panelInfoArray[i].traceInfo = ptr_new(traceInfoArray)
    endif else begin
      panelInfoArray[i].traceInfo = ptr_new()
    endelse
    
    ;add models to the view
    ;The order in which they were added matters because this changes layering,
    ;even though it shouldn't
    
    ;Currently prior to axes, so that they will be below them in the layering
    view->add,gridmodelx
    view->add,gridmodely
    view->add,xAxisModel
    view->add,yAxisModel
  
    
    if obj_valid(zAxis) then begin
      view->add,zAxisModel
    endif
    
    ;  ptr_free,dataXptr,dataYptr,dataZptr
    
    dataXptr = ptr_new()
    dataYptr = ptr_new()
    dataZptr = ptr_new()
    
    ;Garbage collect any memory sitting around from this last iteration.
    ;Most languages would do this automatically, but IDL seems pretty 
    ;bad about it.
    heap_gc
  ;print,"did everything",systime(/seconds)-systm
    
  endfor
  
  self.panelInfo = ptr_new(panelInfoArray)
  
  return,1
  
end

;this routine constructs a reference for legend lookup that has
;no more than the number of points on the screen times some number
;to account for pixel-level aliasing.  Operation vectorized with
;value-locate  
;x = clipped abcissa values, normalized to fractions of the total
;y = clipped data values, with the same number of elements as x
;n = the number of points requested in the output
;ref = data returned in named variable
;tolerance = the distance that a cursor can be from a real data point, before NaNs
;              get filled in.  This is a number proportional to the x range.(ex: .01 = 1% tolerance)
pro thm_ui_draw_object::makeLineReference,x,y,n,ref=ref,tolerance=tolerance

  compile_opt idl2

  ;m = n_elements(x)
  
  ;set to 100% tolerance.  Meaning NANs will never be filled in unless they are in the data.
  if ~keyword_set(tolerance) then begin
    tolerance = 1.
  endif 
  
  minx = min(x,/nan)
  maxx = max(x,/nan)
  
  ref = dblarr(n)
  ref[*] = !VALUES.D_NAN
  
  ;These are fractional positions of points
  ;at which data values will be requested
  vals = (dindgen(n)/(n-1) > 0) < 1
  
  ;This pads the abcissas to deal with some
  ;of the weirdness in value_locate's output indexes
  datx = [minx-.001,x,maxx+.001]
  
;**********Save this code***********
;This code resamples the data rather than interpolates, it is being commented 
;because it can leave large NaN sized gaps in the results. 
;  
  ;value_locate requires sorted data, but
  ;the abcissa values may not be.
  ;So we sort, then later we unsort
  sort_idx = bsort(datx) ;sort transform
  isort_idx = bsort(sort_idx) ;inverse sort transform
  
  datx = datx[sort_idx]
  
  ;Locate the values
  close_idx = value_locate(datx,vals)
  
  ;The list of abcissa values one higher than the requested locations
  lows = abs((datx)[close_idx]-vals) 
  ;The list of abcissa values one lower than the requested locations
  highs = abs((datx)[close_idx+1]-vals)
  
  ;The list of lows that are closer to the values than highs and within
  ;the tolerance
  idx_lows = where(lows lt highs and lows lt tolerance,count_lows)
  
  ;Store these values.  To get to the final results, we need to use the inverse sort
  ;on the locations
  if count_lows gt 0 then begin
    ref[idx_lows] = ([!VALUES.D_NAN,y,!VALUES.D_NAN])[isort_idx[close_idx[idx_lows]]]
  endif
  
  ;The list of highs that are closer to the values than lows and within
  ;the tolerance
  idx_highs = where(highs lt lows and highs lt tolerance,count_highs)
  
  ;Store these values.  To get to the final results, we need to use the inverse sort
  ;on the locations
  if count_highs gt 0 then begin
    ref[idx_highs] = ([!VALUES.D_NAN,y,!VALUES.D_NAN])[isort_idx[close_idx[idx_highs]+1]]
  endif
  
end

;adds thm_ui_variables to requested display
pro thm_ui_draw_object::addVariables, $
    view, $  ;the view to which they will be added
    annotation,$ ;the view to which the legend text will be added
    vars, $  ;the list of variables to be added
    panelInfo, $ ;the panel info struct
    loadedData, $ ;loaded data object
    xMajors,$  ; the positions of the major ticks on the x axis
    xAxis,$ ;the x axis of the panel
    labelPos,$ ;most extreme position of the labels
    labelMargin,$ ;the distance from the edge of the panel that labels should be placed
    varptr=varptr ; Output, a pointer to variable info structures representing displayed variable
    
  compile_opt idl2
  zstack = .1
  
  ;decrease this number to fill variable values with NaNs if they are not within a % difference from the true value
  tolerance = 1.0
  
  ;this factor will convert normalized window coords into normalized panel coords
  xpanelConv = panelInfo.xplotpos[1] - panelInfo.xplotpos[0]
  ypanelConv = panelInfo.yplotpos[1] - panelInfo.yplotpos[0]
  spacing = self->pt2norm(2,1)/ypanelConv ; the amount of space between each variable
  
  validmask = intarr(n_elements(vars))
  
  ;number of pixels across the panel * res_factor = number of points in lookup
  linedim = self->getPlotSize(panelInfo.xplotpos,panelInfo.yplotpos,self.lineres)
  xpx = linedim[0]
  
  model = obj_new('IDLgrModel')
  anno_model = obj_new('IDLgrModel')
  
  xAxis->getProperty, $  ;should probably also account for annotation orientation, but I'm not gonna stress that at this point
    tickStyle=tickStyle,$
    bottomPlacement=bottomPlacement,$
    majorLength=majorLength,$
    minorLength=minorLength,$
    annotateAxis=annotateAxis,$
    placeAnnotation=placeAnnotation,$
    margin=margin,$
    scaling=xscaling,$
    annotateFirstTick=annotateFirstTick,$
    annotateLastTick=annotateLastTick,$
    annotateTextObject=annotateTextObject,$
    annotateExponent=annotateExponent,$
    showDate=showDate
    
  xAxisMajors = xMajors
  
  ;Determine if we need to draw variables at first or last tick,
  ;Based upon related axis settings
  if ~annotateFirstTick then begin
    if n_elements(xAxisMajors) gt 1 then begin
      xAxisMajors = xAxisMajors[1:n_elements(xAxisMajors)-1]
    endif else begin
      noXMajors = 1
    endelse
  endif
  
  if ~annotateLastTick then begin
    if n_elements(xAxisMajors) gt 1 then begin
      xAxisMajors = xAxisMajors[0:n_elements(xAxisMajors)-2]
    endif else begin
      noXMajors = 1
    endelse
  endif
  
  ;if ticks are outside the bottom axis, how long are they?
  ;Use this distance to shift variables.
  if bottomPlacement && (tickStyle eq 1 || tickStyle eq 2) then begin
    tickLoc = self->pt2norm(majorLength > minorLength,1)/ypanelConv
  endif else begin
    tickLoc = 0
  endelse
  
  ;If annotations are drawn on the bottom, more shift-down is required.
  if annotateAxis && ~placeAnnotation && obj_valid(annotateTextObject) then begin
    labelLoc = abs(labelPos)
    annotateTextObject->getProperty,size=size
    annoLoc = tickLoc +  self->pt2norm(size,1)/ypanelConv
  endif else begin
    ;otherwise we only shift down according to tick length
    annoLoc = tickLoc
    labelLoc = 0
  endelse
  
  if showDate && ~placeAnnotation && obj_valid(annotateTextObject) then begin
    annotateTextObject->getProperty,size=size
    dateLoc = tickLoc +  2*self->pt2norm(size,1)/ypanelConv
  endif else begin
    ;otherwise we only shift down according to tick length
    dateLoc = tickLoc
  endelse
  
 ; yloc = 0. - (labelloc > annoloc) - 3*spacing
  
  yloc = 0. - max([labelloc,annoloc,dateLoc])
  
  varInfoArray = *panelInfo.varInfo
  
  ;Loop over the variables on this panel
  for i = 0,n_elements(vars)-1 do begin
  
    vars[i]->getProperty, $
      fieldname=fieldname,$
      controlname=controlname,$
      text=text,$
      format=format,$
      minRange=minRange,$
      maxRange=maxRange,$
      scaling=vscaling,$
      useRange=useRange,$
      annotateExponent=annotateExponent
      
    text->getProperty,size=size,show=show
    
    ;If it is not displayed, skip it.
    if ~show then continue
    
    ;Shift down 1-line after each variable is written
    yloc -= (spacing + self->pt2norm(size,1)/ypanelConv)
    ;This value determines how far to the left the variable title should be placed
    ;and how far to the left the text objects for the variable legend should go.
    xloc = 0. - self->pt2norm(labelMargin,0)/xpanelConv
    
    textObj = self->getTextObject(text,[xloc,yloc,zstack],1,0,justify=1,/enable_formatting)
    
    model->add,textObj
    
    ;Extract the dependent variable from the loaded data object
    if keyword_set(fieldname) && loadedData->isChild(fieldname) then begin
      loadedData->getVarData,name=fieldname,data=yd,isTime=isTime,/duplicate
      varInfoArray[i].dataY = yd
      varInfoArray[i].isTime = isTime
    endif else begin
      continue
    endelse
    
    ;Extract the independent variable from the loaded data object
    if keyword_set(controlname) && loadedData->isChild(controlname) then begin
      loadedData->getVarData,name=controlname,data=xd,/duplicate
      ;varInfoArray[i].dataX = xd
      ;xscaling = vscaling
      
      ;independent data range
      xrange = [min(*xd,/nan),max(*xd,/nan)]
    endif else begin
    
      ;dummy independent variable
      xd2 = ptr_new(dindgen(n_elements(*yd[0]))/(n_elements(*yd[0])-1))
      varInfoArray[i].dataX = xd2
      xrange = [0D,1D]
    endelse
    
    ;Override default independent data range with panel data range, or
    ;Fixed value from user.
    if userange eq 2 then begin
    
      if panelInfo.locked then begin
        xrange = panelInfo.lockedRange
        xscaling = panelInfo.lockedScale
      endif else begin
        xrange = panelInfo.xrange
        xscaling = panelInfo.xscale
      endelse
      
      vars[i]->setProperty,minrange=xrange[0],maxrange=xrange[1]
    endif else if userange eq 1 then begin
      xrange = [minRange,maxRange]
      xscaling = vscaling
    endif
    
    ;Store results in info struct
    varInfoArray[i].annotateStyle = format
    varInfoArray[i].scaling = xscaling
    varInfoArray[i].range = xrange
    
    if ptr_valid(xd) then begin
    
      ;if we're not using a dummy independent, then clip the data as normal
      self->xclip,xd,yd,ptr_new(),xrange,xscaling,fail=fail
         
      if fail then begin
        self.statusBar->update,'Error: Could not process variable control'
        self.historyWin->update,'Error: Could not process variable control'
        ;ok = error_message('Failure to process variable control:' + controlname)
        continue
      endif
    
      ;Normalize clipped x-values for creation of line reference  
      xdata = (temporary(*xd[0])-xrange[0])/(xrange[1]-xrange[0])
      ydata = temporary(*yd[0])
 
      ;Create legend reference for variable
      self->makeLineReference,xdata,ydata,xpx,ref=refvar
      
      varInfoArray[i].dataY = ptr_new(temporary(refvar))
      
    endif else begin
    
     ;Otherwise use dummy normalized data to create
     ;line reference with spacing proportional to element index 
     xdata = dindgen(n_elements(ydata))/n_elements(ydata)
     ydata = temporary(*yd) 
     self->makeLineReference,xdata,ydata,xpx,ref=refvar
    
     varInfoArray[i].dataY = ptr_new(temporary(refvar))
      
    endelse
    
    textTemp = text->copy()
    textTemp->setProperty,value=''
    
    ;Location of legend on the right side
    xloc = 1. + self->pt2norm(labelMargin,0)/xpanelconv
    
    ;The actual text object for the legend
    textObj = self->getTextObject(textTemp,[xloc,yloc,zstack],1,0,justify=-1,/enable_formatting)
    varInfoArray[i].textObj = textObj
    anno_model->add,textObj
    
    ; xmajornorm = (xAxisMajors-xrange[0])/(xrange[1]-xrange[0])
    annotatedata = {timeAxis:isTime,formatid:format,scaling:0,exponent:annotateExponent}
    
    if ~keyword_set(noXMajors) then begin
    
      ;Loop over the majors to place variable annotation at each tick
      for j = 0,n_elements(xAxisMajors)-1 do begin
      
        ;Find closest value to each major
        temp = min(abs(xdata - xAxisMajors[j]),idx,/nan)
        if temp lt tolerance then begin ;only use real valued annotation if major tick value close to an actual value
          value = ydata[idx]
        endif else begin
          value = !VALUES.D_NAN
        endelse
      
        
        ;And generate text string/object to display
        valueString = formatannotation(0,0,value,data=annotatedata)
        
        textTemp = text->copy()
        textTemp->setProperty,value=valuestring
        
        textObj = self->getTextObject(textTemp,[xAxisMajors[j],yloc,zstack],1,0,/enable_formatting)
        model->add,textObj
        
      endfor
    endif
      
    validmask[i] = 1
    
  endfor
  
  idx = where(validmask,c)
  
  if c gt 0 then begin
    varptr=ptr_new(varInfoArray[idx])
    view->add,model
    annotation->add,anno_model
  endif else begin
    varptr=ptr_new()
  endelse
  
end

;
;This routine aggregates the layout structures from
;the panel objects into one array.  This makes certain
;layout operations simpler
;
;INPUTS:
;  panels: An array of thm_ui_panels
;  
;OUTPUTS:
;  an array of layout structures returned by the thm_ui_panel->getLayoutStructure() method
; 
function thm_ui_draw_object::getPanelLayouts,panels

  compile_opt idl2
  
  layout_struct = panels[0]->getLayoutStructure()
  
  layout_array = replicate(layout_struct,n_elements(panels))
  
  for i = 0,n_elements(panels)-1 do begin
    layout_array[i] = panels[i]->getLayoutStructure()
  endfor

  return,layout_array

end

;
;Purpose:
;  generates an array that indicates the space variables will occupy for
;    each row in the layout, sizes are in pts
;  
;  INPUTS:
;    an array of thm_ui_panels
;    
;  OUTPUTS:
;    an array of sizes in pts
;
function thm_ui_draw_object::getVariableRowSizes,panels

  panel_layouts = self->getPanelLayouts(panels)
  
  max_row = max(panel_layouts[*].row+panel_layouts[*].rSpan-1)
  
  row_sizes = dblarr(max_row)
  
  for i = 0,max_row-1 do begin
  
    idx = where(panel_layouts[*].row+panel_layouts[*].rSpan-2 eq i,c)
    
    if c gt 0 then begin
      row_sizes[i] = self->getVariableSize(panels[idx])
    endif
  
  endfor
  
  return,row_sizes
  
end

;Calculates the maximum space that will be occupied, by any panel's x-axes
;Name is because it used to only account for variables
;Inputs:
;  panels(array of objects): List of thm_ui_panels
;
;NOTES:
;  consider returning an array of panel sizes and performing the max after the fact
;
function thm_ui_draw_object::getVariableSize,panels

  compile_opt idl2
  
  max_size = 0
  ;amount of pad
  spacing = 2
  
  ;loop over panels
  for i = 0,n_elements(panels)-1 do begin
    
    total = 0
  
    panels[i]->getProperty,variables=variables,showVariables=showvariables,xaxis=xaxis
    
;This needs to be finished.  Code needs to account for the space occupied by ticks, annotations, datestrings, & labels if it is to be able to render layouts without any collision or error.
;    if obj_valid(xAxis) then begin
;    
;      xAxis->getProperty,$
;            bottomPlacement=bottomPlacement,$
;            topPlacement=topPlacement,$
;            tickStyle=tickStyle,$
;            majorLength=majorLength,$
;            minorLength=minorLength,$
;            
;    
;    endif
    
   
    ;there is a 2 pt pad before, after,
    ;and between each variable section on the panel
    
    if obj_valid(variables) && $
      obj_isa(variables,'IDL_Container') && $
      showvariables then begin
      
      varList = variables->get(/all)
      if obj_valid(varList[0]) then begin
        total=spacing
      
        ;loop over variables.
        for j = 0,n_elements(varList)-1 do begin
        
         ;Get text height of the variable, if it is valid
          varList[j]->getProperty,text=text
          if obj_valid(text) then begin
            text->getProperty,size=size,show=show
            if ~show then continue
            total += size+spacing
          endif
          
        endfor
      endif
      
    endif
    
    max_size = max([max_size,total])
    
  endfor
  
  return,max_size
  
end

;This routine adds a permanent marker to a view
;This is contrasted with a temporary marker, which
;is only drawn as an animation during a cursor event.
;
;Inputs:
;view(IDLgrView): the view to which the marker should be added
;marker(thm_ui_marker): the thm_ui_marker that is being added
;xrange(2-element double): the xrange of that view, needed to position the marker
;zstack(single double): the height at which the marker should be placed.  Marker stacking is
;                         controlled by calling loop, to ensure that they layer correctly.
;Outputs:
;fail(boolean):  This will be set to 1 if a handled error occurs 0 otherwise.
;markerFrames(2-element object array),  2-IDLgrPolyline objects that constitute the border of the marker
;markerPos(2-element double array),  Stores the marker start and end 
;                                                    location normalized proportional to the panel
;markerColor(3-element byte array),  The color of the marker frame, prior to any hue rotation
;markerSelected(boolean):   Whether this marker is currently selected  
;                                                      
;
;NOTES:
;  Permanent marker is contrasted with a temporary marker, which
;  is only drawn as an animation during a cursor event.
pro thm_ui_draw_object::addMarker,view,marker,xrange,zstack,fail=fail,markerFrames=markerFrames,markerpos=markerpos,markercolor=markercolor,markerSelected=markerSelected

  compile_opt idl2
  
  fail = 1
  
  ;Markers are shifted up 5% above the input value
  textzStack = zstack+.05
  
  marker->getProperty,settings=settings,range=range,isSelected=isSelected
  
  settings->getProperty,$
    fillColor=fillColor,$
    lineStyle=lineStyle,$
    drawOpaque=drawOpaque,$
    label=label,$
    vertPlacement=vertPlacement
    
  ;only draw markers that are in range
  if range[0] ge xrange[1] then return
  
  range[0] = max([range[0],xrange[0]],/nan)
  
  if range[1] le xrange[0] then return
  
  range[1] = min([range[1],xrange[1]],/nan)
  
  ;normalized marker position, bounded on [0,1]
  xbegin = max([(range[0] - xrange[0])/(xrange[1]-xrange[0]),0D],/nan)
  xend = min([(range[1] - xrange[0])/(xrange[1]-xrange[0]),1D],/nan)
  
  lineStyle->getProperty,$
    id=lineid,$
    show=lineshow,$
    color=linecolor,$
    thickness=linethick
    
  ;A selected marker starts one rotation from initial color
  if isSelected then begin
    frameColor = self->hueRotation(self->hueRotation(linecolor))
  endif else begin
    frameColor = linecolor
  endelse
  
  ;border
  lineleft = obj_new('IDLgrPolyline',$
    [xbegin,xbegin],$
    [0.,1.],$
    replicate(zstack,2)+.00001,$
    linestyle=lineid,$
    hide=~lineshow,$
    color=self->convertColor(framecolor),$
    thick=linethick,$
    /double)
    
  lineright = obj_new('IDLgrPolyline',$
    [xend,xend],$
    [0.,1.],$
    replicate(zstack,2)+.00001,$
    linestyle=lineid,$
    hide=~lineshow,$
    color=self->convertColor(framecolor),$
    thick=linethick,$
    /double)
    
    
  ;this creates the semi-transparent shading
  poly = obj_new('IDLgrPolygon',$
    [xbegin,xend,xend,xbegin],$
    [0.,0.,1.,1.],$
    replicate(zstack,4),$
    color=self->convertColor(fillColor),$
    alpha_channel=drawOpaque, $
    /double)
    
  ;now create the label
    
  xpos = (xbegin+xend)/2D
  yposarray = 1D - dindgen(7)*1D/6D
  
  ypos = yposarray[vertPlacement]
  
  if vertPlacement eq 0 then begin
    offset = 1
  endif else if vertplacement eq 6 then begin
    offset = -1
  endif else begin
    offset = 0
  endelse
  
  ;marker title
  labelObj = self->getTextObject(label,[xpos,ypos,textZstack],offset,0)
  
  ;model for all this
  model = obj_new('IDLgrModel')
  
  ;adding the objects to the graphics tree
  model->add,lineleft
  model->add,lineright
  
  ;central portion is not added if
  ;postscript is on.  This is because transparency
  ;does not work in postscript, so rather than
  ;a see through pane, you get a solid grey block.
  if ~self.postscript then begin
    model->add,poly
  endif
 
  model->add,labelObj
  
  view->add,model
  
  ;storing the output
  markerpos = [xbegin,xend]
  markerframes = [lineleft,lineright]
  markercolor = linecolor
  markerSelected = isSelected
  
  fail = 0
  
end

;This routine adds a legend to a particular view/panel.
;
;Inputs:
;  view(IDLgrView):  The view to which the legend static components are added
;  annotation(IDLgrView): The view to which the legend dynamic components are added
;  panelInfo(struct):  This is the struct that stores all the information about the panel
;  traceInfoArray(array if structs):  This is an array of structs that store all the
;                                     info for all the traces in this panel
; 
;NOTE this routine is currently automatically generating labels
;IT SHOULDN'T BE DOING THIS.  When default labels are being
;correctly set, it should just use the label text object from
;the appropriate axis.
pro thm_ui_draw_object::addLegend,view,annotation,panelInfo,traceInfoArray

  compile_opt idl2
  
  textsize = 11  ;Base-text size for auto generated labels
  spacing = 2. ;Default vertical spacing between lines in legend
  zstack = .6  ;60% height of legend by default. Puts legend on top of most things
  
  numBias = 10 ; number of chars that annotation will take if using numerical output
  timeBias = 17 ; number of chars that annotation will take if using time output
  extraBias = 3 ; number of chars colon and space will take
  
  nchars = 0  ;Intialize the counter for the number of chars in the longest line
  nLines = 2+n_elements(traceInfoArray) ; The number of lines in the legend
 
  ;calculate the size of legend in chars
  ;the the legend should be as large as the most
  ;characters in any line
  ;Here the bias is the number of characters that will be
  ;contributed by the annotated value itself.(as opposed to the label)
  if panelInfo.xIsTime then begin
    text = 'X Axis Time'
    bias = timeBias
  endif else begin
    text = 'X Axis Value'
    bias = numBias
  endelse
  
  bias += extraBias
  
  nChars = nChars > (strlen(text)+bias)
  
  if panelInfo.yIsTime then begin
    text = 'Y Axis Time'
    bias = timeBias
  endif else begin
    text = 'Y Axis Value'
    bias = numBias
  endelse
  bias += extraBias
  nChars = nChars > (strlen(text)+bias)
    
  if panelInfo.hasSpec then begin
    if panelInfo.zisTime then begin
      bias = timeBias
    endif else begin
      bias = numBias
    endelse
    bias+= extraBias
  endif else begin
    if panelInfo.yistime then begin
      bias = timeBias
    endif else begin
      bias = numBias
    endelse
    bias+= extraBias
  endelse
  
  ;Identify the maximum number of characters in any line
  for i = 0,n_elements(traceInfoArray)-1 do begin
    nChars = nChars > (strlen(traceInfoArray[i].dataName)+bias)
  endfor
  
  ;2 is for colon and one extra
  ; nChars+=annoBias+extrabias
  
  xdiv = panelInfo.xplotpos[1]-panelInfo.xplotpos[0]
  ydiv = panelInfo.yplotpos[1]-panelInfo.yplotpos[0]
  
  ;these estimates assume that a character width is 1/2 its height
  ;this may not be accurate across systems
  width = self->pt2norm(textsize * nchars/2 + 2*spacing,0)/xdiv
  height = self->pt2norm(nlines * textsize + (nlines+1)*spacing,1)/ydiv
  
  ;if the legend is going to be outside of the view, we need to calculate a bias
  ;to shift it down/left so that it will not be clipped.
  view->getProperty,viewPlane_rect=vpr
  if width/2D gt vpr[2]+vpr[0]-1D then begin
    wbias = width/2D - (vpr[2]+vpr[0]-1D)
  endif else begin
    wbias = 0D
  endelse
  
  ;ensure that legend is not flush with edge of screen
  wbias += self->pt2norm(2.,0)/xdiv
  
  if height/2D gt vpr[3]+vpr[1]-1D then begin
    hbias = height/2D - (vpr[3]+vpr[1]-1D)
  endif else begin
    hbias = 0D
  endelse

  ;If the legend is turned on, then don't make it hidden
  if self.legendOn eq 1 || self.legendOn eq 2 then begin
    hide_val = 0
  endif else begin
    ;Even if turned off, still draw it and hide it, so we
    ;can turn it back on without a call to update
    hide_val = 1
  endelse
  
  model = obj_new('IDLgrModel',hide=hide_val)
  anno_model = obj_new('IDLgrModel',hide=hide_val)
  
  ;Legend background
  polygon = obj_new('IDLgrPolygon',$
    [1.-width/2.,1+width/2.,1+width/2.,1-width/2.]-wbias,$
    [1.-height/2.,1-height/2.,1+height/2.,1+height/2.]-hbias,$
    [zstack,zstack,zstack,zstack],color=self->convertColor([255,255,255]),/double)
    
  ;Legend border
  polyline = obj_new('IDLgrPolyline',$
    [1.-width/2.,1+width/2.,1+width/2.,1-width/2.,1.-width/2.]-wbias,$
    [1.-height/2.,1-height/2.,1+height/2.,1+height/2.,1-height/2.]-hbias,$
    [zstack,zstack,zstack,zstack,zstack]+.00001,color=self->convertColor([0,0,0]),/double)
    
  model->add,polyline
  model->add,polygon
  
  ;Spacing in normalized coordinates
  xspaceNorm = self->pt2norm(spacing,0)/xdiv
  yspaceNorm = self->pt2norm(spacing,1)/ydiv
  xcharNorm = self->pt2norm(textsize,0)/xdiv
  ycharNorm = self->pt2norm(textsize,1)/ydiv
  
  labelLocation=[1.-width/2. + xspacenorm - wbias,1.+height/2 - yspacenorm - ycharnorm - hbias,zstack+.05]
  valueLocation=[1.+width/2. - xspacenorm - wbias,1.+height/2 - yspacenorm - ycharnorm - hbias,zstack+.05]
  
  ;Different label depending on whether x is a time or not
  if panelInfo.xIsTime then begin
    text = 'X Axis Time'
  endif else begin
    text = 'X Axis Value'
  endelse
  
  ;space pad to line up colons
  text += ' :'
  
  ;Generate label text object
  thm_label = obj_new('thm_ui_text',value=text,size=textsize,font=2)
  xlabel = self->getTextObject(thm_label,labelLocation,1,0,justify=-1)
  model->add,xlabel
  
  ;Generate text object where values will be drawn
  thm_value = obj_new('thm_ui_text',value='',size=textsize,font=2)
  xvalue = self->getTextObject(thm_value,valueLocation,1,0,justify=1,/enable_formatting)
  panelInfo.xobj = xvalue
  anno_model->add,xvalue

  labelLocation[1] -= (yspacenorm+ycharnorm)
  valueLocation[1] -= (yspacenorm+ycharnorm)
  
  ;Different label depending on whether y is a time ro not
  if panelInfo.yIsTime then begin
    text = 'Y Axis Time'
  endif else begin
    text = 'Y Axis Value'
  endelse
  
  text += ' :'
  
  ;Generate labe
  thm_label = obj_new('thm_ui_text',value=text,size=textsize,font=2)
  ylabel = self->getTextObject(thm_label,labelLocation,1,0,justify=-1)
  model->add,ylabel
  
  ;Generate text object where values will be drawn
  thm_value = obj_new('thm_ui_text',value='',size=textsize,font=2)
  yvalue = self->getTextObject(thm_value,valueLocation,1,0,justify=1,/enable_formatting)
  panelInfo.yobj = yvalue
  anno_model->add,yvalue

  ; ycnt = 1
  ; zcnt = 1
  
  ;loop backwards because traces are in reverse order to create proper layering
  for i = n_elements(traceInfoArray)-1,0,-1 do begin
   ; if traceInfoArray[i].isSpec then begin
  
      labelLocation[1] -= (yspacenorm+ycharnorm)
      valueLocation[1] -= (yspacenorm+ycharnorm)
      
      text = traceInfoArray[i].dataName + ' :'
      
      ;Label for each trace
      thm_label = obj_new('thm_ui_text',value=text,size=textsize,font=2,color=traceInfoArray[i].color)
      olabel = self->getTextObject(thm_label,labelLocation,1,0,justify=-1)
      model->add,olabel
      
      ;Value text object for each trace
      thm_value = obj_new('thm_ui_text',value='',size=textsize,font=2,color=traceInfoArray[i].color)
      ovalue = self->getTextObject(thm_value,valueLocation,1,0,justify=1,/enable_formatting)
      traceInfoArray[i].textobj = ovalue
      anno_model->add,ovalue
  ;    thm_text = obj_new('thm_ui_text',value=text,size=textsize,font=2)
   ; endif
    
  endfor
  
  ;add to info 
  panelInfo.legendModel = model
  panelInfo.legendAnnoModel = anno_model
  
  ;If everything complete successfully add models to views
  view->add,model
  annotation->add,anno_model
  
end

;gets data from loadedData, collects into arrays and performs basic preprocessing.
;
;INPUT:
;
;  traces(array of objects): thm_ui_line_settings or thm_ui_spectra_settings, with names of data to be requested
;  loadedData(thm_ui_loaded_data):  The loaded data object from which data will be taken.
;  yscale(long): 0(linear),1(log10),or 2(logN) to indicate the scaling mode used for the y-axis.  This is needed if
;                a dummy y-axis needs to be generated for a spectral plot with no y-data specified.
;                
;OUTPUTS
;  outXPtrs(array of pointers):  An array of pointers containing the extracted X traces
;  outYPtrs(array of pointers):  An array of pointers containing the extracted Y traces
;  outZPtrs(array of pointers):  An array of pointers containing the extracted Z traces(or null pointers if corresponding trace is line)
;  mirror(array of pointers): An array of pointers containing pointers to mirror data(or null pointers if traces is not mirroring)
;  fail(boolean) : 1 if the operation fails, 0 otherwise
;  dataNames(array of strings):  Name of the dependent variable for each trace
;  dataidx(array of indexes):  The indices of traces that are valid after processing, -1 if non are.
; 
pro thm_ui_draw_object::collateData,traces,loadedData,yscale=yscale,outXPtrs=outXPtrs,outYPtrs=outYPtrs,outZptrs=outZPtrs,mirror=mirror,fail=fail,dataNames=dataNames,dataidx=dataidx

  compile_opt idl2
  
  fail=1
  
  ;allocate output processing
  outXPtrs = ptrarr(n_elements(traces))
  outYPtrs = ptrarr(n_elements(traces))
  outZPtrs = ptrarr(n_elements(traces))
  mirror=ptrarr(n_elements(traces))
  dataNames = strarr(n_elements(traces))
  specmask = intarr(n_elements(traces))
  
  ;loop ovr traces
  for i = 0,n_elements(traces)-1 do begin
  
    ;get data names
    traces[i]->getProperty,dataX=dataX,dataY=dataY
    
    ;get copies of the data
    loadedData->getvardata,name=dataX,data=xptr,/duplicate
    loadedData->getvardata,name=dataY,data=yptr,/duplicate
    
    ;handle spectral trace
    if obj_isa(traces[i],'thm_ui_spectra_settings') then begin
      ;get z-name
      traces[i]->getProperty,dataZ=dataZ
      
      ;get z data
      loadedData->getvardata,name=dataz,data=zptr,/duplicate
      
      ;slip spectral with missing data
      if ~ptr_valid(zptr) then continue
      
      d = dimen(*zptr)
      
      ;if y doesn't exist, then create it so that plotting can still be done
      ;The value selected will just space channels evenly.
      if ~keyword_set(dataY) then begin
      
        self.statusBar->update,'Warning: No yaxis quantity is present in spectral plot of: ' + dataZ + '. Y axis will be scaled proportionally.'
        self.historyWin->update,'Warning: No yaxis quantity is present in spectral plot of: ' + dataZ + '. Y axis will be scaled proportionally.'
        
        if n_elements(d) eq 1 then d = [d,1]
        
        ;scale the dummy y-value so that spacing will appear even on spectral plot
        if keyword_set(yscale) && yscale eq 1 then begin
          yvaltemp = 10^dindgen(d[1])
        endif else if keyword_set(yscale) && yscale eq 2 then begin
          yvaltemp = exp(dindgen(d[1]))
        endif else begin
          yvaltemp = dindgen(d[1])
        endelse
        
        yptr = ptr_new(transpose(rebin(yvaltemp,d[1],d[0])))
      endif
      
    endif
    
    ;skip plot with missing data
    if ~ptr_valid(xptr) || ~ptr_valid(yptr) then continue
    
    ;handle line trace specific mods
    if obj_isa(traces[i],'thm_ui_line_settings') then begin
    
      dataNames[i] = dataY
      
      ;find out if we need  mirror line
      traces[i]->getProperty,mirrorLine=mirrorLine
      
      outXptrs[i] = xptr
      
      ;screen y-data
      if ndimen(*yptr) gt 1 then begin
        self.statusBar->update,'Cannot have multi-d y-quantities on line plots'
        self.historyWin->update,'Cannot have multi-d y-quantities on line plots'
        return
      endif
      
      ;store y-data
      if n_elements(*xptr) eq n_elements(*yptr) then begin
        outYptrs[i] = yptr
      endif else begin
      
        self.historyWin->update,'Warning: X axis quantity does not match data quantity for: ' + dataY
        self.statusBar->update,'Warning: X axis quantity does not match data quantity for: ' + dataY
      
        ;if y does not match x, we interpolate them onto the same grid.
        outYptrs[i] = ptr_new(interpol(*yptr,n_elements(*xptr)))
        ptr_free,yptr
      endelse
      
      ;create reflected mirror data
      if mirrorLine then begin
        mirror[i]=ptr_new(-(*outYptrs[i]))
        *mirror[i]=double(*mirror[i])
      endif
      
      ;all data is treated as double precision inside the draw routine
      *outXptrs[i] = double(*outXptrs[i])
      *outYptrs[i] = double(*outYptrs[i])
      
    ;handle spectral settings
    endif else if obj_isa(traces[i],'thm_ui_spectra_settings') then begin
    
      ;this allows us to mask out the spectragrams from our list of traces      
      specmask[i] = 1
      
      dataNames[i] = dataZ
      
      outZptrs[i] = zptr
      
      dim = dimen(*zptr)
      
      ;IDL has an annoying habit of making dimensions disappear.
      ;Ensuring data is 2-d so algorithms work consistently
      if n_elements(dim) eq 1 then begin
        dim = [dim,1]
      endif
      
      ;store x-data
      if dim[0] eq n_elements(*xptr) then begin
        outXptrs[i] = xptr
      endif else begin
       
        self.historyWin->update,'Warning: X axis quantity does not match data quantity for: ' + dataZ
        self.statusBar->update,'Warning: X axis quantity does not match data quantity for: ' + dataZ
      
        ;if x does not match z, we interpolate onto the same grid
        outXptrs[i] = ptr_new(interpol(*xptr,dim[0]))
        ptr_free,xptr
      endelse
      
      dimy = dimen(*yptr)

      ;if the y-dimension is unchanging, we can use a more efficient
      ;draw pipeline

      ;This code block will make the y-axis 1-d, if possible
      if n_elements(dimy) eq 2 then begin      

        ;if the max is the same as the min in all columns
        ;then the value never changes over time
        max_val = max(*yptr,dimension=1,/nan,min=min_val)
        
        ;remove NaNs before performing check
        ;even with the /nan switch, 'max' can have nans in the output
        ;if every data value along a dimension in NaN
        idx = where(finite(max_val),c)
        
        if c ne 0 then begin
          max_val = max_val[idx]
          min_val = min_val[idx]
        endif

        ;if the data is all NaNs or unchanging, then we can clip down to 1d
        if array_equal(max_val,min_val) || c eq 0 then begin
          tmp = ptr_new(reform((*yptr)[0,*]))
          ptr_free,yptr
          yptr=tmp
          dimy = dimen(*yptr)
        endif
        
      endif
        
      ;if the y-axis data doesn't match, interpolate onto the z-grid
      if n_elements(dimy) eq 2 then begin 
        ;if everything matches up, then store the result
        if dim[0] eq dimy[0] && dim[1] eq dimy[1] then begin
          outYptrs[i] = yptr
        endif else begin 
          self.historyWin->update,'Warning: Y axis quantity does not match data quantity for: ' + dataZ
          self.statusBar->update,'Warning: Y axis quantity does not match data quantity for: ' + dataZ
        
         ;otherwise match the elements to the contents of the z-axis data
          outYptrs[i] = ptr_new(interpolate(*yptr,dimy[0]*dindgen(dim[0])/dim[0],dimy[1]*dindgen(dim[1])/dim[1],/grid))
          ptr_free,yptr
        endelse
        
      endif else begin
      
        if dim[1] eq dimy[0] then begin
          outYptrs[i] = yptr
        endif else begin
          outYptrs[i] = ptr_new(interpol(*yptr,dim[1]))
          ptr_free,yptr
        endelse
        
      endelse
        
      
      ;all data is treated as double precision inside the draw routine
      *outXptrs[i] = double(*outXptrs[i])
      *outYptrs[i] = double(*outYptrs[i])
      *outZptrs[i] = double(*outZptrs[i])
      
    endif else begin
      self.statusbar->update,'Error: Draw object was passed illegal trace settings'
      self.historyWin->update,'Error: Draw object was passed illegal trace settings'
      ; ok = error_message('Illegal trace settings passed to draw object',/traceback)
      return
    endelse
    
  endfor
  
  fail = 0
  
  ;construct the list of valid trace indices 
  dataidx = where(ptr_valid(outXptrs) and ptr_valid(outYptrs) and (~specmask or ptr_valid(outZptrs)))
  
end

;Generates a gridded and fully clipped spectragram during the update function.
;The output from this is used to generate the model for display and used directly
;as a reference for the legend
;
;Inputs:
;  xrange(2 element double):  The range([min,max]) of the panel on the x-axis.
;  yrange(2 element double):  The range([min,max]) of the panel on the y-axis.
;  xpanel_sz_pt(long):  The size of the panel in the x-direction.  Units are a multiple/fraction of screen pixels. 
;  ypanel_sz_pt(long):  The size of the panel in the y-direction.  Units are a multiple/fraction of screen pixels.
;  xscale(long):  x axis scaling mode. 0(linear),1(log10),2(logN)
;  yscale(long):  y axis scaling mode. 0(linear),1(log10),2(logN)
;  zscale(long):  z axis scaling mode. 0(linear),1(log10),2(logN)
;  dx(ptr to array): x data for this spectral plot
;  dy(ptr to array): y data for this spectral plot
;  dz(ptr to array): z data for this spectral plot
;Outputs:
;  refVar(double array):  Array containing final clipped, gridded data
;  plotData(struct) : structure containing information about range,position,scaling, and clipping of resulting quantity, for use with getSpecModel
;
;NOTES:
;  1. xrange,yrange may be different from the range of the data because not all spectragrams span the entire panel, and some span more than the entire panel.
;  2.xpanel_sz_pt,ypanel_sz_pt will be increased due to aliasing correction factor, but decreased because panel spans only a portion of the screen
;


pro thm_ui_draw_object::getSpecRef,xrange,yrange,xpanel_sz_pt,ypanel_sz_pt,xscale,yscale,zscale,dx,dy,dz,refvar=refvar,plotData=plotData

  compile_opt idl2
  
  ; a = systime(/seconds)
  
  polygon = obj_new()
  
  zstack = .05
 
  ;extract the data 
  x = (*dx)
  y = (*dy)
  z = (*dz)
  
  ;calculate data min/max
  xs = min(x,/nan)
  xe = max(x,/nan)
  ys = min(y,/nan)
  ye = max(y,/nan)
  
  if keyword_set(refVar) then begin
    tmp = temporary(refVar)
  endif
  
  ;0 width range gets special treatment
  if xs eq xe then begin

    ;if the quantity takes up the entire range, then we're in business
    if xrange[0] eq xrange[1] then begin
      xstart = 0
      xsize = 1
    endif else begin
    ;if not, there is no way to figure out how to scale the quantity proportionally
      self.historyWin->update,'Cannot determine how to x-scale zero x-width spectrogram, with non-zero width x-range. Try using auto-range.'
      self.statusBar->update,'Cannot determine how to x-scale zero x-width spectrogram, with non-zero width x-range. Try using auto-range.'
      return
    endelse
  
  endif else begin
  
    ;size of the spectral data relative to the visible range
    xstart = (xs - xrange[0])/(xrange[1]-xrange[0])
  
    ;xsize can be greater than 1.  If this occurs the reference variable should have its indices clipped into range
    xsize = (xe-xs)/(xrange[1]-xrange[0])
    
  endelse
  
  ;0 width range gets special treatment
  if ys eq ye then begin
  
    ;if the quantity takes up the entire range, then we're in business
    if yrange[0] eq yrange[1] then begin
      ystart = 0
      ysize = 1
    endif else begin
      self.historyWin->update,'Cannot determine how to y-scale zero y-width(single channel) spectrogram with non-zero width y-range. Try using auto-range.'
      self.statusBar->update,'Cannot determine how to y-scale zero y-width(single channel) spectrogram with non-zero width y-range. Try using auto-range.'
    ;if not, there is no way to figure out how to scale the quantity proportionally
      return
    endelse
  
  endif else begin
  
    ;panel normal z-starting position
    ystart = (ys - yrange[0])/(yrange[1]-yrange[0])
    
    ;ysize can be greater than 1.  If this occurs the reference variable should have its indices clipped into range
    ysize = (ye-ys)/(yrange[1]-yrange[0])
  
  endelse
  
  ;scale by spectral plot size
  xdata_sz_pt = ceil(xsize*xpanel_sz_pt,/l64)
  ydata_sz_pt = ceil(ysize*ypanel_sz_pt,/l64)
  
  ;less than 1 pixel means no plot.
  if xdata_sz_pt le 0 || ydata_sz_pt le 0 then return
  
  ;Note that is the long run, this limitation can probably be avoided by adding an algorithm to manually resample the image
  if xdata_sz_pt * ydata_sz_pt gt 2e7 then begin
  
    self.statusBar->update,'Error: Cannot generate spectrogram. The range may be too small.'
    return
    
  endif
  
  ;clip planes will cut off the image at borders
  cp = double([[-1,0,0,0],[1,0,0,-1],[0,-1,0,0],[0,1,0,-1]])
  
  refvar = dblarr(xpanel_sz_pt,ypanel_sz_pt)
  refvar[*] = !VALUES.D_NAN
  
  ;if very small scaling factors are used,
  ;refvar will sometimes lose a dimension
  if size(refvar,/n_dim) eq 1 then begin
    refvar = reform(refvar,1,1)
  endif
  
  ;This routine contains the more general gridding algorithm, now that parameters have been determined definitively
  self->makeSpec,x,y,z,xdata_sz_pt,ydata_sz_pt,zAlpha=zAlpha,refz=refz
  
  plotData = { $
    data:refz,$
    alpha:zAlpha,$
    xstart:xstart,$
    ystart:ystart,$
    xsize:xsize,$
    ysize:ysize,$
    zstack:zstack, $
    zscale:zscale,$
    pixx:xdata_sz_pt,$
    pixy:ydata_sz_pt,$
    clip:cp $
    }
    
  ;This block performs necessary clipping, and fits the image into refvar
  
  ;determine indices of data in reference variable that
  ;represents the entire panel
  xStartIdx = floor(xstart*(size(refvar,/dimen))[0])
  xStopIdx = xStartIdx+xdata_sz_pt-1
  
  if xStopIdx lt 0 || xStartIdx ge xpanel_sz_pt then return
  
  ;clip left
  if xStartIdx lt 0 then begin
    refz = refz[abs(xStartIdx):*,*]
    xStartIdx = 0
  endif
  
  ;clip right
  if xStopIdx ge xpanel_sz_pt then begin
    refz = refz[0:xpanel_sz_pt-xStartIdx-1,*]
    xStopIdx = xpanel_sz_pt-1
  endif
  
  yStartIdx = floor(ystart*(size(refvar,/dimen))[1])
  yStopIdx = yStartIdx+ydata_sz_pt-1
  
  if yStopIdx lt 0 || yStartIdx ge ypanel_sz_pt then return
  
  ;clip bottom
  if yStartIdx lt 0 then begin
    refz = refz[*,abs(yStartIdx):*]
    yStartIdx = 0
  endif
  
  ;clip top
  if yStopIdx ge ypanel_sz_pt then begin
    refz = refz[*,0:ypanel_sz_pt-yStartIdx-1]
    yStopIdx = ypanel_sz_pt-1
  endif
  
  ;stick clipped data into panel sized reference var
  refvar[xStartIdx:xStopIdx,yStartIdx:yStopIdx] = refz
  
;  model = obj_new('IDLgrModel')
  
  ; if ~keyword_set(self.postscript) then begin
  ;if 1 then begin
  
  ;using a plain image doesn't layer correctly in postscript, consider generating layer code so that this option can replace polygon method
  ; imageObj = obj_new('IDLgrImage',image,location=[xstart,ystart,zstack],dimensions=[xsize,ysize],depth_test_disable=2,blend_function=[3,4])
 ; imageObj = obj_new('IDLgrImage',image)
  
;  polygon = obj_new('IDLgrPolygon', $
;    [[xstart,ystart,zstack],[xstart+xsize,ystart,zstack],[xstart+xsize,ystart+ysize,zstack],[xstart,ystart+ysize,zstack]], $
;    texture_map=imageObj,$
;    texture_coord=[[0,0],[1,0],[1,1],[0,1]], $
;    ;  texture_coord=[[0,1],[1,1],[1,0],[0,0]], $
;    color=self->convertColor([255,255,255]),$
;    shading=1,$
;    clip_planes=cp ) ;,$
;linestyle=6)
    
;endif else begin
    
;NOTE this code below has been worked around, by kludging layering issues during postscript output
;generate polygon vertices for every pixel.
;This is needed for postscript output
;
;
    
;The system I'm using is a polygon mesh, a regular arrangement of 4-gons
;The IDL documentation indicates that this is an optimized polygon
;arrangement and thus should be quicker.
;That said, we should consider generating complex n-gons for each
;contiguous colo region in future versions
    
;1d
;    x_verts = xstart + xsize* (dindgen(xdata_sz_pt+1)/xdata_sz_pt)
;
;    ;X 2d
;    x_verts = reform(rebin(x_verts,xdata_sz_pt+1,ydata_sz_pt+1),(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    ;1d
;    y_verts = ystart + ysize*(dindgen(ydata_sz_pt+1)/ydata_sz_pt)
;
;    ;Y 2d
;    y_verts = reform(transpose(rebin(y_verts,ydata_sz_pt+1,xdata_sz_pt+1)),(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    ;Z 2d
;    z_verts = replicate(zstack,(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    ;generate vertex permutations to define the polygons
;
;    ;vertex number per polygon
;    v_num = lonarr(xdata_sz_pt*ydata_sz_pt)+4 ;all polygons use 4 vertices
;
;    offset = lindgen(xdata_sz_pt*ydata_sz_pt)/xdata_sz_pt
;
;    ;the permutation for each vertex of each polygon
;    ;first vertex of each polygon
;    v1 = lindgen(xdata_sz_pt*ydata_sz_pt) + offset
;    ;second vertex of each polygon
;    v2 = lindgen(xdata_sz_pt*ydata_sz_pt) + 1 + offset
;    ;third vertex of each polygon
;    v3 = lindgen(xdata_sz_pt*ydata_sz_pt) + xdata_sz_pt + 1 + offset
;    ;fourth vertex of each polygon
;    v4 = lindgen(xdata_sz_pt*ydata_sz_pt) + xdata_sz_pt + 2 + offset
;
;    v_perm = transpose([[v_num],[v1],[v2],[v4],[v3]])
;
;    ;generate vertex colors of polygons
;
;    v_r_colors = bytarr((xdata_sz_pt+1),(ydata_sz_pt+1))
;    v_r_colors[0:xdata_sz_pt-1,0:ydata_sz_pt-1] = reform(image[0,*,*])
;    v_r_colors = reform(v_r_colors,(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    v_g_colors = bytarr((xdata_sz_pt+1),(ydata_sz_pt+1))
;    v_g_colors[0:xdata_sz_pt-1,0:ydata_sz_pt-1] = reform(image[1,*,*])
;    v_g_colors = reform(v_g_colors,(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    v_b_colors = bytarr((xdata_sz_pt+1),(ydata_sz_pt+1))
;    v_b_colors[0:xdata_sz_pt-1,0:ydata_sz_pt-1] = reform(image[2,*,*])
;    v_b_colors = reform(v_b_colors,(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;    v_a_colors = bytarr((xdata_sz_pt+1),(ydata_sz_pt+1))
;    v_a_colors[0:xdata_sz_pt-1,0:ydata_sz_pt-1] = reform(image[3,*,*])
;    v_a_colors = reform(v_a_colors,(xdata_sz_pt+1)*(ydata_sz_pt+1))
;
;
;    v_colors = transpose([[v_r_colors],[v_g_colors],[v_b_colors],[v_a_colors]])
;
;    polygon = obj_new('IDLgrPolygon',$
;                       x_verts,$
;                       y_verts,$
;                       z_verts,$
;                       vert_colors=v_colors,$
;                       shading=0,$
;                       style=2,$
;                       polygon=v_perm)
;
;  endelse
    
;print,systime(/seconds)-a
    
; return,polygon
    
    
end

;+
;Procedure: thm_ui_draw::getSpecModel
;
;Purpose:  This procedure finishes the creation of a spectral image.
;          It uses the newly calculated range and the information in plotdata
;
;Inputs: 
;  plotData(struct):  The plotData struct that was returned from getSpecRef, contains plotting information, like scaling, data position and clipping
;  zrange(2 element double):  The z range of the panel, after recalculating for closer autorange fit, if necessary.
;  palette(long): The number of the palette that will be used to draw this spectral plot
;Outputs:
;  model(IDLgrModel):  The model that the result is stored in.
;
;-
pro thm_ui_draw_object::getSpecModel,plotData,zrange,palette,model=model

  compile_opt idl2
  
  model = obj_new('IDLgrModel')
  
  pal = obj_new('IDLgrPalette')
  
  getctpath,ctpath
  
  pal->loadct,palette,file=ctpath
 
  pal->getProperty,red_values=rv,green_values=gv,blue_values=bv
  
  ;Turn refvar into a 4xMxN for each color channel
  out = reform(intarr(4,(*plotData).pixx,(*plotdata).pixy),4,(*plotData).pixx,(*plotdata).pixy)
  
  ;Identify values that should be transparent
  if (*plotData).zscale eq 1 ||  (*plotData).zscale eq 2 then begin
  
    idx = where(finite((*plotData).data,/infinity,sign=-1),c)
    
    if c gt 0 then begin
      (*plotData).alpha[idx] = 255
      (*plotData).data[idx] = zrange[0]
    endif
  
  endif
  
  zval = bytscl((*plotData).data,/nan,min=zrange[0],max=zrange[1])
  
  ;store appropriate color channels
  out[0,*,*] = rv[zval]
  out[1,*,*] = gv[zval]
  out[2,*,*] = bv[zval]
  out[3,*,*] = (*plotdata).alpha 

  out = reform(out,4,(*plotData).pixx,(*plotData).pixy)
  
  ;Generate image object
  imageObj = obj_new('IDLgrImage',out,$
    location=[(*plotData).xstart,(*plotData).ystart,(*plotData).zstack],$
    dimensions=[(*plotData).xsize,(*plotData).ysize],$
    depth_test_disable=2,$
    blend_function=[3,4])
  
  ;Map image object onto the surface of a polygon, as a texture map to allow precise control of position
  polygon = obj_new('IDLgrPolygon', $
    [[(*plotData).xstart,(*plotData).ystart,(*plotData).zstack],$
    [(*plotData).xstart+(*plotData).xsize,(*plotData).ystart,(*plotData).zstack],$
    [(*plotData).xstart+(*plotData).xsize,(*plotData).ystart+(*plotData).ysize,(*plotData).zstack],$
    [(*plotData).xstart,(*plotData).ystart+(*plotData).ysize,(*plotData).zstack]], $
    texture_map=imageObj,$
    texture_coord=[[0,0],[1,0],[1,1],[0,1]], $
    ;  texture_coord=[[0,1],[1,1],[1,0],[0,0]], $
    color=self->convertColor([255,255,255]),$
    shading=1,$
    clip_planes=(*plotData).clip,$
    /double ) 
    
  model->add,polygon

end

;+
;
; Function: thm_ui_draw::makeSpec
;
;Purpose:
;  helper routine for draw object.  It helps construct the image for spectrograms
;  very quickly.
;
;Inputs:
;  x: the 1-d x scaling values for the z components(x-axis)
;  y: the 1-d y scaling values for the z components
;  z: the 2-d z array of values for the image
;  pixx: the desired resolution of the output on the x-axis
;  pixy: the desired resolution of the output on the y-axis
;
;Output:
;   refz: The gridded z-axis array
;   refx: The x-values associated with the z-values
;   refy: The y-values associated with the z-values
;   
;   Notes:
;   1. This uses an alpha channel to make all NaNs transparent.
;   2. PixX and PixY are not totally necessary because object graphics can
;      stretch an image quite well, but selecting the resolution of the screen
;      with them prevents any inadvertent errors from showing up during interpolation.
;      It might actually be better to render the image at twice the screen resolution
;      to prevent aliasing errors.
;   
;$LastChangedBy: pcruce $
;$LastChangedDate: 2010-03-03 12:08:53 -0800 (Wed, 03 Mar 2010) $
;$LastChangedRevision: 7393 $
;$URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/thmsoc/tags/tdas_5_21/idl/themis/thm_ui_new/display/thm_ui_draw_object__define.pro $
;-

pro thm_ui_draw_object::makeSpec,x,y,z,pixx,pixy,zAlpha=zAlpha,refz=refz,refx=refx,refy=refy

  compile_opt idl2
  
  ;note, interpolation doesn't handle missing data quite correctly yet
  do_interp = 0
  
;  pal = obj_new('IDLgrPalette')
;  
;  getctpath,ctpath
;  
;  pal->loadct,palette,file=ctpath

  ;double check that data is valid
  idx = where(finite(y),c)
  
  if c eq 0 then begin
    self.statusBar->update,'Error: Unexpected invalid quantity'
    self.historyWin->update,'Error: Unexpected invalid quantity'
    return
  endif

  ;special case 1d Z
  if ndimen(reform(z)) eq 1 then begin
  
    if n_elements(y) eq 1 && n_elements(x) eq 1 then begin
      ;nothin can be done with one-and-ones
      return
    endif else if n_elements(y) eq 1 then begin
    
      ;refy = [0]
      dim = n_elements(z)
      xn = dim
      
      xi = (x - x[0])/(x[xn-1]-x[0]) 
      refx = dindgen(pixx)/pixx
      
      refz = interpol(z,xi,refx) # replicate(1.,pixy)
      
      refy = replicate(y,pixy)
      
    endif else if n_elements(x) eq 1 then begin
    
      ;refy = [0]
      dim = n_elements(z)
      yn = dim
      
      yi = (y - y[0])/(y[yn-1]-y[0]) 
      refy = dindgen(pixy)/pixy
      
      refz = replicate(1.,pixx) # interpol(z,yi,refy)
      
      refx = replicate(x,pixx)
    
    endif else begin
      return
    endelse
    
  ;  zout = bytscl(refz,/nan,min=zrange[0],max=zrange[1])
    
    zalpha = bytarr(pixx,pixy)
    
    idx = where(finite(refz),c)
    
    if c ne 0 then begin
      zalpha[idx] = 255
    endif
      
  ;1d y draw code
  endif else if ndimen(y) eq 1 then begin
    y = y[idx]
    z = z[*,idx]
  
    dim = dimen(z)
    
    xn = dim[0]
    yn = dim[1]
    
    alpha = dblarr(dim) + 255
    
    idx = where(~finite(z),c)
    
    if c ne 0 then alpha[idx] = 0
    
    ;sorting should maybe be dumped.
    ;it is really a preprocessing task
    idx = bsort(y)
    
    y = y[idx]
    alpha = alpha[*,idx]
    z = z[*,idx]
    
    idx = bsort(x)
    
    x = x[idx]
    alpha = alpha[idx,*]
    z = z[idx,*]
    
    xi = (x - x[0])/(x[xn-1]-x[0]) 
    xo = dindgen(pixx)/(pixx-1)
     
    if xn le 1 then begin
      xin_vals = [0,1]
    endif else begin
      xin_vals = dindgen(xn)
    endelse
    
    idx = where(finite(xi),c)
     
    if c eq 0 then begin
      self.statusbar->update,'Warning: No valid x scaling data found.  Using proportional scaling.'
      self.historywin->update,'Warning: No valid x scaling data found.  Using proportional scaling.'
      refx = interpol(xin_vals,pixx)
    endif else begin
      refx = interpol(xin_vals,xi,xo)
    endelse
    
    if ~keyword_set(do_interp) then begin
      xpos = round(refx)
    endif else begin
      xpos = refx
    endelse
    
    ;because nans may be present, cannot use index to find min and max,
    ;despite sort
    miny = min(y,/nan)
    maxy = max(y,/nan)
    
    yi = (y - miny)/(maxy-miny)
    yo = dindgen(pixy)/(pixy-1)
    
    if yn le 1 then begin
      yin_vals = [0,1]
    endif else begin
      yin_vals = dindgen(yn)
    endelse
    
    idx = where(finite(yi),c)
     
    if c eq 0 then begin
      self.statusbar->update,'Warning: No valid y scaling data found. Using proportional scaling.'
      self.historywin->update,'Warning: No valid y scaling data found. Using proportional scaling.'
      refy = interpol(yin_vals,pixy)
    endif else begin
      refy = interpol(yin_vals,yi,yo)
    endelse
  
    if ~keyword_set(do_interp) then begin
      ypos = round(refy)
    endif else begin
      ypos = refy
    endelse
    
    refz = interpolate(z,xpos,ypos,/grid,missing=!VALUES.D_NAN)
  ;  zout = bytscl(refz,/nan,min=zrange[0],max=zrange[1])
    
    zalpha = interpolate(alpha,xpos,ypos,/grid,missing=0)
    
  endif else begin
  ;2d y code

    dim = dimen(z)
    
    minx = min(x,/nan)
    maxx = max(x,/nan)
    
    miny = min(y,/nan)
    maxy = max(y,/nan)
    
    ;normalized inputs
    xi = (temporary(x) - minx)/(maxx - minx)
    yi = (temporary(y) - miny)/(maxy - miny)
    
    ;normalized x output
    xo = dindgen(pixx)/pixx
     
    ;index-wise scaling value
    refx = interpol(dindgen(dim[0]),temporary(xi),temporary(xo))
    
    ;rounded to prevent smoothing of the data
    if ~keyword_set(do_interp) then begin
      xpos = round(refx)
    endif else begin
      xpos = refx
    endelse  

  ;  xpos = refx
    
    ;now make it 2d
    xpos = xpos # replicate(1.,pixy)
  
    ;normalized y output
    yo = dindgen(pixy)/pixy
  
    ;allocate storage for index-wise scaling value
    refy = dblarr(pixx,pixy)
  
    ;now sample y values along x-axis
    ;note that this technique is subject to potential aliasing errors
    ;unless pixx, is twice the width of the plotting error in pixels
    ;this can be controlled by changing the self.specres value
    for i = 0,pixx-1 do begin
      ;calculate the index of this sample
      j = (xpos[i,0] > 0) < (dim[0]-1)
      y_sample = reform(yi[j,*])
      refy[i,*] = interp(dindgen(dim[1]),y_sample,yo) 
    endfor
  
    ;use an out of range value for non-in-range values
    ;these should have already been cleared in the case of the x-axis
    idx = where(~finite(refy),c)
    
    if c ne 0 then begin
      refy[idx] = -1
    endif
    
    ;now make sure we have only exact indexes
    if ~keyword_set(do_interp) then begin
      ypos = round(refy)
    endif else begin
      ypos = refy
    endelse      
    
    refz = interpolate(z,xpos,ypos,missing=!VALUES.D_NAN)
   ; zout = bytscl(refz,/nan,min=zrange[0],max=zrange[1])
    zalpha = bytarr(pixx,pixy)
    
    idx = where(finite(refz),c)
    
    if c ne 0 then begin
      zalpha[idx] = 255
    endif
  
  endelse
  
;  pal->getProperty,red_values=rv,green_values=gv,blue_values=bv
;  
; ; catch,err
;  
;  ;here to catch potential memory overallocation
; ; if err then begin
; ;   stop
; ; endif else begin
;  out = intarr(4,pixx,pixy)
; ; endelse
;  ;catch,/cancel
;  
;  out = reform(out,4,pixx,pixy)
;  
;  out[0,*,*] = rv[zout]
;  out[1,*,*] = gv[zout]
;  out[2,*,*] = bv[zout]
;  out[3,*,*] = zalpha
;   
;  ;grid the points and scale them into the range of color indices
;  ;return, floor(interpolate(z,xpos,ypos,/grid))
;  image=out
;  
;  ;IDL will remove any 1 element dimensions on this assignment
;  ;this fixes the problem
;  image = reform(image,4,pixx,pixy)

end


;A special kluge function to get around an IDL bug, that causes improper layering in eps
;Generates a composite image from a series of spectral plots to preserve layering when exporting to eps
;
;Inputs: 
;  spec_list(Object Ref): an IDL_Container with each spec_plot model
;  panel_sz_pt(2 element numerical):  The number of points to be used for the x and y dimensions of the output, respectively
;  bg_color(3 element byte array):  The background color for the panel, used to properly simulate transparency
;  
;Outputs:
;  aggregated model
;
function thm_ui_draw_object::aggregateSpecplots,spec_list,panel_sz_pt,bg_color

  compile_opt idl2
  
  zstack = .05
  
  ;clip planes will cut off the image at borders
  cp = double([[-1,0,0,0],[1,0,0,-1],[0,-1,0,0],[0,1,0,-1]])
  
  ;create a dummy view
  view = obj_new('IDLgrView',units=3, $
    VIEWPLANE_RECT=[0.,0.,1.,1.], $
    zclip=[1,-1], eye=5.,color=bg_color,$
    /double)
    
  model_list = spec_list->get(/all)
  
  ;add specplot models to the view 
  for i = 0,n_elements(model_list)-1 do begin
  
    view->add,model_list[i]
    
  endfor

  ;create a buffer and draw models on the view  
  buffer = obj_new('IDLgrBuffer',dimensions=panel_sz_pt)
  
  buffer->draw,view
  
  ;get the image data from the buffer after draw
  buffer->getProperty,image_data=image_data
  
  ;create a new composite image, using the output
  image = obj_new('IDLgrImage',image_data,depth_test_disable=2,clip_planes=cp,location=[0.,0.,zstack],dimensions=[1.,1.])
  
  model = obj_new('IDLgrModel')
  
  model->add,image
  
  return,model
end

;This function generates the line plot for an update
;There is actually a lot of room to increase draw speed
;by optimizing this function.  In specific we need to find
;a way to downsample a line plot, but the technique must work
;on series that are not functional(ex: circle), must not sort
;the inputs, must be imperceptible, must be fast, and must not
;expect the inputs to be spaced uniformly.  Some possibilities:
;1: uniform decimation
;2: pseudo-random decimation
;3: using pythagorean distance to rewrite non-functional series as functional series
;   then interpolate
;4: DFT with frequency cutoff, iDFT, uniform sample?
;
;Another problem involves determining the correct number of points to
;which the target should be decimated. There is a tradeoff where at one
;end you start to introduce aliasing errors and at the other end you get
;a speed slowdown.
;
;Currently the system uses the some constant factor times the number of pixels
;across the plot as the target decimation and it only decimates inputs that have
;time as the x-axis(which can be assumed to be functional).  These can be reliably
;decimated using normal interpolation.
;
;Inputs:
;  trace(object reference): the thm_ui_line_settings of the trace being generated
;  xrange(2 element double): The xrange of the panel being draw on
;  yrange(2 element double): The yrange of the panel being draw on
;  plotdim1(2 element double): The normalized position of the panel(start,stop), relative to window for x-axis
;  plotdim2(2 element double): The normalized position of the panel(start,stop), relative to window for y-axis
;  xscaling(long) : the scaling mode for x-axis 0(linear),1(log10),2(logN)
;  yscaling(long) : the scaling mode for y-axis 0(linear),1(log10),2(logN)
;  xAxisMajors(double array, variable length):  The positions of the x-axis ticks, normalized relative to panel(need for drawing symbols)
;  dx(ptr to array) : the x axis data being plotted
;  dy(ptr to array) : the y axis data being plotted
;  xistime(boolean):  1 if the x-axis is a time type, 0 other wise
;  mirrorptr(ptr to array,optional) the ptr to the mirror data(will deallocate mirrorptr data)
;Outputs: 
;  linecolor(3 element bytarr):  The color of the line that was drawn
;  refVar(ptr to array): the ptr to reference for use in legend
;  abcissa_out(ptr to array): ptr to abcissa values associated with reference, this feature is not currently in use, as refVar is gridded to pixel resolution, and pixel indexes are used
;
;Returns:
;  model with completed line plot
;
function thm_ui_draw_object::getLinePlot,trace,xrange,yrange,plotdim1,plotdim2,xscaling,yscaling,xAxisMajors,dx,dy,xistime,mirrorptr=mirrorptr,linecolor=linecolor,refvar=refvar,abcissa=abcissa_out

  compile_opt idl2
  
  zstack = .2
  
  model = obj_new('IDLgrModel')
  
  trace->getProperty,$
    dataX=dataX,$
    dataY=dataY,$
    lineStyle=lineStyle,$
    drawBetweenPts=drawBetweenPts,$
    mirrorLine=mirrorLine,$
    symbol=symbol,$
    plotpoints=plotpoints,$
    everyother=everyother,$
    positiveEndPt=positiveEndPt,$ ;error bars not yet implemented
    negativeEndPt=negativeEndPt,$
    positiveEndRel=positiveEndRel,$
    negativeEndRel=negativeEndRel,$
    barLine=barLine,$
    markSymbol=markSymbol
    
  lineStyle->getProperty,$
    id=id,$
    show=show,$
    color=color,$
    thickness=thick
    
  linecolor=color
  
  ;Make sure output from previous iteration does not iterfere
  if size(refVar,/type) then begin
    undefine,refvar
  endif
  
  if size(abcissa_out,/type) then begin
    undefine,abcissa_out
  endif
  
  ;number of pixels across the panel * res_factor = number of points in lookup
  linedim = self->getPlotSize(plotdim1,plotdim2,self.lineres)
  xpx = linedim[0]
  
  ;0 width range and plot can't be generated
  if xrange[1] - xrange[0] eq 0 then return,model
  
  if yrange[1] - yrange[0] eq 0 then return,model
  
  ;extract data, and eliminate previous copy
  x = temporary(*dx)
  y = temporary(*dy)
  
  if mirrorline then mirror = temporary(*mirrorptr)
  
  ;need at least two points to do separation check.
  if keyword_set(drawBetweenPts) && n_elements(x) gt 1 then begin
  
    ;determine the minimum amount of space that is allowed between points before we draw a gap.
    separation = trace->getPtSpacing()
    
    idx = where(abs((x[1:n_elements(x)-1]-x[0:n_elements(x)-2])) gt separation)
    
    ;These values should probably be inserted rather than replaced.
    if idx[0] ne -1 then begin
      y[idx] = !VALUES.D_NAN
    
      if keyword_set(mirrorline) then begin
        mirror[idx] = !VALUES.D_NAN
      endif
    endif 
    
  endif
  
  ;normalize x values relative to panel
  x = (x - xrange[0])/(xrange[1]-xrange[0])
  
  ;This generates the line reference
  self->makeLineReference,x,y,xpx,ref=refvar
  
  ;normalize the y values relative to the panel
  y = (y - yrange[0])/(yrange[1]-yrange[0]) 
  
  ;perform decimation on postscript plot
  if self.postscript && self.fancompressionfactor gt 0 then begin
      
    yratio = linedim[1]/linedim[0]  
  
    ;compress for postscript, object graphic postscript exporter doesn't compress
    ;For details on compression algorithm, see header for fancompress.pro 
    outidx = fancompress([[x],[y/yratio]],self.fancompressionfactor,/vector)
 
    x = x[outidx]
    y = y[outidx]
  
  endif
    
  if keyword_set(mirrorLine) then begin

    ;normalize mirror values
    mirrorvar = (temporary(mirror) - yrange[0])/(yrange[1]-yrange[0])
    
    ;generate mirror plot
    plot = obj_new('IDLgrPlot',x,mirrorvar,color=self->convertColor(color),linestyle=id,hide=~show,thick=thick,xrange=[0D,1D],yrange=[0D,1D],zvalue=zstack,/use_zvalue,/double)
    model->add,plot
    
  endif
  
  ;generate main line plot
  plot = obj_new('IDLgrPlot',x,y,color=self->convertColor(color),linestyle=id,hide=~show,thick=thick,xrange=[0D,1D],yrange=[0D,1D],zvalue=zstack,/use_zvalue,/double)
  
  model->add,plot
  
  n = n_elements(x)
  
  ;determine symbol positions depending on the option selected
  if plotpoints eq 1 then begin
    x_sym = [x[0],x[n-1]]
    y_sym = [y[0],y[n-1]]
  endif else if plotpoints eq 2 then begin
    x_sym = [x[0]]
    y_sym = [y[0]]
  endif else if plotpoints eq 3 then begin
    x_sym = [x[n-1]]
    y_sym = [y[n-1]]
  endif else if plotpoints eq 4 then begin
  
    ;majors is a little trickier, we have to loop over majors
    if n_elements(xAxisMajors) gt 1 then begin
      for i = 1,n_elements(xAxisMajors)-1 do begin
      
        t = min(abs(x-xAxisMajors[i]),idx)
        if t lt .01D then begin ;only add symbol if it is close to an actual value
          if n_elements(idx_l) eq 0 then begin
            idx_l = [idx]
          endif else begin
            idx_l = [idx_l,idx]
          endelse
        endif
        
      endfor
    endif
    
    if n_elements(idx_l) gt 0 then begin
      x_sym = x[idx_l]
      y_sym = y[idx_l]
    endif
    
  endif else if plotpoints eq 5 then begin
  
    if everyother gt 0 && everyother lt n then begin
    
      ;note that the (n mod everyother) statement is in place to prevent a 0 length lindgen
      ;It may no longer be necessary now that the draw object inputs are better error checked
      x_sym = x[lindgen(((n mod everyOther)ne 0)+n/everyOther)*everyOther]
      y_sym = y[lindgen(((n mod everyOther)ne 0)+n/everyOther)*everyOther]
    ;  x_sym = x[lindgen(n/everyOther)*everyOther]
    ;  y_sym = y[lindgen(n/everyOther)*everyOther]
      
    endif
  endif else begin
    x_sym = temporary(x)
    y_sym = temporary(y)
  endelse
  
  ;symbol plots
  
  ;note that symbol fill is not yet implmented
  
  ;now generate symbol plot from symbol settings
  symbol->getProperty,id=id,show=show,color=color,fill=fill,size=size
  
  if show && size(x_sym,/type) && size(y_sym,/type) then begin
  
    ;the size appears to be double the size in points that it should be.
    ;This modification scales the symbol size down
    xsize = .5*self->pt2norm(size,0)/(plotdim1[1]-plotdim1[0])
    ysize = .5*self->pt2norm(size,1)/(plotdim2[1]-plotdim2[0])
    
    grSymbol = obj_new('IDLgrSymbol',id,color=self->convertColor(color),size=[xsize,ysize])
    
    plot = obj_new('IDLgrPlot',x_sym,y_sym,color=self->convertColor(color),linestyle=6, $
      xrange=[0D,1D],yrange=[0D,1D], zvalue=zstack+.01,symbol=grsymbol,/use_zvalue,/double)
      
    model->add,plot
    
  endif
  
  ;returning the final model
  return,model
  
end

;This routine performs some of the tricky logic 
;necessary to figure out how to place the axis labels
;
;model: the output model
;labels: IDL_Container storing labels
;margin: margin between axis & labels
;placeAnnotation: whether to place annotation on top/bottom left/right
;dir: x/y axis flag
;orientation: horizontal/vertical text flag
;stackLabels: stacklabels or rowlabels flag
;pt1: multiplicand to change pt into view normalized coords(perp axis)
;pt2: multiplicand to change pt into view normalized coords(par axis)
;labelpos: returns the position of the most distant label from the axis
;blacklabels: indicates that default settings should be over-ridden to make all labels black
pro thm_ui_draw_object::addAxisLabels,model,labels,margin,placeAnnotation,dir,orientation,stacklabels,showlabels,pt1,pt2,blacklabels,labelPos=labelPos

  compile_opt idl2
  
  ;not completely sure about what z-values
  ;each component will need, so I set it at
  ;the top
  zstack = .1
  
  labelpos = 0
  
  ;validate input
  if ~showlabels || ~obj_valid(labels) || ~obj_isa(labels,'IDL_Container') then return
  
  objs = labels->get(/all)
  
  if ~obj_valid(objs[0]) then return
  
  ;This switch simplifies the code significantly by
  ;making the x/y axis code symmetrical.
  ;Think of orient as indicating whether the text is
  ;oriented parallel or perpedicular to the axis
  if dir eq 1 then begin
    orient = ~orientation
  endif else begin
    orient = orientation
  endelse
  
  ;the baseline & updir options are used by
  ;IDL to determine text orientation in 3-d space
  ;(although we are only looking at a planar subset
  if orientation eq 0 then begin
    baseline = [1,0,0]
    updir = [0,1,0]
  endif else begin
    baseline = [0,1,0]
    updir = [-1,0,0]
  endelse
  
  ;logic to control label alignment
  ;ie top/bottom/left/right justify
  if orient eq 0 then begin
    parAlign = .5
    perAlign = .5
  endif else begin
    perAlign = .5
    if placeAnnotation eq 0 then begin
      parAlign = 1.0
    endif else begin
      parAlign = 0.0
    endelse
  endelse
  
  halign = parAlign
  valign = perAlign
  
  len = 0D
  
  n = n_elements(objs)
  
  ;get the length of the labels as a block so that the
  ;labels can be positioned properly
  ;we loop over labels and sum their sizes or lengths. Which depends on stacking & orientation.
  for i = 0,n-1 do begin
  
    objs[i]->getProperty,value=value,size=size,show=show
    
    if ~show then continue
    
    size += 1
    
    if orient eq 0 then begin
      if stacklabels eq 0 then begin
        len += strlen(value)*pt2*size
      endif else begin
        len += pt1*size
      endelse
    endif else begin
      if stacklabels eq 0 then begin
        len += strlen(value)*pt1*size
      endif else begin
        len += pt2*size
      endelse
    endelse
  ;need to correct to account for varying orientations/pt1/pt2
    
  endfor
  
  pos = 0D
  
  ;Now loop over label objects and actually generate the output IDLgrText
  ;for each label in the block
  for i = 0, n-1 do begin
  
    tFont = objs[i]->getGrFont()
    
    objs[i]->getProperty,color=color,value=value,show=show,size=size
    
    if size le 0 then begin
      self.statusBar->update,'Label "' + value + '" had illegal size. Skipping...'
      self.historyWin->update,'Label "' + value + '" had illegal size. Skipping...'
      continue
    endif
    
    if ~show then continue
    
    tFont->setProperty,size=size*self->getZoom()
    
    size +=1
    
    ;this code calculates position for labels of different locations/orientations
    ;It allows for the fonts of labels to be different
    if stackLabels eq 0 then begin
      if orient eq 0 then begin
        loc1 = (size*strlen(value))/(len/pt2*2D) + pos
        loc2 = -(margin*pt1+size*pt1/2D)
        pos += double(size*strlen(value))/double(len/pt2)
      endif else begin
        loc1 = .5D
        loc2 = -(margin*pt1+pos)
        pos += size*strlen(value)*pt1
      endelse
    endif else begin
    
      if orient eq 0 then begin
        loc1 = .5D
        loc2 = -(margin*pt1+pos+size*pt1/2D)
        pos += pt1*(size)
      ; pos += pt1*size
      endif else begin
        loc1 = (.5D)-(len/2D)+(size*pt2)/2D + pos
        loc2 = -(margin*pt1)
        pos += pt2*(size)
      endelse
      
      if dir eq 1 then begin
        if orient eq 1 then begin
          loc1 = 1. - loc1
        endif else begin
          loc2 = -loc2 - len - 2*(pt1*margin)
        endelse
      endif
    endelse
    
    if placeAnnotation eq 1 then begin
      loc2 = 1 - loc2
    endif
    
    if dir eq 1 then begin
      loc = [loc2,loc1,zstack]
      labelPos = loc1
    endif else begin
      loc = [loc1,loc2,zstack]
      labelPos = loc2
    endelse
   
    if keyword_set(blacklabels) then begin
      color = [0,0,0]
    endif 
   
    grText = obj_new('IDLgrText',value,$
      font=tFont,$
      color=self->convertColor(color),$
      hide=~show,$
      location=loc,$
      alignment=hAlign,$
      vertical_alignment=valign,$
      baseline=baseline,$
      recompute_dimensions=0,$
      updir=updir)
      
    model->add,grText
    
  end
  
end

;adds the dateString annotation to the axis
;
;Inputs:
;  view(object reference): The IDLgrView to which the string will be added.
;  axisSettings(object reference):  the thm_ui_axis_settings where the associated settings are stored
;  range(2-element double): The start and stop range for the panel
;  scaling(long):  Indicates the scaling used 0(linear),1(log10),2(logN)
;  xplotsize: The length of the x-axis of the panel in normalized coordinates
;  yplotsize: The length of the y-axis of the panel in normalized coordinates
;  labelMargin:  The distance between the variable labels and the y-axis. This
;                parameter is also used to position the dateString, in lieu of a more specific parameter
;
pro thm_ui_draw_object::addDateString,view,axisSettings,range,scaling,xplotsize,yplotsize,labelmargin

  compile_opt idl2
  
  axisSettings->getProperty,$
    showDate=showDate,$
    datestring1=datestring1,$
    datestring2=datestring2,$
    placeannotation=placeannotation,$
  ;  scaling=scaling,$
    annotateTextObject=annotateTextObject,$
    tickStyle=tickStyle,$
    bottomPlacement=bottomPlacement,$
    topPlacement=topPlacement,$
    majorLength=majorLength,$
    minorLength=minorLength,$
    isTimeAxis=isTimeAxis
    
  ; view->getProperty,viewPlane_rect=viewPlane_rect
    
  if ~showDate then begin
    return
  endif
  
  if ~isTimeAxis then begin
    return
  endif
  
  ;format the date strings, according to the splash-based format codes
  string1 = formatdate(range[0],datestring1,scaling)
  string2 = formatdate(range[0],datestring2,scaling)
  
  ;Copy the text objects so we can mutate them
  string1Obj = annotateTextObject->copy()
  string2Obj = annotateTextObject->copy()
  
  string1Obj->getProperty,size=size
  
  ;Turn this measure into a panel normal size
  textSizeNorm = self->pt2norm(size,1)/yplotsize
  
  posoffset = textSizeNorm
  
  ;account for tick position when calculating offset for date string
  if tickStyle eq 1 || tickStyle eq 2 then begin
    if (~placeAnnotation && bottomPlacement) || $
      (placeAnnotation && topPlacement) then begin
      posoffset += (self->pt2norm(majorLength > minorLength,1)/yplotsize)
    endif
  endif
  
  xposoffset = -self->pt2norm(labelmargin,0)/xplotsize
  
  string1Obj->setProperty,value=string1
  string2Obj->setProperty,value=string2
  
  ;determine if string goes on top or bottom
  if placeAnnotation then begin
    ; location = [viewPlane_rect[0]/2.,1. + (viewPlane_rect[3]-1+viewPlane_rect[1])/4.,.1]
    location = [xposoffset,1.+posoffset,.1]
  endif else begin
    ;location = [viewPlane_rect[0]/2.,viewPlane_rect[1]/4.,.1]
    location = [xposoffset,0.-posoffset,.1]
  endelse
  
  ;generate text models and add them
  model1 = self->getTextModel(string1Obj,location,1.,0.,justify=1)
  model2 = self->getTextModel(string2Obj,location,-1.,0.,justify=1)
  
  view->add,model1
  view->add,model2
  
end

;Adds the main page background to the target view
;
;view(object reference): IDLgrView to which the background is being added
;color(3 element byte array):  The color of the background.
pro thm_ui_draw_object::addBackground,view,color

  compile_opt idl2
  
  ;the lowest object in the layering
  zstack=0.0
  
  ;a simple polygon.
  grBackground = obj_new('IDLgrPolygon',[0,1,1,0], $
    [0,0,1,1], $
    [zstack,zstack,zstack,zstack],$
    color=self->convertColor(color),$
    /double)
    
  grBModel = obj_new('IDLgrModel')
  
  grBModel->add,grBackground
  
  view->add,grBModel
  
end

;creates the views for a panel,
;incorporates all the layout information 
;that can effect this.
;
;Inputs:
;  dims(2 element long) : The number of rows and columns in the overall layout
;  margins(6 element double):  [leftMargin,rightMargin,topMargin,bottomMargin,horizontalMargin,verticalMargin] in draw-area normalized coordinates
;  pos(4 element long):  [row,col,rowSpan,colSpan] of the panel being drawn.
;  pcoord(4 element double): User defined explicit panel position, in draw-area normalized coords: [xpos,ypos,xsize,ysize], if unused, will be -1 
;  markernum(long): The number of markers in the panel.  Each marker is in a different view, so a number of markerviews equal to markernum will be returned
;  varsizes(double array): The varsize that is occupied by each row in the layout
;Outputs:
;  view(object reference):  The static panel IDLgrView
;  annotation(object reference):  The panel IDLgrView for dynamic display elements(ie annotations etc.. that are being updated)
;  markers(array of object references):  Array of IDLgrViews for each marker.  Each marker ends up needing to be put in separate views,
;                                      to guarantee proper layering.
;  xplotpos(2 element double):  The determined x-position of panel in draw-area normalized coordinates [xstart,xstop]
;  yplotpos(2 element double):  The determined y-position of panel in draw-area normalized coordinates [ystart,ystop] 
;  fail(boolean):  Will be 1 if operation fails, 0 otherwise
;  outmargins(5 element double) :  Indicates the size of the various panel regions in draw-normalized coordinates, so that cursor clicks can be properly resolved. [left,right,top,bottom,var]
;                                         
pro thm_ui_draw_object::makeView,dims,margins,pos,pcoord,markernum,varsizes,view=view,annotation=annotation,markers=markers,xplotpos=xplotpos,yplotpos=yplotpos,fail=fail,outmargins=outmargins

  compile_opt idl2
  
  ;  margins = margins_in
  ;  margins[2] = margins_in[3]
  ;  margins[3] = margins_in[2]
  
  dims = double(dims)
  margins = double(margins)
  pos = double(pos)
  pcoord = double(pcoord)
  
  totalVarSize = total(varsizes)
  
  currentVarSize = varsizes[pos[0]+pos[2]-2]
  
  if pos[0]+pos[2] - 2 eq 0 then begin
    cumulvarsize = totalVarSize - 0
  endif else begin
    cumulvarSize = totalVarSize - total(varsizes[0:pos[0]+pos[2]-3])
  endelse
  
  ;outmargins indicate the range in normalized device coordinates to
  ;be considered part of the region(this is used for identifying context sensitive clicks)
  outmargins = dblarr(5) ; [left,right,top,bottom,var]
  
  fail = 1
  
  ;calculate the amount of space the whole panel will occupy(including margins)
  xused = margins[0] + margins[1] + (dims[1]-1) * margins[4]
  xsize = (1.-xused)/dims[1]
  
  yused = margins[3] + margins[2] + (dims[0]-1) * margins[5] + totalvarsize
  ysize = (1. - yused)/dims[0]
  
  if xsize lt 0 then begin
    self.statusBar->update,'Error: XMargins/Horizontal PanelSpacing too large. No room available for panels'
    self.historyWin->update,'Error: XMargins/Horinzontal PanelSpacing too large.  No room for panels'
    ; ok = error_message('XMargins/PanelSpacing too large.  No room for panels')
    return
    
  endif
  
  if ysize lt 0 then begin
    self.statusBar->update,'Error: YMargins/Vertical PanelSpacing too large.  No room for panels'
    self.historyWin->update,'Error: YMargins/Vertical PanelSpacing too large.  No room for panels'
    ;ok = error_message('YMargins/PanelSpacing too large.  No room for panels')
    return
    
  endif
  
  ;This calculates the position and length of the view within the window
  ;It also calculates the viewplane rectangle.  This can be thought of as
  ;the coordinate system local to objects placed inside the view.
  ;It is set up so that the plot itself ranges from 0 to 1,  any
  ;margins are outside of that range
  
  ;x size of the plot in normalized coordinates
  ;this accounts for colspan & any margins
  xplot_size = xsize*pos[3] + margins[4]*(pos[3]-1)
  
  ;calculate
  ;1. X size/location of view
  ;2. X size of viewplane_rect
  ;3. X Start & Stop of Plot in normalized window coordinates
  
  xpos = 0.
  xlen = 1.
  
  ;Since different margins apply depending on panel location, we need to have a special case for 
  ;each panel, depending on whether it is on the edge or in the middle of the panel
  if pos[1] eq 1 && pos[1] + pos[3] - 1 eq dims[1] then begin ;leftmost & rightmost panel
  
    xstart = margins[0]
    outmargins[0] = margins[0]/2D
    outmargins[1] = margins[1]/2D
    
  endif else if pos[1] eq 1 then begin  ;leftmost panel
  
    xstart = margins[0]
    
    outmargins[0] = margins[0]/2D
    outmargins[1] = margins[4]/2D
    
  endif else if pos[1] + pos[3] - 1 eq dims[1] then begin ;rightmost panel
  
    xstart = 1. - margins[1] - xplot_size
    
    outmargins[0] = margins[4]/2D
    outmargins[1] = margins[1]/2D
    
  endif else begin  ;neither left nor right
  
    xstart = margins[0] + (xsize+margins[4])*(pos[1]-1.)
    
    outmargins[0] = margins[4]/2D
    outmargins[1] = margins[4]/2D
    
  endelse
  
  ;handle explicit positioning by user
  ;If the user requested a position override defaults
  if pcoord[0] ne -1 then begin
    xstart = pcoord[0]
  endif
  
  if pcoord[2] ne -1 then begin
    xplot_size = pcoord[2]
    if xplot_size eq 0 then begin
    
      self.statusBar->update,'0 width panel cannot be created'
      self.historyWin->update,'0 width panel cannot be created'
      return
    endif
  endif
  
  xstop = xstart + xplot_size
  viewXpos = -(xstart / xplot_size)
  viewXlen = 1. / xplot_size
  
  ;dims = [rownum,colnum]
  ;margins = [left,right,top,bottom,xSpacing,ySpacing] in normalzied
  ;coords
  ;pos = [row,col,rowSpan,colSpan]
  
  ;this layout naturally orders from bottom to top
  ;the line below reverses the ordering of the rows.
  ;so that it orders from top to bottom
  pos[0] = dims[0] - pos[0] + 1
  
  ;Y size of the plot in normalized coordinates
  ;this accounts for rowspan & any interior margins
  ;(interior margins from multiple row span)
  yplot_size = ysize*pos[2] + margins[5]*(pos[2]-1)
  
  ;because rows count in the opposite direction of coordinate system,
  ;the position needs to be shifted down when a panel spans multiple
  ;rows.  This way adding span appears to increase panel size in the
  ;direction of increasing rows.
  pos[0] = pos[0] - (pos[2] - 1)
  
  ;calculate:
  ;1.  Y size/location of view
  ;2. Y dimensions of viewplane_rect
  ;3. Y Start & Stop of the plot in normalized coordinates
  
  ypos = 0.
  ylen = 1.
   
  ;Since different margins apply depending on panel location, we need to have a special case for 
  ;each panel, depending on whether it is on the edge or in the middle of the panel
  if pos[0] eq 1 && pos[0] + pos[2] - 1 eq dims[0] then begin ;case 1: 1 row layout
  
    ystart = margins[2] + currentvarsize
    
    outmargins[2] = margins[2]/2D
    outmargins[3] = margins[3]/2D
    
  endif else if pos[0] eq 1 then begin ;case 2: bottom row in layout
  
    ystart = margins[3] + currentvarsize
    
    outmargins[2] = margins[5]/2D
    outmargins[3] = margins[3]/2D
    
  endif else if pos[0] + pos[2] - 1 eq dims[0] then begin ;case 3: top row in layout
  
    ystart = 1. - (margins[2] + yplot_size)
    
    outmargins[2] = margins[2]/2D
    outmargins[3] = margins[5]/2D
    
  endif else begin  ;case 4, somewhere in the middle of layout
  
    ystart = margins[3] + (ysize+margins[5])*(pos[0]-1) + cumulvarsize
    
    outmargins[2] = margins[5]/2D
    outmargins[3] = margins[5]/2D
    
    
  endelse
  
  ;handle explicit positioning by user
  ;If the user requested a position override defaults
  if pcoord[1] ne -1 then begin
    ystart = pcoord[1]
  endif
  
  if pcoord[3] ne -1 then begin
    yplot_size = pcoord[3]
    if yplot_size eq 0 then begin
    
      self.statusBar->update,'0 height panel cannot be created'
      self.historyWin->update,'0 height panel cannot be created'
      return
    endif
  endif
  
  ystop = ystart + yplot_size
  viewYpos = -(ystart / yplot_size)
  viewYlen = 1./ yplot_size
  
  outmargins[4] = currentvarsize
  
  ;Now generate the views.  
  ;The logic for IDL views is a little weird, but these settings guarantee that
  ;Things placed in the view can be positioned as if they are in a coordinate system
  ;relative to the panel, rather than relative to the whole layout.  This significantly
  ;simplifes a ton of the positioning code.
  
  ;Even though the views(annotation,view,marker) are different, they have basically
  ;the same settings.  Having different views allows different organization of
  ;the draw tree and sometimes affects layering.
  
  view = OBJ_NEW('IDLgrView')
  
  view->setProperty,units=3,viewplane_rect=[viewXpos,viewYpos,viewXlen,viewYlen], $
    location=[xpos,ypos],dimensions=[xlen,ylen],zclip=[1.,-1.], $
    eye=5.,transparent=1,/double
    
  annotation = OBJ_NEW('IDLgrView')
  
  annotation->setProperty,units=3,viewplane_rect=[viewXpos,viewYpos,viewXlen,viewYlen], $
    location=[xpos,ypos],dimensions=[xlen,ylen],zclip=[1.,-1.], $
    eye=5.,transparent=1,hide=0,/double
    
  ;now loop through and make the marker views
  if markernum gt 0 then begin
    markers = objarr(markernum)
    
    for i = 0,markernum - 1 do begin
    
      marker = obj_new('IDLgrView')
      
      marker->setProperty,units=3,viewplane_rect=[viewXpos,viewYpos,viewXlen,viewYlen], $
        location=[xpos,ypos],dimensions=[xlen,ylen],zclip=[1.,-1.], $
        eye=5.,transparent=1,hide=0,/double
        
      markers[i] = marker
    endfor
  endif
  
  xplotPos = [xstart,xstop]
  yplotPos = [ystart,ystop]
  
  fail = 0
  
end

;updates the draw object to reflect the page settings
;Inputs:
;  pageSettings(object reference):  the thm_ui_page_settings associated with the window being drawn
;  
;Outputs:
;  returns: 1 on success, 0 on failure.
;  
;Mutates:
;  self.pageview, self.scene,self.currentPageSize,self.staticviews
;
function thm_ui_draw_object::updatePage,pageSettings

  compile_opt idl2
  
  ;Constants to determine title position
  vertical_offset_top = 20 ; pts
  vertical_offset_bottom = 5 ; pts
  
  pageSettings->getproperty,backgroundcolor=bgcol, orientation=orientation, canvasSize=canvasSize
  
  ;These routines automatically replace any format codes
  ;with actual values
  title = pageSettings->getTitleString()
  
  footer = pageSettings->getFooterString()

  self.currentPageSize = canvasSize
  ; dim = self->getDim()
  
  ; dim /= self->getZoom()
  
  ;Create the pageview if it doesn't already exist
  if ~obj_valid(self.pageview) then begin
    pageview = obj_new('IDLgrView')
    self.pageview = pageview
    pageview->setProperty,units=3,viewplane_rect=[0.,0.,1.,1.],location=[0.,0.],dimensions=[1.,1.],zclip=[1.,-1.],eye=5,name="pageview",/transparent,/double
    self.scene->add,pageview
  endif
  
  ;add pageview to the group of static views
  ;used for instancing
  self.staticViews->add,self.pageView
  
  ;set the background color
  self.scene->setProperty,color=self->convertColor(bgcol)
  
  ;remove old page info
  self.pageview->remove,/all
  
  ;Create the title and the footer
  if obj_valid(title) then begin
  
    grTitle = self->getTextModel(title,[.5,1.-self->pt2norm(vertical_offset_top,1),0.],-1,0)
    
    self.pageview->add,grTitle
    
    obj_destroy,title
    
  endif
  
  if obj_valid(footer) then begin
  
    grFooter = self->getTextModel(footer,[.5,self->pt2norm(vertical_offset_bottom,1),0.],1,0)
    
    self.pageview->add,grFooter
    
    obj_destroy,footer
    
  end
  
  return,1
  
end

;Calculates the zrange of a spectral plot based upon the set of spectral traces in the panel
;and the z-axis settings
;
;Inputs:
;  dataPtrs(array of ptrs to arrays):  Array of ptrs to the z-axis data for this panel.
;  zaxisSettings:  thm_ui_zaxis_settings object for this panel.
;  
;Output:
;  range(2 element double):  The determined range
;  scaling(long):  The scaling mode: 0(linear),1(log10),2logn
;  fail(boolean):  1 on fail, 0 on success
;  fixed(boolean):  1 if fixed range is used, 0 if autorange is used
;
;Keywords: 
;  forceauto:
;    Forces an auto calculation to identify the full range of the data
;
pro thm_ui_draw_object::getZRange,dataptrs,zaxisSettings,range=range,scaling=scaling,fail=fail,fixed=fixed,forceauto=forceauto

  compile_opt idl2
  
  fail = 1
  
  zAxissettings->getProperty,fixed=fixed,maxRange=maxRange,minRange=minRange,scaling=scaling
  
  if keyword_set(forceauto) then begin
    fixed = 0
  endif
  
  ;For fixed range, just validate values and log the inputs
  if fixed then begin
  
    if maxRange lt 0 && scaling ne 0 then begin
      self.statusbar->update,'Error: Negative fixed range with logarithmic Z axis, autoscaling instead.'
      self.historywin->update,'Error: Negative fixed range with logarithmic Z axis, autoscaling instead.'
      ;ok = error_message('Negative range with logarithmic axis',/traceback)
      fixed = 0
    endif else if minRange lt 0 && scaling ne 0 then begin
      self.statusbar->update,'Error: Negative fixed range with logarithmic Z axis, autoscaling instead.'
      self.historywin->update,'Error: Negative fixed range with logarithmic Z axis, autoscaling instead.'
      ; ok = error_message('Negative range with logarithmic axis',/traceback)
      fixed = 0
    endif else if minRange gt maxRange then begin
      self.statusbar->update,'Error: min fixed z-range greater than max fixed z-range, autoscaling instead.' 
      self.historywin->update,'Error: min fixed z-range greater than max fixed z-range, autoscaling instead.' 
      fixed = 0
    endif
    
  endif
    
  if fixed then begin
    
     if scaling eq 1 then begin
      range = alog10([minRange,maxRange])
    endif else if scaling eq 2 then begin
      range = alog([minRange,maxRange])
    endif else begin
      range = [minRange,maxRange]
    endelse
  
    if scaling ne 0 && (minRange eq 0 || maxRange eq 0) then begin
    
      self.statusbar->update,'Warning: Adjusting Fixed 0 value on logarithmic Z-axis to data minimum.'
      self.historywin->update,'Warning: Adjusting Fixed 0 value on logarithmic Z-axis to data minimum.'
    
      self->getZrange,dataptrs,zAxisSettings,range=autorange,/forceauto
      
      if minRange eq 0 then begin
        range[0] = autorange[0]
      endif
  
      if maxRange eq 0 then begin
        range[1] = autorange[1]
      endif
    endif
    
  endif else begin
  
    minRange = !VALUES.D_NAN
    maxRange = !VALUES.D_NAN
    
    ;for autoscale, loop over data and identify the join of the min and max for each quantity
    for i = 0, n_elements(dataptrs)-1 do begin
    
      ;the calculation varies a little bit if log inputs are present.
      ;le 0 values need to be screened
      if ptr_valid(dataptrs[i]) then begin
      
        if scaling eq 1 || scaling eq 2 then begin
         
          idx = where(*dataptrs[i] gt 0,c1)
          idx = where(*dataptrs[i] eq 0,c2)
         
          ;This is fix deals with out of range log values
          if c1 eq 0 && c2 eq 0 then begin
            ;do nothing
          endif else if c1 eq 0 then begin
            if ~finite(minRange) && ~finite(maxRange) then begin
              minRange = -!VALUES.D_INFINITY
              maxRange = -!VALUES.D_INFINITY
            endif
          endif else if scaling eq 1 then begin
            minRange = min([min(alog10(*dataptrs[i]),/nan),minRange],/nan)
            maxRange = max([max(alog10(*dataptrs[i]),/nan),maxRange],/nan)
          endif else begin
            minRange = min([min(alog(*dataptrs[i]),/nan),minRange],/nan)
            maxRange = max([max(alog(*dataptrs[i]),/nan),maxRange],/nan)
          endelse
        endif else begin
          minRange = min([min(*dataptrs[i],/nan),minRange],/nan)
          maxRange = max([max(*dataptrs[i],/nan),maxRange],/nan)
        endelse
      endif
      
    endfor
    
    range=[minRange,maxRange]
    
  endelse
  
  range = double(range)
  
  fail = 0
  
  return
  
  
end

;Calculates the range of a sequence. Based upon axis settings and the set of traces in the panel.
;This calculation is symmetric across the x/y axes.
;Inputs:
;
;  dataPtrs(array of ptrs to arrays):  List of pointer to data quantities for which range is calculated
;  axisSettings(object reference):  The thm_ui_axis_settings object for this panel.
;  mirror(array of ptrs to arrays, optional):  List of pointers to mirror data quantities. 
;                                 Should have same number of elements as dataPtrs, and really only makes sense when used with the y-axis
;Outputs:
;
;  range(2 element double):  The determined range
;  scaling(long):  The scaling mode: 0(linear),1(log10),2logn
;  istime(boolean): Returns the isTime flag from the axis being queried
;  fail(boolean):  1 on fail, 0 on success
;
;

pro thm_ui_draw_object::getRange,dataptrs,axisSettings,mirror=mirror,scaling=scaling,range=range,istime=isTimeAxis,fail=fail,center=center

  compile_opt idl2
  
  fail = 1
  
  axisSettings->getProperty,rangeOption=rangeOption, $
    rangeMargin=rangeMargin,$
    boundScaling=boundScaling, $
    boundfloating=boundfloating,$
    minFloatRange=minFloatRange,$
    maxFloatRange=maxFloatRange,$
    minBoundRange=minBoundRange, $
    maxBoundRange=maxBoundRange, $
    minFixedRange=minFixedRange, $
    maxFixedRange=maxFixedRange, $
    floatingSpan=floatingSpan, $
    floatingCenter=floatingCenter,$
    scaling=scaling,$
    isTimeAxis=isTimeAxis,$
    annotateStyle=annotateStyle,$
    annotateExponent=annotateExponent
    
  ;error handling for fixed range  done outside of main if block
  ;so that option can be modified and plot may be recovered
  if rangeOption eq 2 then begin
    if maxFixedRange le 0 && scaling ne 0 then begin
      self.statusbar->update,'Error: Negative range with logarithmic X/Y axis, Using automatically scaled range instead.'
      self.historywin->update,'Error: Negative range with logarithmic X/Y axis, Using automatically scaled range instead.'
      ;  ok = error_message('Negative range with logarithmic axis',/traceback)
      rangeOption = 0
    endif else if minFixedRange le 0 && scaling ne 0 then begin
      self.statusbar->update,'Error: Negative range with logarithmic X/Y axis, Using automatically scaled range instead'
      self.historywin->update,'Error: Negative range with logarithmic X/Y axis, Using automatically scaled range instead'  
      ;ok = error_message('Negative range with logarithmic axis',/traceback)
      rangeOption = 0
    endif else if minFixedRange gt maxFixedRange then begin
      self.statusbar->update,'Error: Min Fixed Range greater than Max Fixed Range, Using automatically scaled range instead'
      self.historywin->update,'Error: Min Fixed Range greater than Max Fixed Range, Using automatically scaled range instead'
      ;ok = error_message('Negative range with logarithmic axis',/traceback)
      rangeOption = 0
    endif

  endif
  
  ;should consider similar parameter validation blocks for the other rangeOptions

  ;********* 
  ; THM_UI_AXIS_OPTIONS needs CENTER even when the scaling is not log, so this is outside the rangeOption if/then blocks: 
  ;********* 
  ;The calculation for the floating range is generated using the mean of the center for each individual data quantity.
  ;This is faster to calculate and prevents variations in sample rate between traces from creating an
  ;unreasonable result.  
  ;(For example, if I'm looking at fgl & fgs, the value from fgl would dominate
  ; if I look at the combined mean/median of the data, rather than the mean of the medians
  ; because the sample rate is much higher on fgl, and thus it has many more points.)
  ;
  centers = dblarr(n_elements(dataptrs))
  ; 
  ;loop through data and find the center for each using the requested method
  ;Approximate and Exact centers are handled the same way in the current version.
  for i = 0,n_elements(dataptrs)-1 do begin
  
    if ~ptr_valid(dataPtrs[i]) then continue
    
    if keyword_set(mirror) && ptr_valid(mirror[i]) then begin
      centers[i] = 0
    endif else if scaling eq 1 then begin
      if floatingCenter eq 0 || floatingCenter eq 2 then begin  
	centers[i] = mean((*dataPTrs[i]),/nan)
      endif else if floatingCenter eq 1 || floatingCenter eq 3 then begin
	centers[i] = median((*dataPTrs[i]))
      endif else begin
	self.statusBar->update,'Error: Unrecognized floating center option'
	;ok = error_message('Unrecognized floating center option',/traceback)
	range = double([0,1])
	return
      endelse
    endif else if scaling eq 2 then begin
      if floatingCenter eq 0 || floatingCenter eq 2 then begin
	centers[i] = mean((*dataPTrs[i]),/nan)
      endif else if floatingCenter eq 1 || floatingCenter eq 3 then begin
	centers[i] = median((*dataPTrs[i]))
      endif else begin
	self.statusBar->update,'Error: Unrecognized floating center option'
	;ok = error_message('Unrecognized floating center option',/traceback)
	range = double([0,1])
	return
      endelse
    endif else begin
      if floatingCenter eq 0 || floatingCenter eq 2 then begin
	centers[i] = mean(*dataPTrs[i],/nan)
      endif else if floatingCenter eq 1 || floatingCenter eq 3 then begin
	centers[i] = median(*dataPTrs[i])
      endif else begin
	self.statusBar->update,'Error: Unrecognized floating center option'
	;ok = error_message('Unrecognized floating center option',/traceback)
	range = double([0,1])
	return
      endelse
    endelse
    
  endfor
  ;
  ;After I've got the center, I just add/substract the span
  ;to arrive at the range.
  center = mean(centers,/nan)
  ;********* 
   
   ;fixed range calculation.
   ;all that is required is that the range is put in log space
  if rangeOption eq 2 then begin
    range = [minFixedRange,maxFixedRange]
    
    if scaling eq 1 then begin
      range = double(alog10(range))
    endif else if scaling eq 2 then begin
      range = double(alog(range))
    endif else begin
      range = double(range)
    endelse
    
  endif else if rangeOption eq 1 then begin
;    case scaling of
;      0: center = center
;      1: center = alog10(center)
;      2: center = alog(center)
;    endcase
 
    case scaling of
      0: range = [center-floatingSpan,center+floatingSpan]
      1: range = [alog10(center)-floatingSpan,alog10(center)+floatingSpan]
      2: range = [alog(center)-floatingSpan,alog(center)+floatingSpan]
    endcase

;    range = [center-floatingSpan,center+floatingSpan]
    
    if keyword_set(boundfloating) then begin
      range[0] = max([range[0],minFloatRange],/nan)
      range[1] = min([range[1],maxFloatRange],/nan)
    endif
    
    range = double(range)
    
  endif else if rangeOption eq 0 then begin
  ;automatic scaling option
  
    minRange = !values.d_nan
    maxRange = !values.d_nan
    
    ;loop over the data and find the joined min & max
    ; by joined I mean the min(mins_for_each_quantity), and max(maxes_for_each_quantity)
    for i = 0,n_elements(dataptrs) -1 do begin
    
      if ~ptr_valid(dataPtrs[i]) then continue
      
      if scaling eq 1 then begin
        minRangeTmp = min(alog10(*dataPtrs[i]),/nan)
        maxRangeTmp = max(alog10(*dataPtrs[i]),/nan)
      endif else if scaling eq 2 then begin
        minRangeTmp = min(alog(*dataPtrs[i]),/nan)
        maxRangeTmp = max(alog(*dataPtrs[i]),/nan)
      endif else begin
        minRangeTmp = min(*dataPtrs[i],/nan)
        maxRangeTmp = max(*dataPtrs[i],/nan)
      endelse
      
      ;If a mirror is present, we reflect the range over 0, so that
      ;we can be certain the mirrored line will be in the plot
      if keyword_set(mirror) && ptr_valid(mirror[i]) then begin
        rangeAbs = max([abs(maxRangeTmp),abs(minRangeTmp)],/nan)
        maxRangeTmp = rangeAbs
        minRangeTmp = -rangeAbs
      endif
      
      minRange = min([minRange,minRangeTmp],/nan)
      maxRange = max([maxRange,maxRangeTmp],/nan)
      
    endfor
    
    ;add range margin to calculated range.
    ;It is interpreted as +- some % of the current span.
    ;So if rangemargin is .05, The final span will be the same
    ;whether the range goes from [-10,10] or [100,120], but not [-20,20]
    margin = rangeMargin*(maxRange-minRange)
    
    if margin eq 0 && rangeMargin ne 0 then begin
    
      if maxRange eq 0 then begin
        margin = 1
      endif else begin
        margin = rangeMargin * maxRange
      endelse
    
    endif
    
    maxRange+= margin
    minRange-= margin
    
    ;Boundscaling is last.   If the range is larger or smaller than the bounds,
    ;replace the appropriate value with the bounded value.
    ;It is probably equally correct to calculate the range margin after the boundscaling,
    ;but this would produce a different result.  
    if keyword_set(boundScaling) then begin
    
      if scaling eq 0 then begin
        minRange = max([minRange,minBoundRange],/nan)
        maxRange = min([maxRange,maxBoundRange],/nan)
      endif else if scaling eq 1 then begin
        minRange = max([minRange,alog10(minBoundRange)],/nan)
        maxRange = min([maxRange,alog10(maxBoundRange)],/nan)
      endif else if scaling eq 2 then begin
        minRange = max([minRange,alog(minBoundRange)],/nan)
        maxRange = min([maxRange,alog(maxBoundRange)],/nan)
      endif
      
      if minRange gt maxRange then begin
        self.statusBar->update,'No data found within range when using bound autoscaling range option.'
      ;  return
      endif
      
    endif
    
    range = double([minRange,maxRange])

  endif else begin
    self.statusBar->update,'Error: Illegal range option on axis'
    ;error_message,'Illegal range option on axis',/traceback
    range = double([0,1])
  endelse
  
  
  ;Final value validation  
  if ~finite(range[0]) || ~finite(range[1]) then begin
    self.statusbar->update,'There is no real and finite data in the current range.'
    return
  endif
  
  if range[1]-range[0] lt 0 then begin
    self.statusbar->update,'Error: range interval is less than 0'
    self.historyWin->update,'Error: range interval is less than 0'
    return
  endif
  
  ;Used to convert to strings for error messages.
  data_struct = {scaling:scaling,timeAxis:isTimeAxis,formatid:annotateStyle,exponent:annotateExponent}
  
  if range[1] eq range[0] then begin
 
    self.statusbar->update,'Warning: range interval is 0: ' +'Range: [' + formatannotation(0,0,range[0],data=data_struct)  + ',' + formatannotation(0,0,range[1],data=data_struct)  + ']
    self.historyWin->update,'Warning: range interval is 0: ' +'Range: [' + formatannotation(0,0,range[0],data=data_struct)  + ',' + formatannotation(0,0,range[1],data=data_struct)  + ']
  endif else begin
    
    self.historyWin->update,'Range: [' + formatannotation(0,0,range[0],data=data_struct)  + ',' + formatannotation(0,0,range[1],data=data_struct)  + '] will be used to plot.'
      
  endelse
  
  fail = 0
  
end

;returns a text object by digesting the settings on a thm_ui_text object
;text: a thm_ui_text object
;loc: the normalized location of the text, relative to the view [xpos,ypos,zpos]
;offsetDirFlag: 0=centered,1=abovelocation,-1=belowlocation
;justify, -1 = left, 1=right, 0 = middle
function thm_ui_draw_object::getTextObject,text,loc,offsetDirFlag,orientation,justify=justify,enable_formatting=enable_formatting

  compile_opt idl2
  
  tFont = text->getGrFont()
  
  text->getProperty,color=color,value=value,show=show,size=size
  
  ;calculate parameters determining how the text is justified
  if orientation eq 0 then begin
    if offsetDirFlag eq 0 then begin
      yAlign = .5
    endif else if offsetDirFlag eq 1 then begin
      yAlign = 0.
    endif else begin
      yAlign = 1.
    endelse
    
    if ~keyword_set(justify) then begin
      xAlign = .5
    endif else if justify eq 1 then begin
      xAlign = 1.
    endif else if justify eq -1 then begin
      xAlign = 0.
    endif
    
    baseline = [1,0,0]
    updir = [0,1,0]
    
  endif else begin
  
    if offsetDirFlag eq 0 then begin
      xAlign=.5
    endif else if offsetDirFlag eq 1 then begin
      xAlign = 0.
    endif else begin
      xAlign = 1.
    endelse
    
    if ~keyword_set(justify) then begin
      yAlign = .5
    endif else if justify eq 1 then begin
      yAlign = 1.
    endif else if justify eq -1 then begin
      yAlign = 0.
    endif
    
    baseline=[0,1,0]
    updir = [-1,0,0]
    
  endelse
  
  if size eq 0 then begin
    show = 0
    size = 1D
  endif
  
  tFont->setProperty,size=size*self->getZoom()
  
  grText = obj_new('IDLgrText',value,$
    font=tFont,$
    color=self->convertColor(color),$
    hide=~show,$
    location=loc,$
    alignment=xAlign,$
    vertical_alignment=yalign,$
    baseline=baseline,$
    recompute_dimensions=0,$
    updir=updir,$
    enable_formatting=enable_formatting)
    
    
  return,grText
  
end

;returns a text model by digesting the settings on a thm_ui_text object.
;This is basically just a wrapper for getTextObject
;text: a thm_ui_text object
;loc: the normalized location of the text, relative to the view [xpos,ypos,zpos]
;offsetDirFlag: 0=centered,1=abovelocation,-1=belowlocation
;justify, -1 = left, 1=right, 0 = middle
;
;Output:
;  an IDLgrModel containing an IDLgrText object
;
function thm_ui_draw_object::getTextModel,text,loc,offsetDirFlag,orientation,justify=justify,enable_formatting=enable_formatting

  compile_opt idl2
  
  grText = self->getTextObject(text,loc,offsetDirFlag,orientation,justify=justify,enable_formatting=enable_formatting)
  
  model = obj_new('IDLgrModel')
  
  model->add,grText
  
  return,model
  
end


;constructs a zaxis model for display, from a thm_ui_zaxis_settings object
;
;Inputs:
;  zrange(2 element double):  The min & max range of the axis in logged space.
;  zAxis(object reference):  The thm_ui_zaxis_settings object from which settings will be drawn.
;  xPlotPos(2 element double):  The x-start & stop position of the panel in draw area normal coordinates
;  yPlotPos(2 element double):  The y-start & stop position of the panel in draw area normal coordinates
;  frameColor(3 element bytarr):  The rgb color of the panel frame.
;  frameThick(double):  the thickness of the panel frame, in idl standard line thickness units
;  
;Outputs:
;  model(object reference):  The completed IDLgrModel
;  palette(object reference): The palette object used for this axis.
;  majorNum(long):  The number of major ticks on this axis.
;  minorNum(long):  The number of minor ticks per major tick on this axis
;
;
pro thm_ui_draw_object::makeZAxisModel,zrange,zAxis,xplotpos,yplotpos,framecolor,framethick,model=model,palette=palette,majorNum=majorTickNum,minorNum=minorTickNum

  compile_opt idl2
  
  ;This constant determines how close an automatic
  ;major tick must be to the edge of the axis before it is removed
  edgeTickMargin = .01
  
  ;Annotations within a distance of (roundingfactor)*(data range) of zero
  ;will be rounded to zero
  roundingfactor = 1d-15
  ;This determines how high the axis model will be placed in the layering
  zstack = .1
  ;This is thickness of the axis in points
  thick = 10
  ;Reseting the number of ticks to null value
  majorTickNum = 0
  minorTickNum = 0
  
  zAxis->getProperty, $
    tickNum=majorTickNum, $
    minorTickNum=minorTickNum,$
    annotationStyle=annotationStyle, $
    annotateTextObject=annotateTextObject, $
    annotationOrientation=annotationOrientation,$
    annotateExponent=annotateExponent,$
    labelTextObject=labelTextObject,$
    labelOrientation=labelOrientation,$
    labelMargin=labelMargin,$
    scaling=scaling,$
    placement=placement,$
    margin=margin,$
    autoTicks=autoTicks,$
    logMinorTickType=logMinorTickType
    
  ;If autoticks is set, we aim for 5 major ticks
  if keyword_set(autoTicks) then begin
  
    majorTickNum = 5
  
  endif
    
  ; minorTickNum = 3
    
  model = obj_new('IDLgrModel')
  
  palette = obj_new('IDLgrPalette')
  
  ;lookup the color table from the hard-drive
  getctpath,colortablepath
  
  ;load the color table
  palette->loadCt,zAxis->getColorTableNumber(),file=colortablepath
  
  ;This next block determines the position and dimensions of the axis
  ;The specific meaning of the variables in each if varies because orientation changes.
  ;generally, marginNorm1, is the distance from the x/y axis to the near side of the z-axis, in draw-area normal coordinates
  ;           marginNorm2, is the distance from the x/y axis to the far  side of the z-axis, in draw-area normal coordinates
  ;pt1-4 are each corners of the axis
  
  if placement eq 0 then begin ; top
  
    marginNorm1 = self->pt2Norm(margin,1)
    marginNorm2 = self->pt2Norm(margin+thick,1)
    
    pt1 = [0.,1. + marginNorm1/(yplotpos[1]-yplotpos[0]),zstack]
    pt2 = [1.,1. + marginNorm1/(yplotpos[1]-yplotpos[0]),zstack]
    pt3 = [1.,1. + marginNorm2/(yplotpos[1]-yplotpos[0]),zstack]
    pt4 = [0.,1. + marginNorm2/(yplotpos[1]-yplotpos[0]),zstack]
    
    location = pt1
    xsize = pt3[0]-pt1[0]
    ysize = pt3[1]-pt1[1]
    
  endif else if placement eq 1 then begin ; bottom
  
    marginNorm1 = self->pt2Norm(margin,1)
    marginNorm2 = self->pt2Norm(margin+thick,1)
    
    pt1 = [0.,0. - marginNorm1/(yplotpos[1]-yplotpos[0]),zstack]
    pt2 = [1.,0. - marginNorm1/(yplotpos[1]-yplotpos[0]),zstack]
    pt3 = [1.,0. - marginNorm2/(yplotpos[1]-yplotpos[0]),zstack]
    pt4 = [0.,0. - marginNorm2/(yplotpos[1]-yplotpos[0]),zstack]
    
    location = pt4
    xsize = pt4[0]-pt2[0]
    ysize = pt4[1]-pt2[1]
    
  endif else if placement eq 2 then begin ; left
  
    marginNorm1 = self->pt2Norm(margin,0)
    marginNorm2 = self->pt2Norm(margin+thick,0)
    
    pt1 = [0. - marginNorm1/(xplotpos[1]-xplotpos[0]),0.,zstack]
    pt2 = [0. - marginNorm1/(xplotpos[1]-xplotpos[0]),1.,zstack]
    pt3 = [0. - marginNorm2/(xplotpos[1]-xplotpos[0]),1.,zstack]
    pt4 = [0. - marginNorm2/(xplotpos[1]-xplotpos[0]),0.,zstack]
    
    location = pt4
    xsize = pt4[0]-pt2[0]
    ysize = pt4[1]-pt2[1]
    
  endif else if placement eq 3 then begin ;right
  
    marginNorm1 = self->pt2Norm(margin,0)
    marginNorm2 = self->pt2Norm(margin+thick,0)
    
    pt1 = [1. + marginNorm1/(xplotpos[1]-xplotpos[0]),0.,zstack]
    pt2 = [1. + marginNorm1/(xplotpos[1]-xplotpos[0]),1.,zstack]
    pt3 = [1. + marginNorm2/(xplotpos[1]-xplotpos[0]),1.,zstack]
    pt4 = [1. + marginNorm2/(xplotpos[1]-xplotpos[0]),0.,zstack]
    
    location = pt1
    xsize = pt3[0]-pt1[0]
    ysize = pt3[1]-pt1[1]
    
  endif else begin
  
    return
    
  endelse
  
  ;If we are not using a postscript,
  ;The axis is modeled as a texture mapped polygon.  
  
  if ~keyword_set(self.postscript) then begin
  
    ; if 0 then begin
    poly = obj_new('IDLgrPolygon')
  
    image = obj_new('IDLgrImage',indgen(1,256),palette=palette)
    
    poly->setProperty,data=[[pt1],[pt2],[pt3],[pt4]],texture_map = image,texture_coord=[[0,0],[0,1],[1,1],[1,0]],/texture_interp,color=self->convertColor([255,255,255]),/double
    
  endif else begin
  
    ;Since postscript does not properly render texture mapped polygons, we use a static image and control layering using order.
    poly = obj_new('IDLgrImage',indgen(1,256),palette=palette,location=location,dimensions=[xsize,ysize],depth_test_disable=2)
    
  endelse
  
  ;now create axis
  
  if majorTickNum lt 0 then begin
  
    self.statusBar->update,'Illegal negative z axis major tick number, using 0 ticks'
    self.historyWin->update,'Illegal negative z axis major tick number, using 0 ticks'
    majorTickNum = 0
    
  endif
  
 
  ;this is a bit of a kluge to deal with the
  ;case of a logarithmic z-axis with only 0 values
  ;To fix this we treat it as 0,0 range in log space([1,1] in normal)
  if finite(zrange[0],/infinity,sign=-1) && $
     finite(zrange[1],/infinity,sign=-1) && $
     (scaling eq 1 || scaling eq 2) then begin
     
     scaling = 0
     zrange = [0D,0D]    
 
  endif
 
  ;If there are no finite values we go to a default range
  if ~finite(zrange[0]) || ~finite(zrange[1]) then begin
    zrange = [0D,1D]
  endif
  
  ;Now determine major tick position
  if majorTickNum gt 0 then begin
  
    ;First try human readable tick algorithm
    self->goodTicks,0,zrange,scaling,majorTickNum, $
                  tickValues=tickValues,tickInterval=tickInterval,$
                  /nozero,minorTickNum=minorTickNumRecommended
         

    ;if we don't have enough ticks on a logarithmic axis
    ;we should correct the ticks, by using logFixTicks to add more, but placed at slightly less regular values.  
    if n_elements(tickValues) lt 2 && $
       majorTickNum ge 2 && $
       scaling eq 1 then begin
    
      self->logFixTicks,$
        zrange,$
        tickValues=tickValues,$
        tickInterval=tickInterval,minorTickNum=minorTickNumRecommended
        
      ticksFixed = 1
       
    endif

    ;If available and not overriden by user settings,
    ;we use the recommended tick number, which should be appropriate for tick spacing. 
    if keyword_set(autoticks) && $
       n_elements(minorTickNumRecommended) gt 0 && $
       minorTickNumRecommended ge 0 then begin
      minorTickNum = minorTickNumRecommended
    endif
     
  
    ;if values aren't too close to the edge of the range, we 
    ;add leading and trailing ticks
    if n_elements(tickValues) gt 0 then begin       
     
      ;make sure ticks run to the edge of available range
      while tickValues[0] gt edgeTickMargin do begin
        tickValues = [tickValues[0]-tickInterval,tickValues]
      endwhile
        
      while tickValues[n_elements(tickValues)-1] lt (1-edgeTickMargin) do begin
        tickValues = [tickValues,tickValues[n_elements(tickValues)-1]+tickInterval]
      endwhile
      
      tickValuesForMinors = tickValues 
      
      ;remove out of range major tick values
      idx = where(tickValues le 1. and tickValues ge 0,c)
      if c gt 0 then begin
       
        tickValues = tickValues[idx]
        
      endif else begin
        tickValues = tickValues[0]
        noMajors=1
      endelse
                   
    endif else begin
      noMajors = 1
    endelse
        
    ;if autoticks is not selected, and the number of ticks
    ;produced by ::goodticks is not the number requested,
    ;generate the requested number of ticks.  
    ;In the future, we may be able to improve goodTicks
    ;by incorporating an iterative approximation algorithm         
    if ~keyword_set(autoTicks) && $
       n_elements(tickValues) ne majorTickNum then begin
       
       tickInterval = 1D/(majorTickNum+1)
       tickValues = (dindgen(majorTickNum)+1)*tickInterval
       tickValuesForMinors = [0,tickValues,1]
       noMajors = 0
       ticksFixed = 1
  
    endif
        
    ;if number of ticks gets switched because of automatic ticks
    ;update the value here
    majorTickNum = n_elements(tickValues)
     
  endif else begin
   
    tickValues = [0D,1D]
    tickValuesForMinors = tickValues
    tickInterval = 1
     
  endelse
  
  ;if we're using less than powers of 10 on a log axis
  ;Then force scientific notation
  if keyword_set(ticksFixed) && annotateExponent eq 0 then begin
    annotateExponent = 2
  endif
          
  ;This struct is used to communicate annotation format settings
  data = {timeAxis:0,formatid:annotationStyle,scaling:scaling,range:zrange,exponent:annotateExponent}
  
  ;Determine label alignment/justification options and position
  if placement eq 0 then begin
  
    if annotationOrientation eq 0 then begin
      annobaseline = [1,0,0]
      annoupdir = [0,1,0]
      annoalignment = [.5,0.0]
    endif else begin
      annobaseline = [0,1,0]
      annoupdir = [-1,0,0]
      annoalignment = [0.0,.5]
    endelse
    
    loc = [0D, [1. + marginNorm2/(yplotpos[1]-yplotpos[0])],zstack+.1]
    
    ticklen = self->pt2norm(thick,1)/(yplotpos[1]-yplotpos[0])
    
    tickDir = 0
    textpos = 1
    
    dir = 0
    
  endif else if placement eq 1 then begin
  
    if annotationOrientation eq 0 then begin
      annobaseline = [1,0,0]
      annoupdir = [0,1,0]
      annoalignment = [.5,1.0]
    endif else begin
      annobaseline = [0,1,0]
      annoupdir = [-1,0,0]
      annoalignment = [1.0,.5]
    endelse
    
    loc = [0D, [0. - marginNorm2/(yplotpos[1]-yplotpos[0])],zstack+.1]
    
    ticklen = self->pt2norm(thick,1)/(yplotpos[1]-yplotpos[0])
    
    tickDir = 1
    textpos = 0
    
    dir = 0
    
  endif else if placement eq 2 then begin
  
    if annotationOrientation eq 0 then begin
      annobaseline = [1,0,0]
      annoupdir = [0,1,0]
      annoalignment = [1.0,.5]
    endif else begin
      annobaseline = [0,1,0]
      annoupdir = [-1,0,0]
      annoalignment = [.5,0.0]
    endelse
    
    
    loc = [[0. - marginNorm2/(xplotpos[1]-xplotpos[0])],0D,zstack+.1]
    
    ticklen = self->pt2norm(thick,1)/(xplotpos[1]-xplotpos[0])
    
    tickDir = 1
    textpos = 0
    
    dir = 1
    
  endif else if placement eq 3 then begin
  
    if annotationOrientation eq 0 then begin
      annobaseline = [1,0,0]
      annoupdir = [0,1,0]
      annoalignment = [0.0,.5]
    endif else begin
      annobaseline = [0,1,0]
      annoupdir = [-1,0,0]
      annoalignment = [.5,1.0]
    endelse
    
    loc = [[1. + marginNorm2/(xplotpos[1]-xplotpos[0])],0D,zstack+.1]
    
    ticklen = self->pt2norm(thick,1)/(xplotpos[1]-xplotpos[0])
    
    tickDir = 0
    textpos = 1
    
    dir = 1
    
  endif
  
  ;Now we determine where to render minor ticks and we generate an axis for them
  if majorTickNum gt 0 && ~keyword_set(nomajors) then begin
  
    borderpos = [[pt4],[pt1],[pt2],[pt3]]
  
    ;calculate irregular minor tick spacing
    if minorTickNum ne 0 then begin
          
      self->makeMinorTicks,zrange,scaling,minorTickNum,tickValuesForMinors,tickInterval,logMinorTickType,minorValues=minorTickValues,fail=fail
      
      if ~fail then begin
        axis_minor = obj_new('IDLgrAxis',dir, $
          range=[0D,1D], $
          location=loc, $
          minor=0,$
          tickLen = ticklen/2,$
          tickdir=tickDir,$
          tickValues=minorTickValues,$
          subTickLen=0,$
          thick=framethick,$
          tickfrmtdata=data,$
          tickformat='formatannotation',$
          color=self->convertColor(frameColor),$
          /notext,$
          /exact)
          
        model->add,axis_minor
      endif
       
    endif
    
    ;determine if any ticks are going to be auto-shifted into exponential
    ;if yes, make them all exponential
    ;This makes sure that are formatting is done in a consistent fashion on any particular axis.
    if data.exponent eq 0 && (scaling eq 0 || scaling eq 1) then begin
      for i = 0,n_elements(tickValues)-1 do begin
      
        if (data.range[1]-data.range[0]) eq 0 then begin
          val = data.range[0]
        endif else begin
          val = (tickValues[i] + data.range[0]/(data.range[1]-data.range[0]))*(data.range[1]-data.range[0])
            relativecuttoff = (data.range[1]-data.range[0])*roundingfactor
            if val le relativecuttoff && val ge -relativecuttoff then begin
              val = 0
            endif
        endelse
        
        if scaling eq 1 then begin
          val = 10^val
        endif
        
        thm_ui_usingexponent,val,data,type=type
        
        if type ne 0 && scaling eq 0 then begin
          data.exponent = 2
          break
        endif else if type ne 0 && scaling eq 1 then begin
          data.exponent = 3
          break
        endif
      endfor
    endif

    ;Now we create an axis object for major ticks.
    ;Because IDL doesn't allow the degree of control
    ;that the options in the gui spec require. The 
    ;axis is generated by layering several simpler IDLgrAxis
    ;objects on top of each other, and controlling their
    ;settings explicitly so that it gives the appearance of
    ;a single axis.
    if ~keyword_set(nomajors) then begin

      axis1 = obj_new('IDLgrAxis',dir, $
          range=[0D,1D], $
          location=loc, $
          minor=0,$
          tickLen = ticklen,$
          tickdir=tickDir,$
          textpos=textpos,$
          tickValues=tickValues,$
          thick=framethick,$
          tickfrmtdata=data,$
          tickformat='formatannotation',$
          color=self->convertColor(frameColor),$
          textBaseLine = annobaseline,$
          textupdir = annoupdir, $
          textalignments = annoalignment, $
          /use_text_color,$
          /exact)
          
    endif else begin
    
       axis1 = obj_new('IDLgrAxis',dir, $
          range=[0D,1D], $
          location=loc, $
          minor=0,$
          subTickLen=0.0,$
          tickLen = ticklen,$
          tickdir=tickDir,$
          textpos=textpos,$
          major=0,$
          thick=framethick,$
          tickfrmtdata=data,$
          tickformat='formatannotation',$
          color=self->convertColor(frameColor),$
          textBaseLine = annobaseline,$
          textupdir = annoupdir, $
          textalignments = annoalignment, $
          /use_text_color,$
          /exact)
    
    endelse
  
      
    ;Since annotation object are autogenerated when IDLgrAxis is created
    ;We need to pull them out after the fact to overwrite some of their settings
    ;(for example, IDL uses the same color argument to axis object as the color for both the axis line and the text itself)
    axis1->getProperty,tickText=tickObj
    
    annofont = annotateTextObject->getGrFont()
    
    annotateTextObject->getProperty,color=annocolor,size=size
    
    annoFont->setProperty,size=self->getZoom()*size
    
    tickObj->setProperty,font=annofont,color=self->convertColor(annocolor)
    
    model->add,axis1
  
  endif else begin
  
    borderpos = [[pt4],[pt1],[pt2],[pt3],[pt4]]
  
  endelse
  
  ; now create/position the label
  if obj_valid(labelTextObject) then begin
  
    if placement eq 0 then begin
    
      pos = [.5,1.+self->pt2norm(margin+thick+labelmargin,1)/(yplotpos[1]-yplotpos[0]),zstack+.1]
      
      offset = 1
      justify = 0
      
    endif else if placement eq 1 then begin
    
      pos = [.5,0.-self->pt2norm(margin+thick+labelmargin,1)/(yplotpos[1]-yplotpos[0]),zstack+.1]
      
      offset = -1
      justify = 0
      
    endif else if placement eq 2 then begin
    
      pos = [0.-self->pt2norm(margin+thick+labelmargin,0)/(xplotpos[1]-xplotpos[0]),.5,zstack+.1]
      
      if labelOrientation eq 0 then begin
        offset = 0
        justify = 1
      endif else begin
        offset = 0
        justify = -1
      endelse
      
    endif else if placement eq 3 then begin
    
      pos = [1.+self->pt2norm(margin+thick+labelmargin,0)/(xplotpos[1]-xplotpos[0]),.5,zstack+.1]
      
      if labelOrientation eq 0 then begin
        offset = 0
        justify = -1
      endif else begin
        offset = 0
        justify = 1
      endelse
      
    endif
    
    labelObj = self->getTextObject(labelTextObject,pos,offset,labelOrientation,justify=justify,/enable_formatting)
    
    model->add,labelObj
    
  endif
  
  ;Since axis is only on one side, we create a border around the other sides.
  border = obj_new('IDLgrPolyLine',borderpos,color=self->convertColor(frameColor),thick=framethick,/double)
  
  model->add,border
  
  model->add,poly
  
  
end

;Function adapted from Graphics Gems:
;Heckbert, Paul S., Nice Numbers for Graph Labels, Graphics Gems, p. 61-63, code: p. 657-659
;It identifies the closest "nice" number
;Nice being a number j * 10 ^ n where j = 1,2,5,10 and n = any integer
;
;Inputs:
;  n(double):  The number for which the nearest nicenum is being found
;  
;  floor(optional,boolean keyword): The routine picks the nearest nicenum below n
;  
;  ceil(optional,boolean keyword): The routine picks the nearest nicenum above n
;  
;  factors(optional, array of numeric types): rather than using 1,2,5,10, pass an array
;                                      of alternate values. Common inputs are
;                                      [1,2,3,4,5,6,7,8,9,10], or [1,2,3,6,10]
;                                      
;  bias(optional,long): Some sets of factors may entail looking at the first 2 or D
;                       digits of the nearest nicenum, rather than just the first. 
;                       If this is the case, this argument should be set to instruct
;                       this algorithm to look at 2 digits.  For example, if 
;                       factors = dindgen(101), bias should be 1, if factors = dindgen(1001)
;                       bias should be 2. The default is 0
;  Outputs:                     
;    factor_index(long): this returns an index into the factor_array indicating which
;                        factor actually got selected.  For example: If nicenum = 2, then 
;                        factor_index = 1
;  
;  Returns: 
;     The nicenum that was found
;  
;NOTES:
;  Default behavior is to find the nearest nicenum above or below N, but the algorithm from
;  graphics gems could only approximate this somewhat roughly.  So instead, two calls one
;  with /floor and one with /ceil is made by the calling routine and the called decides
;  which result is closest.
  
;
;factor_index:  The index of the factor that will be used for the result.(ie different j's)
function thm_ui_draw_object::niceNum,n,floor=floor,ceil=ceil,factors=factors,bias=bias,factor_index=factor_index

  compile_opt idl2

  ;factors = dindgen(100)+1
 ; factors = [1,2,5,10]

  ;this input used to determine the values that
  ;the leading digit(s) should snap to 
  if ~keyword_set(factors) then begin
    factors = [1,2,3,4,5,6,7,8,9,10]
  endif
  
  ;If the algorithm should consider more than 1 digit
  ;This value should grow(bias = 1 => 2 digits considered)
  if ~keyword_set(bias) then begin
    bias = 0
  endif

  exponent = floor(alog10(n))
  
  f = n/(10D^(exponent-bias))
  
  ;For each variant of the operation,
  ;it loops through and finds the "nearest" factor
  ;Then puts the output at the correct order of magnitude.
  ;This could probably be vectorized, but I don't think
  ;that it is taking a lot of runtime.
  
  ;this version performs a floored operation
  
  if keyword_set(floor) then begin
    for i = 0,n_elements(factors)-1 do begin
  
      if i eq n_elements(factors)-1 || $
         f lt factors[i+1] then begin
        nf = factors[i]
        break
      endif 
      
    endfor
  endif else if keyword_set(ceil) then begin
    for i = 0,n_elements(factors)-1 do begin
  
      if  i eq n_elements(factors)-1 || $
          f le factors[i] then begin
          
        nf = factors[i]
        break
      endif 
    
    endfor
  
  endif else begin
  
    for i = 0,n_elements(factors)-1 do begin
    
      if  i eq n_elements(factors)-1 || $
          f lt (factors[i] + factors[i+1])/2D then begin
            
        nf = factors[i]
        break
      endif
       
    endfor
    
  endelse

  factor_index = i
 
  return, nf*(10D^(exponent-bias))

end

;Function adapted from Graphics Gems:
;Heckbert, Paul S., Nice Numbers for Graph Labels, Graphics Gems, p. 61-63, code: p. 657-659
;It identifies the closest "nice" number
;Nice being a number j * 10 ^ n where j = 1,2,5 and n = any integer
;
;This routine performs nicenum on a time in seconds, it will
;account for whether the input is closer to an hour or a minute or a day.
;Good factors to use with this routine are [1,2,3,6,10]
; 
;Its Input/Output/Return parameter are identifcal to niceNum
;

function thm_ui_draw_object::niceNumTime,n,factor_index=factor_index,_extra=ex

  compile_opt idl2

  if n le 60D then begin
    return,self->niceNum(n,factor_index=factor_index,_extra=ex)
  endif else if n le 60D*60D then begin
    return,self->niceNum(n/60D,factor_index=factor_index,_extra=ex)*60D
  endif else if n le 60D*60D*24D then begin
    return,self->niceNum(n/(60D*60D),factor_index=factor_index,_extra=ex)*60D*60D
  endif else begin
    return,self->niceNum(n/(60D*60D*24D),factor_index=factor_index,_extra=ex)*60D*60D*24D
  endelse
  
end

;This routine actually does the bulk of the work
;to select good ticks. 
pro thm_ui_draw_object::goodTicks,$
                        isTime,$ ;Boolean, is the axis a time axis
                        range, $ ;2 element double precision, axis range(in log space for log axes)
                        scaling, $ ; 0: linear,1: log10,2 logN
                        numTicks, $ ; The recommended number of ticks( 2 or more)
                        tickValues=tickValues, $ ; Returns the tick values here
                        tickInterval=tickInterval,$ ; Returns the spacing here
                        minorTickNum=minorTickNum,$ ; Returns recommended number of minor Ticks
                        nozero=nozero ; set this keyword to guarantee there are never 0 ticks

  compile_opt idl2

  minorTickNum = -1

  ;These values are output only, prevents previous iterations from interacting.
  if n_elements(tickValues) gt 0 then begin
    tmp = temporary(tickValues)
  endif
  
  if n_elements(tickInterval) gt 0 then begin
    tmp = temporary(tickInterval)
  endif

  ;if the range is too small then return with evenly spaced ticks
  ;this case generally means that all ticks will have the same
  ;value and should not ever happen on normal plots
  if (range[1] - range[0]) / (numTicks+1) eq 0 then begin
    tickValues = dindgen(numTicks+2)/(numTicks+1)
    tickInterval = 1D/(numTicks+1) 

    return
    
  endif 

  ;the different factors that might be used for different nicenum calls
  ;and the number of minor ticks that are recommended for each outcome
  minorTicksDecimal = [10,4,5,10]-1
  factorsDecimal = [1D,2D,5D,10D]
  minorTicksTime = [10,4,3,6,10]-1
  factorsTime = [1D,2D,3D,6D,10D]
  
  ;This algorithm finds the closest nicenum below the input(floor) 
  ;and the closest nicenum above the input(ceil), then
  ;makes its own determinations about which is closest
  
  if istime then begin
  
    ;This handles sub-seconds
    if (range[1]-range[0])/(numTicks+1) lt 1 then begin
    
      minorTicks = minorTicksDecimal
      factors = factorsDecimal
    
      realTickIntervalFloor = self->nicenum((range[1]-range[0])/(numTicks+1),/floor,factors=factors,factor_index=factorIndexFloor)
      realTickIntervalCeil = self->nicenum((range[1]-range[0])/(numTicks+1),/ceil,factors=factors,factor_index=factorIndexCeil)
        
    ;This handles values larger that seconds
    endif else begin
  
      minorTicks = minorTicksTime
      factors = factorsTime
  
      realTickIntervalFloor = self->nicenumtime((range[1]-range[0])/(numTicks+1),/floor,factors=factors,factor_index=factorIndexFloor)
      realTickIntervalCeil = self->nicenumtime((range[1]-range[0])/(numTicks+1),/ceil,factors=factors,factor_index=factorIndexCeil)
      
    endelse
   
     
  ;   realTickIntervalFloor = self->nicenumtime((range[1]-range[0])/(numTicks+1),/floor)
  ;   realTickIntervalCeil = self->nicenumtime((range[1]-range[0])/(numTicks+1),/ceil)
  endif else begin

    ;Use two different techniques to indentify nice ticks.
    ;The best result is used
  
    if scaling eq 0 || scaling eq 2 then begin
  
      minorTicks = minorTicksDecimal
      factors = factorsDecimal
  
      ;Identify a nice interval close to the tick interval(from below)
      realTickIntervalFloor = self->nicenum((range[1]-range[0])/(numTicks+1),/floor,factors=factors,factor_index=factorIndexFloor)
      
      ;Identify a nice interval close to the tick interval(from above)
      realTickIntervalCeil = self->nicenum((range[1]-range[0])/(numTicks+1),/ceil,factors=factors,factor_index=factorIndexCeil)
      
    endif else begin
     
      minorTicks = 8
      factorIndexFloor = 0
      factorIndexCeil = 0
     
      ;the max function here disallows fractional exponents, which don't often translate into readable numbers
      realTickIntervalFloor = max([self->nicenum((range[1]-range[0])/(numTicks+1),/floor),1D])
      
      realTickIntervalCeil = max([self->nicenum((range[1]-range[0])/(numTicks+1),/ceil),1D])
    
    endelse
    
  endelse
    
  ;Identify the value at which the ticks will start.
  tickStartFloor = ceil(range[0]/realTickIntervalFloor,/l64)*realTickIntervalFloor - range[0]
  ;Identify the value at which the ticks will stop.
  tickStopFloor =  floor(range[1]/realTickIntervalFloor,/l64)*realTickIntervalFloor - range[1]
  
  ;Identify the actual number of ticks that will be drawn.(numTicks is treated as an approximate value.
  realTickNumFloor = round((range[1]-range[0]+tickStopFloor-tickStartFloor)/realTickIntervalFloor + 1,/l64)
  
  ;Identify a nice interval close to the tick interval.
 
  
  ;Identify the value at which the ticks will start.
  tickStartCeil = ceil(range[0]/realTickIntervalCeil,/l64)*realTickIntervalCeil - range[0]
  ;Identify the value at which the ticks will stop.
  tickStopCeil =  floor(range[1]/realTickIntervalCeil,/l64)*realTickIntervalCeil - range[1]
  
  ;Identify the actual number of ticks that will be drawn.(numTicks is treated as an approximate value.
  realTickNumCeil = round((range[1]-range[0]+tickStopCeil-tickStartCeil)/realTickIntervalCeil + 1,/l64)
  
  
  ;select the winning parameters for output.
  ;This is based upon whether the floor or ceil is closest
  
  if ~keyword_set(nozero) then begin
   if abs(numTicks-realTickNumCeil) lt abs(numTicks-realTickNumFloor) || $
     (abs(numTicks-realTickNumCeil) eq abs(numTicks-realTickNumFloor) && $
      realTickNumCeil gt realTickNumFloor) then begin
      realTickInterval = realTickIntervalCeil
      tickStart = tickStartCeil
      realTickNum = realTickNumCeil
      minorTickNum = minorTicks[factorIndexCeil]
    endif else begin
      realTickInterval = realTickIntervalFloor
      tickStart = tickStartFloor
      realTickNum = realTickNumFloor
      minorTickNum = minorTicks[factorIndexFloor]
    endelse
  endif else begin
   if (abs(numTicks-realTickNumCeil) lt abs(numTicks-realTickNumFloor) || $
     (abs(numTicks-realTickNumCeil) eq abs(numTicks-realTickNumFloor) && $ 
     realTickNumCeil gt realTickNumFloor)) && realTickNumCeil gt 0 then begin  
      realTickInterval = realTickIntervalCeil
      tickStart = tickStartCeil
      realTickNum = realTickNumCeil
      minorTickNum = minorTicks[factorIndexCeil]
    endif else begin
      realTickInterval = realTickIntervalFloor
      tickStart = tickStartFloor
      realTickNum = realTickNumFloor
      minorTickNum = minorTicks[factorIndexFloor]
    endelse
  
  endelse
  
  ;There are not logical interrim values for a natural log axis.
  ;So one tick is used
  if scaling eq 2 then begin
    minorTickNum = 1
  endif
      
  ;if we don't generate any ticks, lets get out of here
  if ~finite(realTickNum) || realTickNum le 0 then return
  
  if realTickNum gt self.maxTickNum then begin
    self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(realTickNum),/remove_all) + ' major ticks.  Draw operation failed.'
    self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(realTickNum),/remove_all) + ' major ticks.  Draw operation failed.'
    return
  endif
    
  ;Determine the tick values in range space.
  realTickValues = dindgen(realTickNum)*realTickInterval+tickStart
  
  ;Normalize the values for placement on the axis.
  tickValues = realTickValues/(range[1]-range[0])
  tickInterval = realTickInterval/(range[1]-range[0])

  return 

end

;It is sometimes the case that logarithmic axes end up with 1 or 0 ticks
;when more were requested.  This routine attempts to fix this problem
;
;It does this by using a little trick of the change of base formula.
;Essentially, if ticks are evenly spaced in base-2 log, then they will
;be evenly spaced in another base.
;
;So if the goodTick algorithm couldn't find ticks at 1x10^1,1x10^2,...
;This algorithm may find ticks at,  5,10,20,40
;
;
pro thm_ui_draw_object::logFixTicks,$
      range_in, $ ;2 element double precision, axis range(in log space)
      tickValues=tickValues, $ ; Returns the tick values here
      tickInterval=tickInterval,$ ; Returns the spacing here
      minorTickNum=minorTickNum ; return a recommended number of minorTicks
     
  numTicks = 2
  minorTickNum = 0
  
  minorTicks = [10,4,5,10]-1
  
  ;destroy any inputs via the outputs
  if n_elements(tickValues) gt 0 then begin
    tmp = temporary(tickValues)
  endif
  
  if n_elements(tickInterval) gt 0 then begin
    tmp = temporary(tickInterval)
  endif
  
  ;if the range is too small then return with evenly spaced ticks
  ;this case generally means that all ticks will have the same
  ;value and should not ever happen on normal plots
  if (range_in[1] - range_in[0]) / (numTicks+1) eq 0 then begin
    tickValues = dindgen(numTicks+2)/(numTicks+1)
    tickInterval = 1D/(numTicks+1) 

    return
    
  endif 
     
  range = 10^range_in
      
  ;Calculate the nominal interval near the requested one.    
  realTickIntervalFloor = self->nicenum((range[1]-range[0])/(numTicks+1),/floor,factors=[1,2,5,10],factor_index=factorIndexFloor)
  ;realTickIntervalFloor = self->nicenum((range[1]-range[0])/(numTicks+1),/floor)    
  realTickIntervalCeil = self->nicenum((range[1]-range[0])/(numTicks+1),/ceil,factors=[1,2,5,10],factor_index=factorIndexCeil)
  ;realTickIntervalCeil = self->nicenum((range[1]-range[0])/(numTicks+1),/ceil)
  
  ;Identify the value at which the ticks will start.
  tickStartFloor = ceil(range[0]/realTickIntervalFloor,/l64)*realTickIntervalFloor - range[0]
  ;Identify the value at which the ticks will stop.
  tickStopFloor =  floor(range[1]/realTickIntervalFloor,/l64)*realTickIntervalFloor - range[1]
  
  ;Identify the actual number of ticks that will be drawn.(numTicks is treated as an approximate value.
  realTickNumFloor = round((range[1]-range[0]+tickStopFloor-tickStartFloor)/realTickIntervalFloor + 1,/l64)
  
  ;Identify a nice interval close to the tick interval.
 
  ;Identify the value at which the ticks will start.
  tickStartCeil = ceil(range[0]/realTickIntervalCeil,/l64)*realTickIntervalCeil - range[0]
  ;Identify the value at which the ticks will stop.
  tickStopCeil =  floor(range[1]/realTickIntervalCeil,/l64)*realTickIntervalCeil - range[1]
  
  ;Identify the actual number of ticks that will be drawn.(numTicks is treated as an approximate value.
  realTickNumCeil = round((range[1]-range[0]+tickStopCeil-tickStartCeil)/realTickIntervalCeil + 1,/l64)
  
  if (abs(numTicks-realTickNumCeil) lt abs(numTicks-realTickNumFloor) || $
     (abs(numTicks-realTickNumCeil) eq abs(numTicks-realTickNumFloor) && $ 
    realTickNumCeil gt realTickNumFloor)) && realTickNumCeil gt 0 then begin  
    realTickInterval = realTickIntervalCeil
    tickStart = tickStartCeil
    realTickNum = realTickNumCeil
    factorIndex = factorIndexCeil
  endif else begin
    realTickInterval = realTickIntervalFloor
    tickStart = tickStartFloor
    realTickNum = realTickNumFloor
    factorIndex = factorIndexFloor
  endelse
  
  ;if we don't generate any ticks, lets get out of here
  if ~finite(realTickNum) || realTickNum le 0 then return
    
    
  ;Determine the tick values in range space.
  realTickValues = dindgen(2)*realTickInterval+tickStart
  
  ;relog
  realTickValues = alog10(realTickValues+range[0])
  
  ;Normalize the values for placement on the axis.
  tickValues = (realTickValues-range_in[0])/(range_in[1]-range_in[0])
  tickInterval = tickValues[1]-tickValues[0]
  minorTickNum = minorTicks[factorIndex]

  return 
      
end
      
      
      
;Determines where to place the tick marks for
;an axis, and deals with the various input validation issues
;and positioning options.
;If they are placed automatically,
;They should be at human readable values, if possible.
;In this case human readable means that if the axis
;is non time, the ticks will be at values of
;1*10^n or 2*10^n or 5*10^n where n is some number
;appropriate to the scale of the axis
;If the axis is a time axis the ticks will be at
;1,2,5 * 10^n or 60*1,2,5*10^n or 60*60*1,2,5*10^n or
;24*60*60*1,2,5*10^n  With selection/n dependent on scale
;
pro thm_ui_draw_object::placeMajorTicks, $
                        isTime,$  ;Boolean, is the axis a time axis
                        range, $  ;2 element double precision, axis range(in log space for log axes)
                        scaling, $ ; 0: linear,1: log10,2 logN
                        majorTickAuto, $ ; Boolean, automatically position major ticks? (If this is 0, ticks will not be placed at human readable values)
                        autoTicks,$ ;Boolean whether the automatic tick algorithm should be used or not
                        numMajorTicks, $ ; number of major ticks(only used if autopositioning is on)
                        firstTickAt, $ ; the location of the first tick(only used if autopositioning is off)
                        majorTickSpace, $ ; the space between major ticks(only used if autopositioning is off)
                        majorTickValues=majorTickValues,$ ; the locations of major ticks are returned as an array from this argument
                        majorTickInterval=majorTickInterval,$ ; the final space between ticks
                        minorTickNum=minorTickNum,$ ; the recommended number of minor ticks for this spacing
                        ticksFixed=ticksFixed,$ ; if we used the non-standard log-spacing, note this so that we can change the annotation style
                        fail=fail  ;Boolean, 1 indicates a failure
          
    
  compile_opt idl2
          
  fail = 1
  ticksFixed = 0
  
  ;this margin determines whether or not another
  ;tick should be added at the beginning or end to create a full range
  edgeTickMargin = .01
               
  minorTickNum = -1
  
  if numMajorTicks lt 0 then return
  
  if range[1] eq range[0] then return
    
  ;if both firstTick and majorTick are autoscaling
  ;then we use human readable tick algorithm
  if majorTickAuto then begin
  
    if keyword_set(autoticks) then begin
      self->goodTicks,isTime,$ ;Boolean, is the axis a time axis
                    range, $ ;2 element double precision, axis range(in log space for log axes)
                    scaling, $ ; 0: linear,1: log10,2 logN
                    numMajorTicks, $ ; The recommended number of ticks( 2 or more)
                    tickValues=majorTickValues, $ ; Returns the tick values here
                    tickInterval=majorTickInterval,$ ; Returns the spacing here
                    minorTickNum=minorTickNum ; returns recommended minor tick number here
     
      ;if we don't have enough ticks on a logarithmic axis
      ;we should correct the ticks, by using logFixTicks to add more, but placed at slightly less regular values.  
      if n_elements(majorTickValues) lt 2 && $
        numMajorTicks ge 2 && $
        scaling eq 1 then begin
      
        self->logFixTicks,$
         range,$
         tickValues=majorTickValues,$
         tickInterval=majorTickInterval,$
         minorTickNum=minorTickNum
          
       ticksFixed = 1
             
      endif
      
      ;this block runs corrections on automatic ticks, if the output is valid.
      ;it guarantees they run slightly passed the edge of the range
      if keyword_set(majorTickValues) && keyword_set(majorTickInterval) then begin     
   
        if majorTickValues[0] gt edgeTickMargin then begin
          majorNewNumLow = floor((majorTickValues[0]-edgeTickMargin)/majorTickInterval,/l64)
          
          if n_elements(majorTickValues) + majorNewNumLow gt self.maxTickNum then begin
            self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(majorTickValues) + majorNewNumLow),/remove_all) + ' major ticks.  Draw operation failed.'
            self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(majorTickValues) + majorNewNumLow),/remove_all) + ' major ticks.  Draw operation failed.'
            return
          endif
          
          majorTickValues = [majorTickValues[0]-(dindgen(majorNewNumLow+1)+1)*majorTickInterval,majorTickValues]
        endif
        
        if majorTickValues[n_elements(majorTickValues)-1] lt (1-edgeTickMargin) then begin
          majorNewNumHigh = floor(((1-edgeTickMargin)-majorTickValues[n_elements(majorTickValues)-1])/majorTickInterval,/l64)
          
          if n_elements(majorTickValues) + majorNewNumHigh gt self.maxTickNum then begin
            self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(majorTickValues) + majorNewNumHigh),/remove_all) + ' major ticks.  Draw operation failed.'
            self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(majorTickValues) + majorNewNumHigh),/remove_all) + ' major ticks.  Draw operation failed.'
            return
          endif
          
          majorTickValues = [majorTickValues,majorTickValues[n_elements(majorTickValues)-1]+(dindgen(majorNewNumHigh+1)+1)*majorTickInterval] 
        endif
      
      endif
    endif else begin
          
      majorTickInterval = 1D/(numMajorTicks+1)
      
      majorTickValues = dindgen(numMajorTicks+2)*majorTickInterval
      fail = 0
      return
    
    endelse
 endif else begin
    
;   if firstTickAt ge range[1] then begin
;     self.statusBar->update,'First tick at is larger than range, no ticks can be drawn.'
;     self.historywin->update,'First tick at is larget than range, no ticks can be drawn.'
;     return
;   endif
   
   if majorTickSpace le 0 then begin
     self.statusBar->update,'Tick Spacing is less than or equal to 0, no ticks can be drawn.'
     self.historywin->update,'Tick Spacing is less than or equal to 0 , no ticks can be drawn.'
     return
   endif
   
   if majorTickSpace gt (range[1]-range[0]) then begin
     self.statusBar->update,'Tick Spacing is greater than range span, no ticks can be drawn.'
     self.historywin->update,'Tick Spacing is greater than range span, no ticks can be drawn.'
     return
   endif
   
   ;first shift tick start so that it is slightly less than
   ;the min range, but still a multiple of the original value
   if firstTickAt le range[0] then begin
     tickStartNum = floor((range[0] - firstTickAt) / majorTickSpace,/l64)
     tickStart = firstTickAt + tickStartNum*majorTickSpace
   endif else begin
     tickStartNum = floor((firstTickAt - range[0]) / majorTickSpace,/l64) + 1
     tickStart = firstTickAt - tickStartNum*majorTickSpace
   endelse
  
   majorTickNum = floor((range[1] - tickStart) / majorTickSpace,/l64) 
  
   tickStart = (tickStart - range[0]) / (range[1]-range[0])
   majorTickInterval = majorTickSpace / (range[1] - range[0])
   
   if majorTickNum gt self.maxTickNum then begin
     self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(majorTickNum),/remove_all) + ' major ticks.  Draw operation failed.'
     self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(majorTickNum),/remove_all) + ' major ticks.  Draw operation failed.'
     return
   endif
   
   majorTickValues = dindgen(majorTickNum+1)*majorTickInterval + tickStart
   
  endelse
  
  if keyword_set(majorTickValues) && keyword_set(majorTickInterval) then begin
  
    idx = where(majorTickValues ge edgeTickMargin and majorTickValues le (1-edgeTickMargin),c)
        
    if c gt 0 then begin
    
      majorTickValues = [0,majorTickValues[idx],1]
   
      ;the old major tick interval could have become invalid when ticks got clipped
      if c eq 1 then begin
        majorTickInterval = max([majorTickValues[1]-majorTickValues[0],majorTickValues[n_elements(majorTickValues)-1]-majorTickValues[n_elements(majorTickValues)-2]])
      endif
    endif else begin
      majorTickValues = [0,1]
      majorTickInterval = 1
    endelse
  endif else begin
    majorTickValues = [0,1]
    majorTickInterval = 1
  endelse
  
  fail = 0
  
   
end

;This routine takes generates the minor ticks for the z-axis and the xy axes.
;It does most of the work to guarantee proper spacing of minor ticks on logarithmic axes
;Inputs:
;  Range:  The range of the data values.(log applied, not real)
;  Scaling: The scaling factor used on this axis. (O: Linear, 1: Log10, 2:LogN)
;  MinorNum: The requested number of minor ticks per major tick
;  MajorValues: An array of major tick positions, normalized relative to their respective axis.  Minimum 2 major ticks. 
;  MajorSpacing:  The spacing between major ticks, in normalized units.
;  MinorAuto: Whether automatic minor ticks are being used or not.
; 
;Outputs:
;  MinorValues: An array of minor tick positions.  Not for a single major tick, but for the entire axis.
;  Fail: 0 indicates no fail, 1 indicates fail.  If no ticks can fit on axis, failure is indicated.
;
;NOTES:
;  Minor ticks will appear to be more evenly spaced the smaller the interval is between ticks on a logarithmic axis.
;  On a non-log axis, they will always be evenly spaced.
;
;
pro thm_ui_draw_object::makeMinorTicks,range,scaling,minorNum,majorValues,majorSpacing,logMinorTickType,minorValues=minorValues,fail=fail

  compile_opt idl2
  
  fail = 1
  tolerance = .01
  
  ;blank the minor tickValues, to prevent any inadvertent interaction
  undefine,minorValues

  majorNum = n_elements(majorValues)
    
  n = minorNum+1
  
  if n * majorNum gt self.maxTickNum * 2 then begin
    self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n*majorNum),/remove_all) + ' minor ticks.  Draw operation failed.'
    self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(n*majorNum),/remove_all) + ' minor ticks.  Draw operation failed.'
    fail = 1
    return
  endif
  
  majorValue1 = (majorValues[0] + range[0]/(range[1]-range[0]))*(range[1]-range[0])
  majorValue2 = (majorValues[1] + range[0]/(range[1]-range[0]))*(range[1]-range[0])
    
  if scaling eq 1 then begin
    base = 10d
  endif else begin
    base = exp(1)
  endelse
    
  if scaling eq 0 || logMinorTickType eq 3 then begin
    minorValues = (dindgen(n)*(1D/n))*majorSpacing
  endif else if logMinorTickType eq 1 || logMinorTickType eq 2 then begin
  
    if logMinorTickType eq 1 then begin
      deLogMajorValue1 = base^majorValue1
      deLogMajorValue2 = base^(majorValue1+1)
    endif else if logMinorTickType eq 2 then begin
      deLogMajorValue1 = base^(majorValue2-1)
      deLogMajorValue2 = base^(majorValue2)
    endif
    
    minorValues = (dindgen(n+1)/(n))*(deLogMajorValue2-deLogMajorValue1) + deLogMajorValue1
    
    idx = where(minorValues ge base^majorValue1 and minorValues le base^majorValue2,c)
       
    if c eq 0 then begin
      minorValues = [base^majorValue1,base^majorValue2]
      n=1
    endif else begin
      minorValues = minorValues[idx]
      
      if minorValues[0] gt ((base^majorValue1)+(base^majorValue2-base^majorValue1)*tolerance) then begin
        minorValues = [base^majorValue1,minorValues]
      endif
      
      if minorValues[n_elements(minorValues)-1] lt ((base^majorValue2)-(base^majorValue2-base^majorValue1)*tolerance) then begin
        minorValues = [minorValues,base^majorValue2]
      endif
                    
      n = (n_elements(minorValues)-1 < n)
    endelse  
    
   ; print,minorValues
    
    if scaling eq 1 then begin
      minorValues = alog10(minorValues)
    endif else begin
      minorValues = alog(minorValues)
    endelse
  
    minorValues = majorSpacing*((minorValues[0:n]) - majorValue1)/(majorValue2-majorValue1)
  
  endif else begin
  
    minorValues = alog10(10*dindgen(n+2)/(n+1)+1)*(majorValue2-majorValue1)/(range[1]-range[0]) 

  endelse
  
  minorInd1 = lindgen((majorNum+1)*(n)) / long(n)
  minorInd2 = lindgen((majorNum+1)*(n)) mod long(n)
  
  minorValues = majorValues[minorInd1]+minorValues[minorInd2]
  
  idx = where(minorValues lt 1. and minorValues gt 0.,c)

  if c gt 0 then begin
    minorValues = minorValues[idx]
    fail = 0
  endif else begin
    minorValues = minorValues[0]
    fail = 1
  endelse
  
  return

end
                        
;Constructs an X or Y axis model from a thm_ui_axis_settings object
;Inputs:
;dir = direction of the axis(0=x,1=y)
;xrange,yrange: data range of the panel
;scaling: scaling mode of the panel 0(linear),1(log10),2(logN)
;axisSettings: axis settings object
;plotDim1: normalized length of the plot on the dimension perpendicual to the axis
;plotDim2: normalized length of the plot on the dimension parallel to the axis
;color: The color of the plot frame in RGB
;thick: The thickness of the plot frame/ticks
;useIsTime: use this keyword to override the current isTime value
;Outputs
;gridmodel: the model containing any axis grids
;model: the axis model is returned in this keyword
;majorTickValues:the major tickvalues are returned in this keyword
;numMinorTicks: the number of minor ticks is returned in this keyword
;isTimeAxis: flag indicating whether the axis is time annotated or not returned in this keyword
;labelPos: this keyword returns the most distant label position from the axis
;fail: 1 indicates failure, 0 success
pro thm_ui_draw_object::makeXYAxisModel, $
                                    dir,$
                                    xrange,$
                                    yrange,$
                                    scaling,$
                                    axisSettings,$
                                    plotDim1,$
                                    plotdim2,$
                                    color,$
                                    thick,$
                                    bgcolor,$
                                    useIstime=useIsTime,$
                                    gridmodel=gridmodel,$
                                    model=model,$
                                    majors=majorTickValues,$
                                    minorNum=numMinorTicks,$
                                    isTimeAxis=isTimeAxis,$
                                    labelPos=labelPos,$
                                    fail=fail

  compile_opt idl2
  
  fail = 1
  
  noMajor = 0
  noMinor = 0
  
  numMinorTicks = 0
  
  ;how close to edge of axis before annotation not drawn
  annotateEdgeMargin = .01
  ;how close to edge of axis before grid not drawn
  gridEdgeMargin = .01 
  
  axisSettings->getProperty,$
    annotateOrientation=annotateOrientation,$
    placeAnnotation=placeAnnotation,$
    annotateAxis=annotateAxis,$
    isTimeAxis=isTimeAxis,$
    annotateMajorTicks=annotateMajorTicks,$
    annotateFirstTick=annotateFirstTick,$
    annotateLastTick=annotateLastTick,$
    annotateStyle=annotateStyle,$
    annotateTextObject=annotateTextObject,$
    annotateExponent=annotateExponent,$
    majorTickAuto=majorTickAuto,$
    minorTickAuto=minorTickAuto,$
    firstTickAuto=firstTickAuto,$
    majorLength=majorLength,$
    minorLength=minorLength,$
    bottomPlacement=bottomPlacement,$
    topPlacement=topPlacement,$
    tickStyle=tickStyle,$
    numMajorTicks=numMajorTicks,$
    numMinorTicks=numMinorTicks,$
    lineAtZero=lineAtZero,$
    majorGrid=majorGrid,$
    minorGrid=minorGrid,$
    margin=margin,$
    showLabels=showLabels,$
    labels=labels,$
    orientation=orientation,$
    stackLabels=stackLabels,$
    autoTicks=autoTicks,$
    logMinorTickType=logMinorTickType
    
  if n_elements(useIsTime) gt 0 && useIsTime ge 0 then begin
    isTimeAxis = useIsTime
  endif  

  ;don't want division operations 
  ;to fail because of wrong type
  ;so data converted to double explicitly.
  ;(these problems are probably largely gone by now)
  xrange = double(xrange)
  yrange = double(yrange)
  plotdim1 = double(plotdim1)
  
  ; xconv = [-xrange[0]/(xrange[1]-xrange[0]),1./(xrange[1]-xrange[0])]
  ; yconv = [-yrange[0]/(yrange[1]-yrange[0]),1./(yrange[1]-yrange[0])]
  

  
  ;Annotations within a distance of (roundingfactor)*(data range) of zero
  ;will be rounded to zero
  roundingfactor = 1d-15
  ;The height of the axis
  axiszstack = .25D
  ;The height of the grid
  gridzstack = .07D
  ;The height of the line-at-zero
  linezstack = .08D
  ;The height of the annotations
  AnnotationDepth = .05D
  
  ;The basic tick spacing settings with any time based conversions already performed
  tickSpacing = axisSettings->getTickSpacing()
  
  location1 = [0.,0.,axiszstack]
  
  ;The tickConversion determines how much to scale the ticks to
  ;get consistent length even if aspect ratio is not 1:1
  if dir eq 0 then begin
    range = xrange
    location2 = [0.,1.,axiszstack]
    
    tickconversion = 1./(plotdim1[1]-plotdim1[0])
    
  endif else begin
    range=yrange
    location2 = [1.,0.,axiszstack]
    
    tickconversion = 1./(plotdim1[1]-plotdim1[0])
  endelse
  
  ;transform ticklength from pts to data coordinates
  majTicklen = self->pt2norm(majorLength,~dir)*tickConversion
  minTicklen = self->pt2norm(minorLength,~dir)*tickConversion
  
  model = obj_new('IDLgrModel')
  gridmodel = obj_new('IDLgrModel')
  
  ;just a dummy parameter for axis objects
  tickNum = -1

  if ~finite(range[1]) || ~finite(range[0]) then begin
    range = [0D,1D]
  endif

  ;digest all the tick settings and determine major tick positioning
  self->placeMajorTicks,$
    isTimeAxis,$
    range,$
    scaling,$
    majorTickAuto,$
    autoticks,$ 
    numMajorTicks,$
    tickSpacing[0],$
    tickSpacing[1],$
    majorTickValues=majorTickValues,$
    majorTickInterval=tickSpacingMajor,$
    minorTickNum=minorTickNumRecommended,$
    ticksFixed=ticksFixed,$
    fail=placefail
    
;  if ~keyword_set(tickSpacingMajor) then stop
    
  ;If we fail, don't draw any ticks
  if placefail then begin
    nomajor = 1
    nominor = 1
  endif
  
  numMajorTicks = n_elements(majorTickValues)
 
  ; If autoticks is on and we have a valid recommendation,
  ;use the recommended number of ticks
  if n_elements(minorTickNumRecommended) gt 0 && $
     keyword_set(autoTicks) && $
     minorTickNumRecommended ge 0 then begin
 
     numMinorTicks = minorTickNumRecommended

  endif
    
  if (numMinorTicks + 1) le 0 then begin
    ok = error_message('ERROR:  The current settings will result in the creation of less than or equal to 0 minor ticks. Draw Operation Failed',/center)
    nomajor = 1
    nominor = 1
  endif
  
  if ~nomajor && ~nominor then begin
    tickSpacingMinor = tickSpacingMajor/(numMinorTicks+1)
  endif

  if numMinorTicks eq 0 || nominor eq 1 then begin
    noMinor = 1
  endif else begin
    
    majorTickValuesForMinors = majorTickValues
    
    ;make sure we have majors running at least as far as the edges of the axis, even if these ticks are out of range
    ;any out of range minors created with this will be clipped.
    if numMajorTicks gt 2 then begin
    
      if majorTickValuesForMinors[1] - majorTickValuesForMinors[0] lt tickSpacingMajor then begin
    
        majorTickValuesForMinors[0] = majorTickValuesForMinors[1] - tickSpacingMajor 
    
      endif
    
      if numMajorTicks gt 2 && majorTickValuesForMinors[numMajorTicks-1] - majorTickValuesForMinors[numMajorTicks-2] lt tickSpacingMajor then begin
    
        majorTickValuesForMinors[numMajorTicks-1] = majorTickValuesForMinors[numMajorTicks-2] + tickSpacingMajor 
    
      endif
    
      ;Add some extra ticks to ensure there isn't blank on the edge of the panel
    
      majorTickValuesForMinors = [majorTickValuesForMinors[0] - tickSpacingMajor,majorTickValuesForMinors,majorTickValuesForMinors[n_elements(majorTickValuesForMinors)-1]+tickSpacingMajor]
    
    endif
    
    self->makeMinorTicks,range,scaling,numMinorTicks,majorTickValuesForMinors,tickSpacingMajor,logMinorTickType,minorValues=minorTickValues,fail=fail
    
    if fail then begin
      nominor = 1
    endif
  
  endelse
  
  ;this check is probably redundant with other checks.  
  if (n_elements(majorTickValues) gt self.maxTickNum ||  n_elements(minorTickValues) gt self.maxTickNum*2) && (noMinor eq 0 && noMajor eq 0) then begin
    ok = error_message('ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(majorTickValues)),/remove_all) + ' major ticks and ' + strcompress(string(n_elements(minorTickValues)),/remove_all) + ' minor ticks.  Draw operation failed.',/center)
    nomajor = 1
    nominor = 1
  endif

  ;Create an axis objects.
  ;Because IDL doesn't allow the degree of control
  ;that the options in the gui spec require. The 
  ;axis is generated by layering several simpler IDLgrAxis
  ;objects on top of each other, and controlling their
  ;settings explicitly so that it gives the appearance of
  ;a single axis.

  ;majorTicks
  if topPlacement then topTickLen = majTickLen else topTickLen = 0.
  
  if bottomPlacement then bottomTickLen = majTickLen else bottomTickLen = 0.
  
  if ~noMajor then begin
  
    ;outside ticks
    if tickStyle eq 1 || tickStyle eq 2 then begin
    
      ;bottom axis
      majorAxis1 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location1,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = bottomTickLen, $
        tickDir=1,$
        minor=0,$
        subticklen=0.0,$
        major=tickNum,$
        tickValues=majorTickValues)
        
      ;top axis
      majorAxis2 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location2,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = topTickLen, $
        tickDir=0,$
        minor=0,$
        subticklen=0.0,$
        major=ticknum,$
        tickValues=majorTickValues)

      model->add,majorAxis1    
      model->add,majorAxis2
      
    endif
    
    ;inside ticks
    if tickStyle eq 0 || tickStyle eq 2 then begin
    
      ;bottom axis
      majorAxis1 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location1,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = bottomTickLen, $
        tickDir=0,$
        minor=0, $
        subticklen=0.0,$
        major=ticknum,$
        tickValues=majorTickValues)
        
      ;top axis
      majorAxis2 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location2,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = topTickLen, $
        tickDir=1,$
        minor=0,$
        subticklen=0.0,$
        major=ticknum,$
        tickValues=majorTickValues)
        
      model->add,majorAxis1
      
      model->add,majorAxis2
      
    endif
  endif else begin ;no major ticks
  
    ;bottom axis
    majorAxis1 = OBJ_NEW('IDLgrAxis',dir,$
      range=[0D,1D],$
      location=location1,$
      color=self->convertColor(color),$
      thick=thick,$
      subticklen=0.0,$
      /exact,$
      /notext,$
      minor=0,$
      major=0)
      
    ;top axis
    majorAxis2 = OBJ_NEW('IDLgrAxis',dir,$
      range=[0D,1D],$
      location=location2,$
      color=self->convertColor(color),$
      thick=thick,$
      /exact,$
      /notext,$
      subticklen=0.0,$
      minor=0,$
      major=0)
      
    model->add,majorAxis1
    
    model->add,majorAxis2
    
  endelse
  
   ;minorTicks
  
  if topPlacement then topTickLen = minTickLen else topTickLen = 0.
  
  if bottomPlacement then bottomTickLen = minTickLen else bottomTickLen = 0.
  
  if ~noMinor then begin
  
    ;outside ticks
    if tickStyle eq 1 || tickStyle eq 2 then begin
    
      ;bottom axis
      minorAxis1 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location1,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = bottomTickLen, $
        tickDir=1,$
        minor=0,$
        subticklen=0.0,$
        major=ticknum,$
        tickValues=minorTickValues)
        
      ;top axis
      minorAxis2 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location2,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = topTickLen, $
        tickDir=0,$
        minor=0,$
        subticklen=0.0,$
        major=ticknum,$
        tickValues=minorTickValues)
      
      model->add,minorAxis1
      model->add,minorAxis2
      
    endif
    
    ;inside ticks
    if tickStyle eq 0 || tickStyle eq 2 then begin
    
      ;minorTickValues = minorTickValues[0:n_elements(minorTickValues)-3]
    
      ;bottom axis
      minorAxis1 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location1,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = bottomTickLen, $
        tickDir=0,$
        minor=0, $
        subticklen=0.0,$
        major=ticknum,$
        tickValues=minorTickValues,$
        log=log)
        
      ;top axis
      minorAxis2 = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=location2,$
        color=self->convertColor(color),$
        thick=thick,$
        /exact,$
        /notext,$
        tickLen = topTickLen, $
        tickDir=1,$
        minor=0,$
        subticklen=0.0,$
        major=ticknum,$
        tickValues=minorTickValues)
        
      model->add,minorAxis1
;      
      model->add,minorAxis2
      
    endif
  endif
  
  ;perform annotation on Axis
  if annotateAxis then begin
  
    noAnno = 0
  
    if range[1] eq range[0] && ~annotateMajorTicks then begin
      self.statusBar->update,'Max and Min range are the same: Annotating major ticks.'
      self.historyWin->update,'Max and Min range are the same: Annotating major ticks.'
      annotateMajorTicks=1
    endif
  
    if annotateMajorTicks then begin
      if ~noMajor then begin
        majorAxis1->getProperty,tickValues=annotateValues
      endif else begin
        noAnno = 1
        annotateValues = [0,1]
        self.historyWin->update,'Cannot annotate major ticks, because no major ticks being drawn'
      endelse
    endif else begin
    
    
      if tickSpacing[3] gt range[1] then begin
        self.statusBar->update,'"Align Annotations At:" is larger than maximum range.  No annotations will be drawn.'
        self.historyWin->update,'"Align Annotations At:" is larger than maximum range.  No annotations will be drawn.'
        annotateValues = [0,1]
        noAnno = 1
      endif else if tickSpacing[4] le 0 then begin
        self.statusBar->update,'"Annotate Every" is less than 0.  No annotations will be drawn.'
        self.historyWin->update,'"Annotate Every" is less than 0.  No annotations will be drawn.'
        annotateValues = [0,1]
        noAnno = 1
      endif else if tickSpacing[4] gt (range[1]-range[0]) then begin
        self.statusBar->update,'"Annotate Every" is greater than range span.  No annotations will be drawn.'
        self.historyWin->update,'"Annotate Every" is greater than range span.  No annotations will be drawn.'
        annotateValues = [0,1]
        noAnno = 1
      endif else begin

        annotateStart = tickSpacing[3]
        annotateInterval = tickSpacing[4]
  
        ;first shift annotate start so that it is slightly less than
        ;the min range, but still a multiple of the original value
        if annotateStart lt range[0] then begin
        
          annotateStartNum = floor((range[0] - annotateStart) / annotateInterval,/l64)
          annotateStart += annotateStartNum*annotateInterval
        
        endif else begin
          annotateStartNum = floor((annotateStart - range[0]) / annotateInterval,/l64) + 1
          annotateStart -= annotateStartNum*annotateInterval
        endelse
   
        annotateNum = floor((range[1] - annotateStart) / annotateInterval,/l64)
        
        ;normalize values
        annotateStart = (annotateStart - range[0]) / (range[1]-range[0])
        annotateInterval = annotateInterval/(range[1]-range[0])
         
        if annotateNum gt self.maxTickNum then begin
          self.statusBar->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(annotateNum),/remove_all) + ' annotations.  Draw operation failed.'
          self.historyWin->update,'ERROR:  The current settings will result in the creation of ' + strcompress(string(annotateNum),/remove_all) + ' annotations.  Draw operation failed.'
          return
        endif
        
        annotateValues = dindgen(annotateNum + 2) * annotateInterval + annotateStart
                
        idx = where(annotateValues ge annotateEdgeMargin and annotateValues le (1-annotateEdgeMargin),c)
        
        if c gt 0 then begin
          annotateValues = [0,annotateValues[idx],1]
        endif else begin
          annotateValues = [0,1]
        endelse
        
      endelse  
          
    endelse
    
    if ~annotateLastTick && ~noAnno then begin
      if n_elements(annotateValues) eq 1 then begin
        noAnno = 1
      endif else begin
        annotateValues = annotateValues[0:n_elements(annotateValues)-2]
      endelse
    endif
  
    if ~annotateFirstTick && ~noAnno then begin
      if n_elements(annotateValues) eq 1 then begin
        noAnno = 1
      endif else begin
        annotateValues = annotateValues[1:*]
      endelse
    endif
    
    if ~noAnno then begin
    
      ;Check if there are too many annotations.
      if n_elements(annotateValues) gt self.maxTickNum then begin
        ok = error_message('ERROR:  The current settings will result in the creation of ' + strcompress(string(n_elements(annotateValues)),/remove_all) + ' annotations.  Draw operation failed.',/center)
        return
      endif
      
      data = {timeAxis:isTimeAxis,formatid:AnnotateStyle,scaling:scaling,range:range,exponent:annotateExponent}
      
      if placeAnnotation eq 1 then begin
        annoPos = 1
      endif else begin
        annoPos = 0
      endelse
      
      if tickStyle eq 1 || tickStyle eq 2 then begin
        AnnoColor = bgcolor ; the color to draw the axis so that it won't be visible
        ;we draw real but invisible ticks so that the annotations will be shifted out of the way of collision with the ticks
        if placeAnnotation eq 1 then begin
          AnnoDir = 0
          AnnoLoc = location2
          AnnoLen = topTickLen
        endif else begin
          AnnoDir = 1
          AnnoLoc = location1
          AnnoLen = bottomTickLen
        endelse
      endif else if tickStyle eq 0 then begin
        AnnoColor = color
        AnnoLen = 0 ;when ticks are only on the inside, ticklength can be 0, because there is no need to shift the annotations down.w
        if placeAnnotation eq 1 then begin
          AnnoDir = 1
          AnnoLoc = location2
        endif else begin
          AnnoDir = 0
          AnnoLoc = location1
        endelse
      endif else begin
        self.statusBar->update,'Error: Illegal tickstyle'
        ;ok = error_message('Illegal tickstyle',/traceback)
        return
      endelse
      
      if annotateOrientation eq 1 then begin
        annoBaseLine = [0,1,0]
        annoUpDir = [-1,0,0]
        if dir eq 1 then begin
          if annoPos eq 0 then begin
            annoAlign = [.5,0.]
          endif else begin
            annoAlign = [.5,1.]
          endelse
        endif else begin
          if AnnoPos eq 0 then begin
            annoAlign = [1.,.5]
          endif else begin
            annoAlign = [0.,.5]
          endelse
        endelse
      endif else begin
        annoBaseLine = [1,0,0]
        annoUpDir = [0,1,0]
      ;annoAlign = [1.,-.5]
      endelse
      
      labFont = annotateTextObject->getGrFont()
      
      annoLoc[2] = AnnotationDepth
      
      annotateTextObject->getProperty,color=labcolor,size=size
      
      if size le 0 then begin
        size = 1D
        fontshow = 0
      endif else begin
        fontshow = 1
      endelse
      
      labFont->setProperty,size=self->getZoom()*size
      
      ; labFont->setProperty,size=self->getZoom()*size
      
      
      if ticksFixed then begin
        data.exponent = 2   
      ;determine is any ticks are going to be auto-shifted into exponential
      ;if yes, make them all exponential, this guarantees that any annotations
      ;on a particular axis will use the same size
      endif else if ~isTimeAxis && data.exponent eq 0 && (scaling eq 0 || scaling eq 1) then begin
        for i = 0,n_elements(annotateValues)-1 do begin
        
          if data.range[1]-data.range[0] eq 0 then begin
            val = data.range[0]
          endif else begin
            val = (annotateValues[i] + data.range[0]/(data.range[1]-data.range[0]))*(data.range[1]-data.range[0])
              relativecuttoff = (data.range[1]-data.range[0])*roundingfactor
              if val le relativecuttoff && val ge -relativecuttoff then begin
                val = 0
              endif
          endelse
          
          if scaling eq 1 then begin
            val = 10^val
          endif
          
          thm_ui_usingexponent,val,data,type=type
          
          if type ne 0 && scaling eq 0 then begin
            data.exponent = 2
            break
          endif else if type ne 0 && scaling eq 1 then begin
            data.exponent = 3
            break
          endif
        endfor
      endif

      annaxis = OBJ_NEW('IDLgrAxis',dir,$
        range=[0D,1D],$
        location=AnnoLoc,$
        alpha_channel = 1.0,$
        thick=thick,$
        color=AnnoColor,$
        /exact,$
        tickLen = AnnoLen, $
        tickDir=AnnoDir,$
        textPos=AnnoPos,$
        minor=0,$
        subticklen=0.0,$
        major=-1,$
        tickValues=annotateValues,$
        /use_text_color, $
        tickfrmtdata=data,$
        tickformat='formatannotation',$
        textBaseline=annoBaseLine,$
        textupdir=annoUpDir,$
        textAlignments=annoAlign)
        
        
      annaxis->getProperty,tickText=tickObj
      
      tickObj->setProperty,font=labFont,color=self->convertColor(labcolor),alpha_channel=1.0,hide=~fontshow,/enable_formatting
      
      model->add,annaxis
      
    endif
  endif
  
 
  
  ;draw lineatzero
  if lineatzero && $
    0. gt range[0] && $
    0. lt range[1] then begin
    
    if dir eq 0 then begin
      locationx = replicate((0-range[0])/(range[1]-range[0]),2)
      locationy = [0D,1D]
    endif else begin
      locationx = [0D,1D]
      locationy = replicate((0-range[0])/(range[1]-range[0]),2)
    endelse
    
    locationz = [linezstack,linezstack]
    
    line = obj_new('IDLgrPolyline',locationx,locationy,locationz,$
      color = self->convertColor([0,0,0]),/double)
      
    model->add,line
    
  endif
  
  majorGridShow = 0 ; needed to generate minor grid
  
  ;add major grid lines
  if obj_valid(majorGrid) && obj_isa(majorgrid,'thm_ui_line_style') && ~noMajor then begin
    majorGrid->getProperty,id=gridstyle,$
      color=gridcolor,$
      show=majorgridshow,$
      thickness=gridthick,$
      opacity=opacity
      
      
    if majorgridshow && range[1] ne range[0] then begin
      ;get tick values, (may have been automatically set)
      tickValues = majorTickValues
      normGridThick = self->pt2norm(gridthick,dir)/(2D*(plotDim2[1]-plotDim2[0]))
      
      if n_elements(tickValues) gt 1 then begin
        for i = 1,n_elements(tickvalues)-1 do begin
          if dir eq 0 then begin
            gridx = [tickvalues[i],tickvalues[i]]
            gridy = [0D,1D]  
          endif else begin
            gridx = [0D,1D]
            gridy = [tickvalues[i],tickvalues[i]]      
          endelse
          
          ;it looks bad if you draw grid lines on top of frame
          if tickvalues[i] lt 0+gridEdgeMargin || tickvalues[i] gt 1-gridEdgeMargin then begin
            lineshow=0
          endif else begin
            lineshow=1
          endelse
          
          gridz = [gridzstack,gridzstack]
          
          if lineshow then begin
          
            gridline = obj_new('IDLgrPolyline',$
              gridx,gridy,gridz,alpha=opacity,$
              linestyle=gridstyle,thick=gridthick,$
              color=self->convertColor(gridColor),/double)
              
            gridmodel->add,gridline
          ;model->add,gridline
          endif
        endfor
      endif
    endif
  endif
  
  ;minor grid
  if obj_valid(minorGrid) && obj_isa(minorgrid,'thm_ui_line_style') && ~noMinor then begin
    minorGrid->getProperty,id=gridstyle,$
      color=gridcolor,$
      show=gridshow,$
      thickness=gridthick,$
      opacity=opacity
      
    if gridshow && range[1] ne range[0] then begin
      ;get tick values, (may have been automatically set)
      ;axis1->getProperty,tickValues=tickValues
    
      tickValues = minorTickValues
      
      for i = 0,n_elements(tickvalues)-1 do begin
      
        ;don't draw minor grids on major grids, if majorGrids are drawn
        if n_elements(majorTickValues) gt 0 && majorGridShow then begin
          val = min(abs(majorTickValues - tickvalues[i]))
          
          if val lt .01 then continue
          
        endif
        
        if dir eq 0 then begin
          gridx = [tickvalues[i],tickvalues[i]]
          gridy = [0D,1D]   
        endif else begin
          gridx = [0D,1D]
          gridy = [tickvalues[i],tickvalues[i]]
        endelse
        
        ;it looks bad if you draw grid lines on top of frame
        if tickvalues[i] lt 0+gridEdgeMargin || tickvalues[i] gt 1-gridEdgeMargin then begin
          lineshow=0
        endif else begin
          lineshow=1
        endelse
        
        gridz = [gridzstack,gridzstack]
        
        if lineshow then begin
          gridline = obj_new('IDLgrPolyline',$
            gridx,gridy,gridz,alpha=opacity,$
            linestyle=gridstyle,thick=gridthick,$
            xcoord_conv=xconv,ycoord_conv=yconv,$
            color=self->convertColor(gridColor),/double)
            
          gridmodel->add,gridline
        ;model->add,gridline
        endif
      endfor
    endif
  endif
  
  ; axis label

  axisSettings->getProperty,blacklabels=blacklabels
  
  self->addAxisLabels,model,labels,margin,placeAnnotation,dir,orientation,stacklabels,showlabels,self->pt2norm(1.,~dir)/(plotDim1[1]-plotDim1[0]),self->pt2norm(1.,dir)/(plotDim2[1]-plotDim2[0]),blacklabels,labelPos=labelPos
  
  fail = 0
  
end

;This routine actually draws the display, it should be called after
;any update to this function via another call.  It should also be
;called any time that there is damage to the window from opening a
;panel or after an expose_event
pro thm_ui_draw_object::draw,_extra=ex

  compile_opt idl2
  
  if ~obj_isa(self.destination,'IDLgrWindow') then begin
    self.destination->draw,self.scene,_extra=ex
  endif else begin
    self.destination->draw,self.scene,/draw_instance,_extra=ex
  endelse
  
end

;This routine creates an instance of the static components
;of any display, it also leaves only the dynamic components
;unhidden after it is complete, so the draw object is ready 
;for instance based drawing
;
;See IDL Help documentation on instances.  The short explanantion
;is that instances are used in object graphics to make draws,
;much much faster.
pro thm_ui_draw_object::createInstance

  compile_opt idl2
  
  ;instancing should only be done on window objects,
  ;but since this method is called at the end of updates,
  ;we need to be certain we don't try to instance a printer or postscript
  if obj_isa(self.destination,'IDLgrWindow') then begin
 ; if 0 then begin
  
    ;hide only the dynamic components of the image
    self->setModelHide,self.staticViews,0
    self->setModelHide,self.dynamicViews,1
    self->setLegendHide
    
    self.destination->draw,self.scene,create_instance=1
    
    ;hide only the static components of the image
    self->setModelHide,self.dynamicViews,0
    self->setModelHide,self.staticViews,1
    self->setLegendHide,/dynamic
 
    self->setCursor,self.cursorLoc
    
   ; self->draw
  
  endif
  
end

;this method will remove the instance hide settings from static components
;This is generally meant to be used by image export routines when the
;the legend is off,  if the legend is on, this method may leave the
;dynamic components of the legend hidden
pro thm_ui_draw_object::removeInstance

  compile_opt idl2
  
  self->setModelHide,self.staticViews,0
  ;hide the components of the legend if they just got turned on
  ;by the previous call
  self->setLegendHide

end

;This routine sets the hide values for all the models inside the views that it receives as an argument
;It just exists to remove some duplication that occurs when generating an instanced display
;This is a recursive function
;
;Inputs:
;  hidevalue(boolean): The value that the hide flag will be set to.
;
pro thm_ui_draw_object::setModelHide,input,hideValue

  compile_opt idl2
 
  if obj_isa(input,'IDLgrModel') then begin
    input->setProperty,hide=hideValue
  endif else if obj_isa(input,'IDL_Container') then begin
    list = input->get(/all,count=c)
  
    if c gt 0 then begin
      for i = 0,c-1 do begin
      
        self->setModelHide,list[i],hideValue
      
      endfor
    endif
  endif 
    
end

;Because the static components of the legend are still somewhat
;dynamic(Because they can be manipulated between updates), 
;This routine is needed to manipulate them separately
;From the lists in self.staticViews & self.dynamicViews
;Inputs:
;  dynamic(boolean keyword):, set to hide dynamic component of the legend
;  hide:(boolean): set to the hide value you want to use
; 
pro thm_ui_draw_object::setLegendHide,dynamic=dynamic,hide=hide

 if n_elements(hide) gt 0 then begin
   if keyword_set(hide) then begin
     hideValueDynamic = 1
     hideValueStatic = 1
   endif else begin
     hideValueDynamic = 0
     hideValueStatic = 0
   endelse 
 endif else if self.legendOn eq 1 || self.legendOn eq 2 then begin
   if keyword_set(dynamic) then begin
     hideValueStatic = 0
     hideValueDynamic = 0
   endif else begin
     hideValueDynamic = 1
     hideValueStatic = 1
   endelse
 endif else begin
   hideValueDynamic = 1
   hideValueStatic = 1
 endelse

 if ptr_valid(self.panelInfo) then begin
  
   for i = 0,n_elements(*self.panelInfo)-1 do begin
    
     panel = (*self.panelInfo)[i]
      
     if ~obj_valid(panel.legendModel) then continue
    
  ;   print,i,hidevaluestatic,hidevaluedynamic
    
     panel.legendModel->setProperty,hide=hideValueStatic
     panel.legendAnnoModel->setProperty,hide=hideValueDynamic
    
     self->setVarHide,panel,hideValueDynamic
      
   endfor
    
  endif

end

;This routine sets the hide value for variables on a panel with
;a particular index.  It is mainly here for organization and to prevent duplication
;
;Inputs:
;  hidevalue(boolean): The value that the hide flag will be set to.
;
pro thm_ui_draw_object::setVarHide,panel,hideValue

  if ptr_valid(panel.varInfo) then begin
  
     for j = 0,n_elements(*panel.varInfo)-1 do begin
        var = (*panel.varInfo)[j]
        
        if obj_valid(var.textObj) then begin
          var.textObj->setProperty,hide=hideValue
        endif
     endfor
    
   endif

end

;start drawing a vertical bar on one or all panels
;Inputs:
;  all(boolean keyword):  Set to turn on for all panels.
;                         Default is for single panel mode
;
pro thm_ui_draw_object::vBarOn,all=all

  compile_opt idl2
  
  if keyword_set(all) then begin
    self.vBarOn = 2
  endif else begin
    self.vBarOn = 1
  endelse
  
end

;stop drawing a vertical bar
pro thm_ui_draw_object::vBarOff

  compile_opt idl2
  
  self.vBarOn = 0
  
  ;hide vbar
  
  if ptr_valid(self.panelInfo) then begin
  
    for i = 0,n_elements(*self.panelInfo)-1 do begin
    
    
      vBar = ((*self.panelInfo)[i]).vBar
      old = vBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      vBar->remove,/all
      
    endfor
    
  endif
  
  self->draw
  
end

;start drawing the horizontal bar
;  all(boolean keyword):  Set to turn on for all panels.
;                         Default is for single panel mode
pro thm_ui_draw_object::hBarOn,all=all

  compile_opt idl2
  
  if keyword_set(all) then begin
    self.hBarOn = 2
  endif else begin
    self.hBarOn = 1
  endelse
  
end

;stop drawing the horizontal bar
pro thm_ui_draw_object::hBarOff

  compile_opt idl2
  
  self.hBarOn = 0
  
  ;hide vbar
  
  if ptr_valid(self.panelInfo) then begin
  
    for i = 0,n_elements(*self.panelInfo)-1 do begin
    
    
      hBar = ((*self.panelInfo)[i]).hBar
      old = hBar->get(/all)
      if obj_valid(old) then obj_destroy,old
      hBar->remove,/all
      
    endfor
    
  endif
  
  self->draw
  
end


;Start drawing a legend on one or more panels
;  all(boolean keyword):  Set to turn on for all panels.
;                         Default is for single panel mode
pro thm_ui_draw_object::legendOn,all=all

  compile_opt idl2
  
  if keyword_set(all) then begin
    self.legendOn = 2
  endif else begin
    self.legendOn = 1
  endelse
  
  self->setCursor,self.cursorLoc
  
  ;self->createInstance
  
  self->draw
  
end

;Stop drawing the legend
pro thm_ui_draw_object::legendOff

  compile_opt idl2
  
  self.legendOn = 0
  
  self->setCursor,self.cursorLoc 
  
 ; self->createInstance
  
  self->draw
  
end

;starts drawing a new marker at the current location
;'default' is a marker object from which the marker defaults will be copied
;'all' indicates that markers should be drawn on all panels
;note that markerOn can fail if the current location isn't within the
;boundaries of a panel.  The 'fail' keyword indicates this
pro thm_ui_draw_object::markerOn,default=default,all=all,fail=fail

  compile_opt idl2
  
  fail = 1
  
  self.markerStart = self.cursorLoc
  
  if ~ptr_valid(self.panelInfo) then return
  
  panels = *self.panelInfo
  
  inBounds = 0
  
  ;only activate if the start location is in bounds of the panel
  for i = 0,n_elements(panels)-1 do begin
  
    if self->inBounds(panels[i]) then begin
      inbounds = 1
      panel = i
    endif
    
  endfor
  
  if ~inBounds then return
  
  if ~keyword_set(all) then begin
    self.markerOn = 1
    
    ;create the new marker, if no default settings are specified, uses thm_ui_marker
    
    if ~keyword_set(default) || ~obj_valid(default) then begin
      marker = [obj_new('thm_ui_marker')]
    endif else begin
      marker = [default->copy()]
    endelse
    
    panelIdx = [panel]
  endif else begin
  
    self.markerOn = 2
    marker = objarr(n_elements(*self.panelInfo))
    
    panelIdx = indgen(n_elements(*self.panelInfo))
    
    ;create new markers for each panel, if no default settings are specified, uses thm_ui_marker for determining defaults
    for i = 0,n_elements(marker)-1 do begin
      if ~keyword_set(default) || ~obj_valid(default) then begin
        marker[i] = obj_new('thm_ui_marker')
      endif else begin
        marker[i] = default->copy()
      endelse
    endfor
    
  endelse
  
  ;destroy old markers
  if ptr_valid(self.currentMarkers) then begin
    obj_destroy,*self.currentMarkers
    ptr_free,self.currentMarkers
    ptr_free,self.markerIdx
  endif
  
  ;replace with new values
  self.currentMarkers = ptr_new(marker)
  self.markerIdx = ptr_new(panelIdx)
  
  fail = 0
  
end

;stops drawing the marker
pro thm_ui_draw_object::markerOff

  compile_opt idl2
  
  self.markerOn = 0
  
  if ptr_valid(self.panelInfo) then begin
  
    panels = *self.panelInfo
    
    for i = 0,n_elements(panels)-1 do begin
    
      self->drawMarker,[0,1],panels[i],obj_new(),/remove
      
    endfor
    
  endif
  
;hide marker
  
end

;Starts drawing the rubber band at the current location
pro thm_ui_draw_object::rubberBandOn

  compile_opt idl2
  
  self.rubberOn = 1
  self.rubberStart = self.cursorLoc
  
  if ~self->rubberBand(self.rubberStart,[0.,0.]) then begin
    self.statusBar->update,'Error: Problem drawing rubber band'
  ;t=error_message('Problem drawing rubber band',/traceback)
  endif
  
  self->draw
  
end

;Stops drawing the rubber band
pro thm_ui_draw_object::rubberBandOff

  compile_opt idl2
  
  self.rubberOn = 0
  
  if ~self->rubberBand(self.rubberStart,self.cursorLoc - self.rubberStart,/hide) then begin
    self.statusBar->update,'Error: Problem drawing rubber band'
  ; t=error_message('Problem drawing rubber band',/traceback)
  endif
  
  self->draw
  
end

;for making a rubber band.  This thing actually manipulates the
;draw tree to move the rubber band around according to the current cursor position
;location is the location in draw-area normalized coordinates [x,y]
;dimensions is the dimensions in draw-area normalized coordinates [xsize,ysize]
function thm_ui_draw_object::rubberBand,location,dimensions,hide=hide

  compile_opt idl2
  
  ;default stacking height
  zstack=.7
  
  ;If no rubber band view exists, create one
  if ~obj_valid(self.rubberview) then begin
  
    rubberview = obj_new('IDLgrView')
    self.rubberview = rubberview
    rubberview->setProperty,units=3,viewplane_rect=[0.,0.,1.,1.],location=[0.,0.],dimensions=[1.,1.],zclip=[1.,-1.],eye=5,name="rubberview",/transparent,/double
    self.scene->add,rubberview
    
  endif
  
  ;remove all models from old view
  old = self.rubberview->get(/all)
  if obj_valid(old) then obj_destroy,old
  self.rubberview->remove,/all
  
  model = obj_new('IDLgrModel')
  
  self.rubberview->add,model
  
  ;create a new polyline at the requested location and add it to the model
  xlocs = [location[0],location[0]+dimensions[0],location[0]+dimensions[0],location[0],location[0]] > 0. < 1.
  ylocs = [location[1],location[1],location[1]+dimensions[1],location[1]+dimensions[1],location[1]] > 0. < 1.
  zlocs = replicate(zstack,5)
  
  rubberband = obj_new('IDLgrPolyline',xlocs,ylocs,zlocs,hide=hide,/double)
  
  model->add,rubberband
  
  return,1
  
end

;Set a couple of properties related to drawing
;Mainly used to perform output to other devices
;
;Destination:
;  The target to which draws will be made.  
;  Some parameters used in updated are also drawn from the destination.
;  This should be some sort of IDLgr* destination object.
;
;LineRes: 
;  The resolution at which lines will be drawn.  
;  Ideally, this is a scalar multiple of the current screen resolution.
;  (ie plot with 500 pixel width, and lineRes 2 will send 1000 points to the output destination)
;  Line resolution modification is currently limited by aliasing issues. So it is ignored in the current version
;  and all line plots send every point to the output destination.
;  
;SpecRes:
;  The resolution at which spectral plots will be drawn. 
;  SpecRes is a multiple of screen resolution.  If specRes is 2
;  and a plot has a screen resolution of 400x300 pixels, a spectral
;  plot of 800x600 will be output to the destination.
;  
;HistoryWin:
;  The history object that the draw object sends its history output to.
;
;statusBar:
;  The status bar object that the draw object sends status messages to.
;  
;fancompressionfactor:
;  The percentage error to be applied to the fancompression algorithm during postscript plotting.
;  0 = No compression
;
pro thm_ui_draw_object::setProperty,destination=destination,lineres=lineres,specres=specres,historyWin=historyWin,statusBar=statusBar,fancompressionfactor=fancompressionfactor

  compile_opt idl2
  
  if n_elements(destination) gt 0 then begin
    if ~obj_valid(destination) then begin
      self.statusBar->update,'Error: Invalid destination object passed to thm_ui_draw_object'
      ;t=error_message('Invalid destination object passed to thm_ui_draw_object',/traceback)
      return
    endif else begin
      ;self->removeInstance
      self.destination = destination
      ;self->createInstance
    endelse
  endif
  
  if n_elements(lineres) gt 0 then begin
    self.lineres=lineres
  endif
  
  if n_elements(specres) gt 0 then begin
    self.specres = specres
  endif

  if n_elements(historyWin) && obj_valid(historyWin) then begin
    self.historyWin = historyWin
  endif

  if n_elements(statusBar) && obj_valid(statusBar) then begin
    self.statusBar = statusBar
  endif
  
  if n_elements(fancompressionfactor) gt 0 then begin
    self.fancompressionfactor = fancompressionfactor
  endif
end

;Query various draw object settings
pro thm_ui_draw_object::getProperty, $
    destination=destination, $
    markerOn=markerOn, $
    legendOn=legendOn, $
    rubberOn=rubberOn, $
    vBarOn=vBarOn, $
    hBarOn=hBarOn, $
    pageSize=pageSize,$
    lineres=lineres,$
    specres=specres
    
  compile_opt idl2
  
  destination = self.destination
  markerOn = self.markerOn
  legendOn = self.legendOn
  rubberOn = self.rubberOn
  vBarOn = self.vBarOn
  hBarOn = self.hBarOn
  pageSize = self.currentpageSize
  lineres = self.lineres
  specres = self.specres
  
end

;This rotates the hue of of the input color by 120 degrees
;The output is the rotated color 
function thm_ui_draw_object::hueRotation,color

  compile_opt idl2
  
  color_convert,color[0],color[1],color[2],hue,light,sat,/rgb_hls
  hue = (hue + 120) mod 360
  light = 1 - light
  color_convert,hue,light,sat,red,grn,blu,/hls_rgb
  return,[red,grn,blu]
  
end

;this routine converts between True color and indexed color
;depending upon which color mode is set by the window
;if keyword: backwards is set, the routine will return a 1x3 array,
;Which may be useful in some applications.
function thm_ui_draw_object::convertColor,color,backwards=backwards

  compile_opt idl2
  
  self.destination->getProperty,palette=pal,color_model=col
  
  if col eq 1 && n_elements(color) eq 1 then return,color
  
  if col eq 0 && n_elements(color) eq 3 then begin
    if (keyword_set(backwards) && size(color,/n_dim) eq 2) || $
      (~keyword_set(backwards) && size(color,/n_dim) eq 1) then begin
      return,color
    endif
    
    if (keyword_set(backwards) && size(color,/n_dim) eq 1) || $
      (~keyword_set(backwards) && size(color,/n_dim) eq 2) then begin
      return,transpose(color)
    endif
  endif
  
  ;If we don't have a valid palette object,
  ;Use the command line color table.
  if ~obj_valid(pal) then begin
    tvlct,r,g,b,/get
    
    pal = obj_new('IDLgrPalette',r,g,b)
    
    self.destination->setProperty,palette=pal
  endif
  
  if n_elements(color) eq 1 then begin
    if keyword_set(backwards) then begin
      return,transpose(pal->getRGB(color))
    endif else begin
      return,pal->getRGB(color)
    endelse
  endif
  
  if n_elements(color) eq 3 then begin
    return,pal->nearestcolor(color[0],color[1],color[2])
  endif
  
  self.statusBar->update,'Error: Invalid color argument passed to thm_ui_draw_object'
  ;t=error_message('Invalid color argument',/traceback)
  return,-1
  
end

;Convert pts into draw area normal coordinates.
;Inputs:
;  Value(numeric type, or array of numeric types): the point value(s) to be converted
;  xy(boolean):  0: convert for x-axis, 1 convert for y-axis.(because screen dims differ, axis must be specified)
;  
;Returns, the value in normalized coordinates
;
function thm_ui_draw_object::pt2norm,value,xy

  compile_opt idl2
  
  pt2mm = 127D/360D
  mm2cm = .1D
  
  v = value*pt2mm*mm2cm
  
  dim = self->getDim()
  
  self.destination->getProperty,resolution=r
  
  dim /= self->getZoom()
  
  return,v/(r[xy]*dim[xy])
  
end

;converts back from the normalized value into points,
;While the normalized value is dependent on screen dimensions
;zoom, & resolution.  The value in points should be an
;absolute quantity
;
;Inputs:
;  Value(numeric or array of numerics):  A value in screen normal coords
;  xy(boolean) 0 : convert from x-axis, 1:convert from y-axis(because screen dims differ, axis must be specified)
;
function thm_ui_draw_object::norm2pt,value,xy

  compile_opt idl2
  
  pt2mm = 127D/360D
  mm2cm = .1D
  
  dim = self->getDim()
  
  self.destination->getProperty,resolution=r
  
  dim /= self->getZoom()
  
  v = value*r[xy]*dim[xy]
  
  return,v/(pt2mm*mm2cm)
  
end

;calculates the panel size for the purpose of spectral plot generation
;Inputs:
;  plotdim1(2-element double): The position of the panel/plot in x-direction [xstart,xstop]
;  plotdim2(2-element double): The position of the panel/plot in the y-direction [ystart,ystop]
;
;Returns:
;  2-element double
;  xpanel_sz in points(multiple of pixels scaled to dims *not* desktop publishing points) 
;  ypanel_sz in points(multiple of pixels scaled to dims *not* desktop publishing points) 
function thm_ui_draw_object::getPlotSize,plotdim1,plotdim2,res_factor

  compile_opt idl2
  
  dim = self->getDim()
  
  dim /= self->getZoom()
  
  if max(dim,sub) gt self.pointmax then begin
    if sub eq 0 then begin
      dim[1] = ceil(self.pointmax*dim[1]/dim[0])
      dim[0] = self.pointmax
    endif else begin
      dim[0] = ceil(self.pointmax*dim[0]/dim[1])
      dim[1] = self.pointmax
    endelse
  endif
  
  xpt = dim[0] * res_factor
  ypt = dim[1] * res_factor
  
  ;size of the panel in points
  xpanel_sz_pt = double(ceil(xpt * (plotdim1[1]-plotdim1[0])))
  ypanel_sz_pt = double(ceil(ypt * (plotdim2[1]-plotdim2[0])))
  
  return,[xpanel_sz_pt,ypanel_sz_pt]
  
end


;This routine returns the current zoom of the destination object
; Used primarily for determining scaling values to be applied to
; text when drawn.  IDL doesn't properly correct for zoom, unless
; an object is already rendered.  If you initially draw while at
; non 1. zoom text will be mis-sized unless scaled by zoom factor.
;
; Doesn't really apply to non-IDLgrWindow, because they don't
; have associated zoom factors.
;
function thm_ui_draw_object::getZoom

  compile_opt idl2
  
  if obj_isa(self.destination,'IDLgrWindow') then begin
    self.destination->getProperty,current_zoom=cz
  endif else begin
    cz = 1D
  endelse
  
  return, cz
  
end

;Set the zoom factor on the current destination object
;Only works if the destination is an IDLgrWindow
pro thm_ui_draw_object::setZoom,zoom

  compile_opt idl2
  
  if obj_isa(self.destination,'IDLgrWindow') then begin
    ;I suspect that there is a bug(feature?) in IDL's recompute_dimensions routine
    ;This is causing the routine to incorrectly recalculate dimensions of some of the
    ;IDLgrText based upon the current hide value of the model in which it resides.
    ;This may also be based upon whether the text has been drawn yet.    
    self->setLegendHide,hide=0
    self->draw
 
    self->setLegendHide,hide=1
    self.destination->setCurrentZoom,zoom
    self->createInstance
    
  ;  if self.legendOn eq 1 then begin
  ;  self->setLegendHide,hide=0
 ;   self->draw
   ; endif
    
    self->setCursor,self.cursorLoc
    
  endif
  
end

;This routine should blank the current contents of the object
;Generally used in the event of an error
pro thm_ui_draw_object::nukeDraw

  compile_opt idl2
  
  drawTree = self.scene->get(/all)
  self.scene->remove,/all
  
  obj_destroy,drawTree
  
  ptr_free,self.panelInfo
  
  heap_gc
  
end

;gets dimensions in pixels,
;abstracts some unit fuss
function thm_ui_draw_object::getDim

  compile_opt idl2
  
  self.destination->getProperty,units=un
  self.destination->setProperty,units=0
  self.destination->getProperty,dimensions=dim
  self.destination->setProperty,units=un
  
  return,float(dim)
  
end

;create a new draw object.
;
;destination:
;  window created by widget_draw(graphics_level=2),
;  or other IDLgrDestination object(IDLgrClipboard, IDLgrBuffer, IDLgrPrinter,...)
;  
;statusBar:
;  thm_ui_status_bar object to which status message should be sent
;  
;historyWin
;  thm_ui_historyWin object to which history messages should be sent
;
;
function thm_ui_draw_object::Init,destination,statusbar,historyWin

  compile_opt idl2
  
  if ~obj_valid(destination) then begin
    t=error_message('Invalid destination object passed to thm_ui_draw_object',/traceback)
    return,0
  endif
  
  if ~obj_valid(Statusbar) then begin
    t = error_message('Expected valid status bar',/traceback)
    return,0
  endif
  
  if ~obj_valid(historyWin) then begin
    t = error_message('Expected valid history Window',/traceback)
    return,0
  endif
  
  self.destination = destination
  self.statusbar = statusbar
  self.historyWin = historyWin
  
  self.scene = OBJ_NEW('IDLgrScene',color=[255,255,255])
  
  rubberview = obj_new('IDLgrView')
  self.rubberview = rubberview
  rubberview->setProperty,units=3,viewplane_rect=[0.,0.,1.,1.],location=[0.,0.],dimensions=[1.,1.],zclip=[1.,-1.],eye=5,name="rubberview",/transparent,/double
  self.scene->add,rubberview
  
  self.staticViews = obj_new('IDL_Container')
  self.dynamicViews = obj_new('IDL_Container')
   
  self.lineres = 4.0D
  self.specres = 1.0D
  self.pointmax = 4096
  
  self.maxTickNum = 200
  
  return,1
  
end


pro thm_ui_draw_object__define

  struct = { THM_UI_DRAW_OBJECT, $
    destination:OBJ_NEW(), $ ; The output object
    scene:OBJ_NEW(), $ ; The current scene(private)
    pageview:OBJ_NEW(), $  ; The view for the page includes the title
    panelViews:obj_new(),$ ; view group of panel views
    rubberview:OBJ_NEW(), $  ; The rubber band view
    rubberstart:dblarr(2), $ ; The starting location of a rubberband box
    markerstart:dblarr(2), $  ; The starting location of a marker draw
    cursorloc:dblarr(2), $  ; The current location of the cursor
    markerOn:0, $ ; boolean value indicating whether to draw a marker 0: no marker, 1: single panel marker, 2: all panel markers
    rubberOn:0, $ ; boolean value indicating whether to draw a rubber band
    vBarOn:0, $  ;value indicating whether to draw a vertical bar, 0 = no bar, 1 = single panel bar, 2 = all panel bar
    hBarOn:0, $  ;value indicating whether to draw a horizontal bar, 0 = no bar, 1 = single panel bar, 2 = all panel bar
    legendOn:0, $  ;value indicating whether to draw a legend, 0 = no legend, 1 = single panel legend, 2 = all panel legend
    nRows:1, $ ;number of rows in current display
    nCols:1, $ ;number of columns in current display
    panelInfo:ptr_new(), $ ;an array of structures that describe information in panels that is relevant to drawing annotations
    currentPageSize:[8.5,11], $ ; the current size of the page in inches
    currentMarkers:ptr_new(), $ ;a list of the currently/most recently drawn markers
    markerIdx:ptr_new(), $ ; a list of the marker panel indexes
    statusBar:obj_new(), $  ; reference to the status bar from the main window, for error output
    historyWin:obj_new(), $ ; reference to the history window
    postscript:0B, $  ; indicates whether or not a vector postscript is being generated
    lineres:2D, $ ; a multiplier for line plots to determine how much it is up or down sampled prior to display
    specres:1D, $ ; a multiplier for spectral plots to determine how they are up or down sampled prior to display
    fancompressionfactor:0d,$ ; percentage error to be allowed if fancompression is used during postscript plotting
    pointmax:4096, $ ; the maximum resolution at which a screen render should be made
    staticViews:obj_new(), $ ; This view group contains all visual components that change only during updates
    dynamicViews:obj_new(), $ ; This view group contains all visual components that change between updates and during updates
    maxTickNum:200 $ The maximum tick limit before a warning is issued
    }
;margins:dblarr(5) } ; The [left,right,top,bottom,internal] margins in normalized coordinates
    
end


