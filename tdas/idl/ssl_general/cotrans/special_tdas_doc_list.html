<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>ssl_general/cotrans/special</TITLE>
</head>
 
<body>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help2</CODE>.
<br>
<P>
<STRONG>Last modified: </STRONG>Wed Apr 14 11:49:06 2010.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>Directory Listing of Routines</H1></A>
<UL>
<H1>ssl_general/cotrans/special</H1>
<LI><A HREF="#TCROSSP">TCROSSP</A>
<LI><A HREF="#TDOTP">TDOTP</A>
<LI><A HREF="#TINTERPOL_MXN">TINTERPOL_MXN</A>
<LI><A HREF="#TNORMALIZE">TNORMALIZE</A>
<LI><A HREF="#TVECTOR_ROTATE">TVECTOR_ROTATE</A>
<br>
</UL><P>
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="TCROSSP">
<H2>TCROSSP</H2></A>
<A HREF="#TDOTP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PROCEDURE: TCROSSP
Purpose:
  Vectorized routine to calculate the cross product of two tplot
  variables containing arrays of 3d vectors and storing the result
  in a tplot variable.  Also, can perform vectorized cross product on
  arrays.

Arguments: 
 v1: The name of the tplot variable  or an Nx3 length array storing the first vector in the cross product
    
 v2: The name of the tplot variable or an Nx3 length array storing the second vector in the
     cross product 
 
 newname(optional): the name of the output tplot variable

 error(optional): named variable in which to return error state of
 the computation.  1 = success 0 = failure
 
 Outputs(optional):
   out:
     Returns output in array format, if this argument is present, no tplot variable will be created

NOTES: 
</PRE><P>
<STRONG>(See <A href="special/tcrossp.pro">ssl_general/cotrans/special/tcrossp.pro</A>)</STRONG><P>
<HR>
 
<A NAME="TDOTP">
<H2>TDOTP</H2></A>
<A HREF="#TCROSSP">[Previous Routine]</A>
<A HREF="#TINTERPOL_MXN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PROCEDURE: TDOTP
Purpose:
  Vectorized routine to calculate the dot product of two tplot
  variables containing arrays of vectors and storing the results
  in a tplot variable

Arguments: 
 v1: The name of the tplot variable storing the first vector in the dot product
 v2: The name of the tplot variable storing the second vector in the
 dot product
 
 newname(optional): the name of the output tplot variable

 error(optional): named variable in which to return the error state
 of the computation.  1 = success 0 = failure

NOTES: 
</PRE><P>
<STRONG>(See <A href="special/tdotp.pro">ssl_general/cotrans/special/tdotp.pro</A>)</STRONG><P>
<HR>
 
<A NAME="TINTERPOL_MXN">
<H2>TINTERPOL_MXN</H2></A>
<A HREF="#TDOTP">[Previous Routine]</A>
<A HREF="#TNORMALIZE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
Function: tinterpol_mxn

Purpose:  Generalized interpolates across a series of vectors(since
interpol only works on 1-d vectors) This function works on any
n-dimensional vectors. Basically, this is an element by element
interpolation across M

 - i. works on tplot variables
     - ii. allows no extrapolation beyond valid data with
          /no_extrapolate keyword&quot;
              
Arguments:
            xv_tvar = tplot variable to be interpolated, the y component
            can have any dimesions, can use globbing to interpolate
            many values at once
            uses x component for x abcissa values
            
            uz_tvar = tplot variable that V will be fit to
            uses x component for u abcissa values.  Can also
            pass in an array of time values rather than a tplot 
            variable.
            
            newname = output variable name(optional) defaults to
            xv_tvar+'_interp'
            
            suffix = a suffix other than interp you can use,
            particularily useful when using globbing
            
            overwrite=set this variable if you just want
            the original variable overwritten instead of using
            newname or suffix

            Use only newname or suffix or overwrite. If you combine
            them the naming behavior may be erratic

            /LINEAR = pass this argument to specify linear
            interpolation(this is the default behavior)
            
            /QUADRATIC = pass this argument to specify quadratic
            interpolation
            
            /SPLINE = pass this argument to specify spline
            interpolation
            
            /NO_EXTRAPOLATE = pass this argument to prevent
            extrapolation of data values in V passed it's start and
            end points
            
            /NAN_EXTRAPOLATE = pass this argument to extrapolate past
            the endpoints using NaNs as a fill value

            ERROR(optional): named variable in which to return the error state
            of the computation.  1 = success 0 = failure

Outputs(optional):
   out:
     Returns output as a data struct. If this argument is present, no tplot variable will be created
     Note that only one result can be returned through this keyword.  

CALLING SEQUENCE;
           tinterpol_mxn,'tplot_var1','tplot_var2',out_var='tplot_var_out'
           tinterpol_mxn,'tplot_var1','tplot_var2',/NO_EXTRAPOLATE
           tinterpol_mxn,'tplot_var1','tplot_var2',/SPLINE
         
Output: an N by D1 by D2 by ... array stored in an output tplot variabel

Notes: 
Uses a for loop over D1*D2*..., but I'm operating under the assumption that
D1*D2... &lt;&lt; M (D1 * D2 *... is waaaay less than M)

It uses a little bit of modular arithmatic so this function is
generalized to any array dimensionality(IDL limits at 8)


Examples:
 if the input is an array of 3-d vectors(say 1,1,1 and 2,2,2) and we
 want 3 vectors out the output is 1,1,1 1.5 1.5 1.5 2,2,2
 if the input is an array of 3x3 matrices(say all ones and all twos) 
 and we want three matrices then output is all 1s all 1.5s all 2s 
 

 $LastChangedBy: pcruce $
 $LastChangedDate: 2009-12-09 14:39:12 -0800 (Wed, 09 Dec 2009) $
 $LastChangedRevision: 6983 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/ssl_general/tags/tdas_5_21/cotrans/special/tinterpol_mxn.pro $
</PRE><P>
<STRONG>(See <A href="special/tinterpol_mxn.pro">ssl_general/cotrans/special/tinterpol_mxn.pro</A>)</STRONG><P>
<HR>
 
<A NAME="TNORMALIZE">
<H2>TNORMALIZE</H2></A>
<A HREF="#TINTERPOL_MXN">[Previous Routine]</A>
<A HREF="#TVECTOR_ROTATE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
PROCEDURE: TNORMALIZE
Purpose:
  Vectorized routine to normalize all the vectors stored in a tplot
  variable


Arguments: 
 v: The name or number of the tplot variable storing the vectors to be
 normalized, or an array of vectors to be normalized.  NOTE, if the input is
 not a tplot variable, this routine will not generate a tplot variable for output
 newname(optional): The name of the output tplot variable. Defaults
 to v+'_normalized'
 error(optional): Named variable in which to return the error state
 of the computation, 1 = success, 0 = failure
 out(optional):  If set to a named variable, the output will be stored
              in out, rather than a tplot variable.
 

NOTES:

 $LastChangedBy: pcruce $
 $LastChangedDate: 2009-06-23 17:40:09 -0700 (Tue, 23 Jun 2009) $
 $LastChangedRevision: 6314 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/ssl_general/tags/tdas_5_21/cotrans/special/tnormalize.pro $
</PRE><P>
<STRONG>(See <A href="special/tnormalize.pro">ssl_general/cotrans/special/tnormalize.pro</A>)</STRONG><P>
<HR>
 
<A NAME="TVECTOR_ROTATE">
<H2>TVECTOR_ROTATE</H2></A>
<A HREF="#TNORMALIZE">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
Procedure: tvector_rotate

Purpose:  rotates a set of vectors by a set of coordinate
          transformation matrices inputs and outputs are tplot
          variables.  This is designed mainly for use with
          fac_matrix_make.pro and minvar_matrix_make, but can be used
          for more general purposes

Warning:
 The transformation matrices generated by
fac_matrix_make,thm_fac_matrix_make, and minvar_matrix_make are
defined relative to a specific coordinate system.  This means that if
you use vectors in one coordinate system to generate the rotation
matrices they will only correctly transform data from that coordinate
system into the functional coordinate system.

  For example if you use
magnetic field data in gsm to generate Rgeo transformation matrices
using fac_matrix_make then the vectors being provided to tvector
rotate to be transformed by those matrices should only be in gsm coordinates.


Arguments:

 mat_var_in: the name of the tplot variable storing input matrices
 The y component of the tplot variable's data struct should be
 an Mx3x3 array, storing a list of transformation matrices. 
 

 vec_var_in: the name of the tplot variable storing input
vectors. You can use globbing to rotate several tplot variables
storing vectors with a single matrix. The y component of the tplot variable's
 data struct should be an Nx3 array.  



 newname(optional): the name of the output variable, defaults to 
                    vec_var_in + '_rot'
                    If you use type globbing in the vector variable
                    This option will be disabled

 suffix: The suffix to be appended to the tplot variables that the output matrices will be stored in.
         (Default: '_rot')

 error(optional): named variable in which to return the error state
 of the computation.  1 = success 0 = failure
 
 
 invert(optional):  If matrix_var naturally transforms vector_var from Coord A to B,
                    (ie Vb = M#Va where # denotes matrix multiplication) then setting
                    this keyword will transform vector_var from Coord B to A( ie Va = M^T#Vb 
                    This is done by transposing the input matrices, as it is a property of 
                    rotation matrices that M#M^T = I and M^T#M = I(ie M^T = M^-1) 
                    
 vector_skip_nonmonotonic(optional): Removes any vector data with non-ascending or repeated
                            timestamps before SLERPing matrices rather than throwing an error.
                            
 matrix_skip_nonmonotonic(optional): Removes any vector data with non-ascending 
                            timestamps before SLERPing matrices rather than throwing an error.

CALLING SEQUENCE:

 tvector_rotate,'matrix_var','vector_var',newname = 'out_var',error=error

 tvector_rotate,'matrix_var','vector_var'

Notes: 
 1.  mat_var_in should store rotation or permutation matrices. 
     (ie the columns of any matrix in mat_var_in should form an orthonormal basis) 
     tvector_rotate will test and warn if input matrices are inalid.
     Permutation matrices are allowed so that coordinates can be transformed
     from right to left handed systems and vice-versa.  This is verified via the following 
     contraints.  
     M#M^-1 = I and abs(determ(m)) = 1
   
 2.  transformation matrices generally only transform from one particular basis
     to another particular basis.  Since tvector_rotate as no way to test that
     vector_var is in the correct basis, you need to be very careful that
     vector_var has the correct coordinate system and representation
     so that it can correctly transform the data.
     

3.   If M!=N, then M must be &gt;= 2 (where M,N refer to the dimensions of the
     input variables.)

4.  Also If the x components of mat_var_in and vec_var_in data structs
    do not match then, the matrices will be interpolated to match the
    cadence of the vector data.  Interpolation is done by turning the
    matrices into quaternions and performing spherical linear
    interpolation.  As noted above this interpolation behavior will
    not be predictable if the matrices do anything other than rotate.

5.  If the timestamps of mat_var_in are not monotonic(ascending or identical) or 
    if the timestamps vec_var_in are not strictly monotonic(always ascending) the
    program will not work correctly in the event that matrix SLERPing is required. 
    Set the keywords vector_skip_nonmonotonic or matrix_skip_nonmonotonic to have
    the routine remove the non-monotonic data when generating the output. Alternatively,
    if matrix and vector timestamps match no SLERPing will be required, also fixing
    nonmonotonicities manually will fix the problem.

 SEE ALSO:  mva_matrix_make.pro, fac_matrix_make.pro,rxy_matrix_make

 $LastChangedBy: pcruce $
 $LastChangedDate: 2009-09-16 15:37:17 -0700 (Wed, 16 Sep 2009) $
 $LastChangedRevision: 6742 $
 $URL: svn+ssh://thmsvn@ambrosia.ssl.berkeley.edu/repos/ssl_general/tags/tdas_5_21/cotrans/special/tvector_rotate.pro $
</PRE><P>
<STRONG>(See <A href="special/tvector_rotate.pro">ssl_general/cotrans/special/tvector_rotate.pro</A>)</STRONG><P>
<HR>
 
